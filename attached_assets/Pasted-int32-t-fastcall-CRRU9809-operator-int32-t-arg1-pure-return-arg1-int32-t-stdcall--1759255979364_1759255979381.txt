int32_t __fastcall CRRU9809::operator=(int32_t arg1) __pure
{
    return arg1;
}

int32_t __stdcall sub_10001010(int32_t arg1)
{
    if (arg1 == 0)
        DeleteCriticalSection(&data_100489fc);
    else if (arg1 == 1)
        InitializeCriticalSection(&data_100489fc);
    
    return 1;
}

int32_t sub_10001050() __pure
{
    return 3;
}

int32_t __convention("regparm") sub_10001060(int32_t* arg1, int32_t arg2, void* arg3, int32_t arg4)
{
    return sub_10008ce0(data_10045558, *arg1, arg1[1], arg2, arg3, arg4, &arg_10);
}

int32_t* __thiscall sub_10001090(int32_t* arg1, int32_t arg2)
{
    *arg1 = arg2;
    return arg1;
}

void sub_100010a0(int32_t arg1) __noreturn
{
    int32_t eax = data_10045590;
    int32_t esi = arg1;
    int32_t var_10 = esi;
    wchar16 const* const var_14 = u"AtlThrow: hr = 0x%x\n";
    int32_t var_18 = 0;
    char const* const var_8 = "E:\Program Files\Microsoft Visua…";
    int32_t var_4 = 0x40;
    void* ecx;
    int32_t edx;
    sub_10001060(&var_8, edx, ecx, eax);
    arg1 = esi;
    sub_1000ed00(&arg1, &data_100426a4);
    /* no return */
}

int32_t __fastcall sub_100010f0(int32_t* arg1)
{
    *arg1 = 0x10037f68;
    /* tailcall */
    return sub_1000c1f0(arg1);
}

int32_t* __thiscall sub_10001100(int32_t* arg1, char arg2)
{
    *arg1 = 0x10037f68;
    sub_1000c1f0(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80(arg1);
    
    return arg1;
}

char* sub_10001130(char* arg1, char* arg2)
{
    *arg1 = *arg2;
    return arg2;
}

void* sub_10001140(char* arg1)
{
    char* eax = arg1;
    char i;
    
    do
    {
        i = *eax;
        eax = &eax[1];
    } while (i != 0);
    return (eax - &eax[1]);
}

char* sub_10001160(char* arg1, int32_t arg2, int128_t* arg3, void* arg4)
{
    sub_1000ad50(arg1, arg2, arg3, arg4);
    return arg1;
}

int128_t* sub_10001190(int128_t* arg1, int32_t arg2, int128_t* arg3, void* arg4)
{
    sub_1000aee0(arg1, arg2, arg3, arg4);
    return arg1;
}

int32_t* __fastcall sub_100011c0(int32_t* arg1, int32_t** arg2 @ esi)
{
    int32_t var_4_2 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034868;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t* var_10 = arg1;
    int32_t __saved_edi;
    int32_t* result = (__security_cookie ^ &__saved_edi);
    int32_t* result_1 = result;
    fsbase->NtTib.ExceptionList = &ExceptionList;
    
    if (*arg1 != arg2)
    {
        sub_10032890(&var_10, 3);
        int32_t var_4 = 0;
        sub_10001240(arg1);
        
        if (arg2 != 0)
        {
            int32_t* eax_2 = *arg2;
            
            if (eax_2 != 0xfffffffd)
            {
                arg1[1] = eax_2;
                *arg2 = arg1;
            }
        }
        
        *arg1 = arg2;
        int32_t var_4_1 = 0xffffffff;
        result = sub_100328d0(&var_10);
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

void sub_10001240(int32_t* arg1 @ edi)
{
    int32_t* esi = *arg1;
    
    if ((esi != 0 && *esi != 0xfffffffd))
    {
        if (*esi == 0)
            sub_10032900(u"ITERATOR LIST CORRUPTED!", u"E:\Program Files\Microsoft Visua…", 0xbd);
        else
        {
            int32_t eax_1;
            
            do
            {
                eax_1 = *esi;
                
                if (eax_1 == arg1)
                    break;
                
                esi = (eax_1 + 4);
            } while (*(eax_1 + 4) != 0);
            
            if (*esi == 0)
                sub_10032900(u"ITERATOR LIST CORRUPTED!", u"E:\Program Files\Microsoft Visua…", 0xbd);
        }
        
        *esi = arg1[1];
        *arg1 = 0;
    }
}

int32_t* __fastcall sub_10001290(int32_t* arg1)
{
    int32_t* var_4 = arg1;
    sub_10032890(&var_4, 3);
    int32_t eax = *arg1;
    
    if (eax != 0xfffffffd)
    {
        if (eax != 0)
        {
            int32_t i;
            
            do
            {
                **arg1 = 0;
                i = *(*arg1 + 4);
                *arg1 = i;
            } while (i != 0);
        }
        
        *arg1 = 0;
    }
    
    return sub_100328d0(&var_4);
}

void* __fastcall sub_100012e0(void* arg1)
{
    if (*(arg1 + 0x28) < 0x10)
        return (arg1 + 0x14);
    
    return *(arg1 + 0x14);
}

int32_t* __thiscall sub_100012f0(int32_t* arg1, char arg2)
{
    *arg1 = 0x10040f7c;
    
    if (arg1[0xa] >= 0x10)
        sub_1000ab80(arg1[5]);
    
    arg1[0xa] = 0xf;
    arg1[9] = 0;
    arg1[5] = 0;
    sub_10001290(&arg1[3]);
    sub_1000c1f0(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80(arg1);
    
    return arg1;
}

int32_t* __convention("regparm") sub_10001350(void* arg1, int32_t* arg2 @ esi)
{
    int32_t ecx;
    int32_t var_4 = ecx;
    
    if (*(arg1 + 0x1c) >= 0x10)
    {
        sub_100056f0(arg2, *(arg1 + 8));
        return arg2;
    }
    
    sub_100056f0(arg2, (arg1 + 8));
    return arg2;
}

int32_t* __stdcall sub_10001380(int32_t* arg1, void* arg2)
{
    int32_t var_4_1 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034ae4;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_esi;
    int32_t var_18 = (__security_cookie ^ &__saved_esi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    sub_10032890(arg1, 0);
    int32_t var_4 = 0;
    arg1[1] = 0;
    arg1[8] = 0xf;
    arg1[7] = 0;
    arg1[3] = 0;
    arg1[9] = 0;
    arg1[0x10] = 0xf;
    arg1[0xf] = 0;
    arg1[0xb] = 0;
    arg1[0x11] = 0;
    arg1[0x18] = 0xf;
    arg1[0x17] = 0;
    arg1[0x13] = 0;
    arg1[0x19] = 0;
    arg1[0x20] = 0xf;
    arg1[0x1f] = 0;
    arg1[0x1b] = 0;
    var_4 = 4;
    sub_10032f40(arg1, arg2);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg1;
}

int32_t* __stdcall sub_10001420(int32_t* arg1)
{
    int32_t var_4_2 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_100348f4;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_edi;
    int32_t var_20 = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_4 = 4;
    sub_10032fd0(arg1);
    var_4 = 3;
    
    if (arg1[0x20] >= 0x10)
        sub_1000ab80(arg1[0x1b]);
    
    arg1[0x20] = 0xf;
    arg1[0x1f] = 0;
    arg1[0x1b] = 0;
    sub_10001290(&arg1[0x19]);
    var_4 = 2;
    
    if (arg1[0x18] >= 0x10)
        sub_1000ab80(arg1[0x13]);
    
    arg1[0x18] = 0xf;
    arg1[0x17] = 0;
    arg1[0x13] = 0;
    sub_10001290(&arg1[0x11]);
    var_4 = 1;
    
    if (arg1[0x10] >= 0x10)
        sub_1000ab80(arg1[0xb]);
    
    arg1[0x10] = 0xf;
    arg1[0xf] = 0;
    arg1[0xb] = 0;
    sub_10001290(&arg1[9]);
    var_4 = 0;
    
    if (arg1[8] >= 0x10)
        sub_1000ab80(arg1[3]);
    
    arg1[8] = 0xf;
    arg1[7] = 0;
    arg1[3] = 0;
    sub_10001290(&arg1[1]);
    int32_t var_4_1 = 0xffffffff;
    int32_t* result = sub_100328d0(arg1);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t* __thiscall sub_10001530(int32_t* arg1, void* arg2)
{
    int32_t var_4_1 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034a88;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t* var_10 = arg1;
    int32_t __saved_edi;
    int32_t var_1c = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_10_1 = arg1;
    sub_1000c150(arg1, arg2);
    int32_t var_4 = 0;
    *arg1 = 0x10040f7c;
    sub_10005790(&arg1[3], (arg2 + 0xc));
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg1;
}

int32_t* __fastcall sub_100015a0(void* arg1)
{
    void* var_4 = arg1;
    sub_10032890(&var_4, 0);
    int32_t eax = *(arg1 + 4);
    
    if (eax < 0xffffffff)
        *(arg1 + 4) = (eax + 1);
    
    return sub_100328d0(&var_4);
}

void* __fastcall sub_100015d0(void* arg1)
{
    void* var_4 = arg1;
    sub_10032890(&var_4, 0);
    int32_t eax = *(arg1 + 4);
    
    if ((eax > 0 && eax < 0xffffffff))
        *(arg1 + 4) = (eax - 1);
    
    int32_t esi = *(arg1 + 4);
    int32_t esi_1 = -(esi);
    sub_100328d0(&var_4);
    return (!((esi_1 - esi_1)) & arg1);
}

void* j_sub_10033b20(int32_t arg1, int32_t* arg2, int32_t arg3, int32_t arg4)
{
    /* tailcall */
    return sub_10033b20(arg1, arg2, arg3, arg4);
}

void sub_10001620(int32_t* arg1)
{
    if (arg1 != 0)
    {
        **arg1(0);
        __mktime32(arg1);
    }
}

int32_t __fastcall sub_10001640(int32_t* arg1)
{
    *arg1 = 0x10040144;
}

int32_t* __thiscall sub_10001650(int32_t* arg1, int32_t arg2)
{
    *arg1 = 0x10040144;
    arg1[1] = arg2;
    return arg1;
}

void __fastcall sub_10001670(int32_t* arg1)
{
    int32_t* var_4 = arg1;
    void* edi = *arg1;
    
    if (edi != 0)
    {
        sub_10032890(&var_4, 0);
        int32_t eax_1 = *(edi + 4);
        
        if ((eax_1 > 0 && eax_1 < 0xffffffff))
            *(edi + 4) = (eax_1 - 1);
        
        int32_t esi_1 = *(edi + 4);
        int32_t esi_2 = -(esi_1);
        void* esi_5 = (!((esi_2 - esi_2)) & edi);
        sub_100328d0(&var_4);
        
        if (esi_5 != 0)
        {
            **esi_5(0);
            __mktime32(esi_5);
        }
    }
}

int32_t* __stdcall sub_100016d0(int32_t* arg1)
{
    int32_t var_4_1 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034d61;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_edi;
    int32_t var_44 = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_30 = 0;
    int32_t* i_1;
    sub_10001350((*arg_4 + 0x18), &i_1);
    int32_t var_4 = 1;
    sub_10005790(arg1, &i_1);
    var_4 = 0;
    int32_t var_30_1 = 1;
    int32_t var_10;
    char var_24;
    
    if (var_10 >= 0x10)
        sub_1000ab80(var_24);
    int32_t var_10_1 = 0xf;
    int32_t var_14 = 0;
    char var_24_1 = 0;
    sub_10032890(&arg_4, 3);
    int32_t* i = i_1;
    
    if (i != 0xfffffffd)
    {
        while (i != 0)
        {
            *i = 0;
            i = i_1[1];
            i_1 = i;
        }
        
        i_1 = nullptr;
    }
    
    sub_100328d0(&arg_4);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg1;
}

int32_t sub_100017b0() __pure
{
    int32_t result;
    result = 1;
    return result;
}

int32_t sub_100017c0() __pure
{
    return 1;
}

int32_t* sub_100017d0(int32_t* arg1 @ esi)
{
    arg1[1] = 0;
    *arg1 = 0x10040f88;
    void var_14;
    int32_t* eax = sub_10033a90(&var_14);
    arg1[2] = *eax;
    arg1[3] = eax[1];
    arg1[4] = eax[2];
    arg1[5] = eax[3];
    return arg1;
}

int32_t sub_10001810(int32_t* arg1 @ edi, int32_t* arg2)
{
    int32_t var_c = 0xffffffff;
    int32_t (* var_10)(void* arg1) = sub_10034e93;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_esi;
    int32_t var_d4 = (__security_cookie ^ &__saved_esi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t ebx = 0;
    int32_t var_c8 = 0;
    
    if ((arg1 != 0 && *arg1 == 0))
    {
        int32_t var_a0_1 = 0x100401e0;
        int32_t* esi_1 = sub_10033b20(0x18, &data_100401e0, "E:\Program Files\Microsoft Visua…", 0x700);
        int32_t* var_a4_1 = esi_1;
        int32_t* eax_4 = nullptr;
        int32_t var_c_1 = 0;
        int32_t* i_1;
        void var_9c;
        
        if (esi_1 != 0)
        {
            int32_t* var_d8_1 = &i_1;
            int32_t* eax_5 = sub_100016d0(arg2);
            var_c_1 = 1;
            var_c8 = 1;
            sub_10001380(&var_9c, eax_5);
            ebx = 3;
            eax_4 = sub_100017d0(esi_1);
        }
        
        int32_t var_c_2 = 2;
        *arg1 = eax_4;
        
        if ((ebx & 2) != 0)
        {
            ebx &= 0xfffffffd;
            var_c8 = ebx;
            sub_10001420(&var_9c);
        }
        
        int32_t var_c_3 = 0xffffffff;
        
        if ((ebx & 1) != 0)
        {
            int32_t var_a8;
            char var_bc;
            
            if (var_a8 >= 0x10)
                sub_1000ab80(var_bc);
            int32_t var_a8_1 = 0xf;
            int32_t var_ac_1 = 0;
            char var_bc_1 = 0;
            sub_10032890(&var_c8, 3);
            int32_t* i = i_1;
            
            if (i != 0xfffffffd)
            {
                while (i != 0)
                {
                    *i = 0;
                    i = i_1[1];
                    i_1 = i;
                }
                
                i_1 = nullptr;
            }
            
            sub_100328d0(&var_c8);
        }
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return 2;
}

uint32_t __thiscall sub_10001970(void* arg1, char arg2)
{
    return sub_10033910(arg2, (arg1 + 8));
}

char* __thiscall sub_10001990(void* arg1, char* arg2, int32_t arg3)
{
    char* result = arg2;
    
    if (result != arg3)
    {
        if (result == 0)
            sub_10032900(u"invalid null pointer", u"E:\Program Files\Microsoft Visua…", 0x723);
        
        if (arg3 == 0)
            sub_10032900(u"invalid null pointer", u"E:\Program Files\Microsoft Visua…", 0x723);
        
        if (arg3 < result)
            sub_10032900(u"invalid iterator range", u"E:\Program Files\Microsoft Visua…", 0x723);
        
        do
        {
            *result = sub_10033910(*result, (arg1 + 8));
            result = &result[1];
        } while (result != arg3);
    }
    
    return result;
}

uint32_t __thiscall sub_10001a20(void* arg1, char arg2)
{
    return sub_10033bf0(arg2, (arg1 + 8));
}

char* __thiscall sub_10001a40(void* arg1, char* arg2, int32_t arg3)
{
    char* result = arg2;
    
    if (result != arg3)
    {
        if (result == 0)
            sub_10032900(u"invalid null pointer", u"E:\Program Files\Microsoft Visua…", 0x731);
        
        if (arg3 == 0)
            sub_10032900(u"invalid null pointer", u"E:\Program Files\Microsoft Visua…", 0x731);
        
        if (arg3 < result)
            sub_10032900(u"invalid iterator range", u"E:\Program Files\Microsoft Visua…", 0x731);
        
        do
        {
            *result = sub_10033bf0(*result, (arg1 + 8));
            result = &result[1];
        } while (result != arg3);
    }
    
    return result;
}

int32_t __stdcall sub_10001ad0(char arg1) __pure
{
    int32_t result;
    result = arg1;
    return result;
}

int32_t __thiscall sub_10001ae0(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    return *(*arg1 + 0x1c)(arg2, arg3, arg4, (arg3 - arg2));
}

int32_t __stdcall sub_10001b10(int128_t* arg1, int32_t arg2, char* arg3, int32_t arg4)
{
    if (arg1 != arg2)
    {
        if (arg1 == 0)
            sub_10032900(u"invalid null pointer", u"E:\Program Files\Microsoft Visua…", 0x747);
        
        if (arg2 == 0)
            sub_10032900(u"invalid null pointer", u"E:\Program Files\Microsoft Visua…", 0x747);
        
        if (arg2 < arg1)
            sub_10032900(u"invalid iterator range", u"E:\Program Files\Microsoft Visua…", 0x747);
    }
    
    if (arg3 == 0)
        sub_10032900(u"invalid null pointer", u"E:\Program Files\Microsoft Visua…", 0x748);
    
    void* esi_1 = (arg2 - arg1);
    
    if (arg4 < esi_1)
    {
        if (sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x749, nullptr, u"("_Dest_size >= (size_t)(_Last -…") == 1)
            breakpoint();
        
        sub_1000c310(u""out of range"", u"std::ctype<char>::_Do_widen_s", u"E:\Program Files\Microsoft Visua…", 0x749, 0);
    }
    
    sub_1000ad50(arg3, arg4, arg1, esi_1);
    return arg2;
}

int32_t __stdcall sub_10001c00(char arg1) __pure
{
    int32_t result;
    result = arg1;
    return result;
}

int32_t __thiscall sub_10001c10(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)
{
    return *(*arg1 + 0x28)(arg2, arg3, arg4, arg5, (arg3 - arg2));
}

int32_t __stdcall sub_10001c40(int128_t* arg1, int32_t arg2, char* arg3, int32_t arg4)
{
    if (arg1 != arg2)
    {
        if (arg1 == 0)
            sub_10032900(u"invalid null pointer", u"E:\Program Files\Microsoft Visua…", 0x760);
        
        if (arg2 == 0)
            sub_10032900(u"invalid null pointer", u"E:\Program Files\Microsoft Visua…", 0x760);
        
        if (arg2 < arg1)
            sub_10032900(u"invalid iterator range", u"E:\Program Files\Microsoft Visua…", 0x760);
    }
    
    if (arg3 == 0)
        sub_10032900(u"invalid null pointer", u"E:\Program Files\Microsoft Visua…", 0x761);
    
    void* esi_1 = (arg2 - arg1);
    
    if (arg4 < esi_1)
    {
        if (sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x762, nullptr, u"("_Dest_size >= (size_t)(_Last -…") == 1)
            breakpoint();
        
        sub_1000c310(u""out of range"", u"std::ctype<char>::_Do_narrow_s", u"E:\Program Files\Microsoft Visua…", 0x762, 0);
    }
    
    sub_1000ad50(arg3, arg4, arg1, esi_1);
    return arg2;
}

int32_t* __thiscall sub_10001d30(int32_t* arg1, char arg2)
{
    int32_t eax = arg1[5];
    *arg1 = 0x10040f88;
    
    if (eax > 0)
        __mktime32(arg1[4]);
    else if (eax < 0)
        Concurrency::set_task_execution_resources(arg1[4]);
    
    *arg1 = 0x10040144;
    
    if ((arg2 & 1) != 0)
    {
        sub_10007700(arg1, 0);
        __mktime32(arg1);
    }
    
    return arg1;
}

int32_t* __stdcall sub_10001d80(int32_t* arg1, int32_t* arg2)
{
    int32_t var_4_1 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034c98;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_esi;
    int32_t var_14 = (__security_cookie ^ &__saved_esi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    Concurrency::details::_MallocaArrayHolder<class Concurrency::event*>::_MallocaArrayHolder<class Concurrency::event*>(arg1);
    int32_t var_4 = 0;
    *arg1 = 0x10040f7c;
    sub_10005790(&arg1[3], arg2);
    *arg1 = 0x10040fb8;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg1;
}

int32_t __fastcall sub_10001df0(int32_t* arg1)
{
    *arg1 = 0x10040f7c;
    
    if (arg1[0xa] >= 0x10)
        sub_1000ab80(arg1[5]);
    
    arg1[0xa] = 0xf;
    arg1[9] = 0;
    arg1[5] = 0;
    sub_10001290(&arg1[3]);
    /* tailcall */
    return sub_1000c1f0(arg1);
}

int32_t __thiscall sub_10001e30(void* arg1, int32_t arg2)
{
    int32_t var_c = 0xffffffff;
    int32_t (* var_10)(void* arg1) = sub_10034d1e;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    void var_b0;
    int32_t var_b4 = (__security_cookie ^ &var_b0);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result = (arg2 & 0x17);
    *(arg1 + 8) = result;
    int32_t ecx_1 = (*(arg1 + 0xc) & result);
    
    if (ecx_1 == 0)
    {
        fsbase->NtTib.ExceptionList = ExceptionList;
        return result;
    }
    
    void var_90;
    
    if ((ecx_1 & 4) != 0)
    {
        sub_100056f0(&var_b0, "ios_base::badbit set");
        int32_t var_c_1 = 0;
        sub_10001d80(&var_90, &var_b0);
        sub_1000ed00(&var_90, &data_10042718);
        /* no return */
    }
    
    if ((ecx_1 & 2) == 0)
    {
        void var_64;
        sub_100056f0(&var_64, "ios_base::eofbit set");
        int32_t var_c_3 = 2;
        void var_44;
        sub_10001d80(&var_44, &var_64);
        sub_1000ed00(&var_44, &data_10042718);
        /* no return */
    }
    
    sub_100056f0(&var_b0, "ios_base::failbit set");
    int32_t var_c_2 = 1;
    sub_10001d80(&var_90, &var_b0);
    sub_1000ed00(&var_90, &data_10042718);
    /* no return */
}

int32_t* __convention("regparm") sub_10001f40(void* arg1, int32_t* arg2 @ edi)
{
    void* esi = **(arg1 + 0x24);
    *arg2 = esi;
    int32_t __saved_ecx;
    sub_10032890(&__saved_ecx, 0);
    int32_t eax = *(esi + 4);
    
    if (eax < 0xffffffff)
        *(esi + 4) = (eax + 1);
    
    sub_100328d0(&__saved_ecx);
    return arg2;
}

void* sub_10001f70(void* arg1 @ esi)
{
    *(arg1 + 0x24) = 0;
    *(arg1 + 4) = 0;
    *(arg1 + 0xc) = 0;
    *(arg1 + 0x10) = 0x201;
    *(arg1 + 0x14) = 6;
    *(arg1 + 0x18) = 0;
    *(arg1 + 0x1c) = 0;
    *(arg1 + 0x20) = 0;
    sub_10001e30(arg1, 0);
    void* eax = sub_10033b20(4, &data_100401e0, "E:\Program Files\Microsoft Visua…", 0x20d);
    
    if (eax == 0)
    {
        *(arg1 + 0x24) = 0;
        return eax;
    }
    
    *eax = sub_10032cf0();
    void* eax_2 = __CrtGetAllocHook();
    int32_t __saved_ecx;
    sub_10032890(&__saved_ecx, 0);
    int32_t eax_3 = *(eax_2 + 4);
    
    if (eax_3 < 0xffffffff)
        *(eax_2 + 4) = (eax_3 + 1);
    
    int32_t* eax_5 = sub_100328d0(&__saved_ecx);
    *(arg1 + 0x24) = eax;
    return eax_5;
}

int32_t* __thiscall sub_10002000(int32_t* arg1, void* arg2)
{
    sub_10001530(arg1, arg2);
    *arg1 = 0x10040fb8;
    return arg1;
}

uint32_t __convention("regparm") sub_10002020(char** arg1, int32_t arg2, char arg3)
{
    uint32_t result;
    result = sub_1000c720(arg3, arg1) != 0xffffffff;
    return result;
}

int32_t* __fastcall sub_10002040(void* arg1)
{
    sub_10005c00((arg1 + 0x5c));
    *(arg1 + 0x5c) = &data_10040ec4;
    return sub_10033d70((arg1 + 0x5c));
}

int32_t fnRRU9809() __pure
{
    return 0x2a;
}

int32_t __stdcall _OpenCom@8(int32_t arg1, char arg2)
{
    int32_t lpCommTimeouts;
    int32_t eax_1 = (__security_cookie ^ &lpCommTimeouts);
    
    if (arg1 <= 0xc)
    {
        void var_24;
        wsprintfW(&var_24, u"COM%d:", arg1);
        HANDLE hFile = CreateFileW(&var_24, 0xc0000000, FILE_SHARE_NONE, nullptr, OPEN_EXISTING, SECURITY_ANONYMOUS, nullptr);
        *((arg1 << 2) + &data_10048a1c) = hFile;
        
        if (hFile != 0xffffffff)
        {
            data_10048a50 = 0x1c;
            GetCommState(hFile, &data_10048a50);
            uint32_t eax_4 = arg2;
            
            if (eax_4 > 6)
                goto label_10002146;
            
            switch (eax_4)
            {
                case 0:
                {
                    data_10048a54 = 0x2580;
                label_10002146:
                    HANDLE hFile_1 = *((arg1 << 2) + &data_10048a1c);
                    data_10048a63 = 0;
                    data_10048a64 = 0;
                    data_10048a62 = 8;
                    
                    if (SetCommState(hFile_1, &data_10048a50) != 0)
                    {
                        GetCommTimeouts(&data_10048a1c, &lpCommTimeouts);
                        __builtin_memcpy(&lpCommTimeouts, "\x0a\x00\x00\x00\x05\x00\x00\x00\x0a\x00\x00\x00\x14\x00\x00\x00\x14\x00\x00\x00", 0x14);
                        
                        if (SetCommTimeouts(*((arg1 << 2) + &data_10048a1c), &lpCommTimeouts) == 0)
                        {
                            CloseHandle(*((arg1 << 2) + &data_10048a1c));
                            return sub_1000ac70((eax_1 ^ &lpCommTimeouts));
                        }
                        
                        SetCommMask(*((arg1 << 2) + &data_10048a1c), EV_RXCHAR);
                        SetupComm(*((arg1 << 2) + &data_10048a1c), 0x400, 0x400);
                        PurgeComm(*((arg1 << 2) + &data_10048a1c), PURGE_RXABORT | PURGE_RXCLEAR | PURGE_TXABORT | PURGE_TXCLEAR);
                        return sub_1000ac70((eax_1 ^ &lpCommTimeouts));
                    }
                    
                    CloseHandle(*((arg1 << 2) + &data_10048a1c));
                    break;
                }
                case 1:
                {
                    data_10048a54 = 0x4b00;
                    goto label_10002146;
                }
                case 2:
                {
                    data_10048a54 = 0x9600;
                    goto label_10002146;
                }
                case 4:
                {
                    data_10048a54 = 0xdac0;
                    goto label_10002146;
                }
                case 5:
                {
                    data_10048a54 = 0xe100;
                    goto label_10002146;
                }
                case 6:
                {
                    data_10048a54 = 0x1c200;
                    goto label_10002146;
                }
            }
        }
    }
    
    return sub_1000ac70((eax_1 ^ &lpCommTimeouts));
}

int32_t CloseComPort()
{
    EnterCriticalSection(&data_100489fc);
    
    for (void* i = nullptr; i < 0x30; i += 4)
    {
        HANDLE hObject = *(i + 0x10048a20);
        
        if ((hObject != 0xffffffff && CloseHandle(hObject) != 0))
        {
            *(i + 0x10048a20) = 0xffffffff;
            *(i + 0x100475d4) = 0;
        }
    }
    
    LeaveCriticalSection(&data_100489fc);
    return 0;
}

int32_t __stdcall CloseSpecComPort(int32_t arg1)
{
    EnterCriticalSection(&data_100489fc);
    HANDLE hObject = *((arg1 << 2) + &data_10048a1c);
    
    if (hObject == 0xffffffff)
    {
        LeaveCriticalSection(&data_100489fc);
        return 0;
    }
    
    if (CloseHandle(hObject) == 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x30;
    }
    
    *((arg1 << 2) + &data_100475d0) = 0;
    *((arg1 << 2) + &data_10048a1c) = 0xffffffff;
    LeaveCriticalSection(&data_100489fc);
    return 0;
}

int32_t __fastcall sub_10002350(int32_t arg1, int16_t* arg2, void* arg3)
{
    int32_t var_4_2 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034cd8;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    void var_4c;
    int32_t eax_2 = (__security_cookie ^ &var_4c);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    
    if (arg3 != 0)
    {
        int32_t __saved_edi;
        int16_t* var_48 = (*(data_100455d4 + 0xc)((__security_cookie ^ &__saved_edi)) + 0x10);
        int32_t var_4 = 0;
        void* var_44 = (*(data_100455d4 + 0xc)() + 0x10);
        var_4 = 1;
        wchar16* lpWideCharStr = (*(data_100455d4 + 0xc)() + 0x10);
        wchar16* lpWideCharStr_1 = lpWideCharStr;
        var_4 = 2;
        sub_10005680(&var_44);
        sub_10005680(&var_48);
        uint32_t var_64_1 = *arg2;
        sub_10008110(&var_48, &data_10040804);
        int16_t* eax_16 = var_48;
        sub_10007af0(&var_44, eax_16, *(eax_16 - 0xc));
        uint32_t var_64_3 = arg2[1];
        sub_10008110(&var_48, &data_10040804);
        int16_t* eax_18 = var_48;
        sub_10007af0(&var_44, eax_18, *(eax_18 - 0xc));
        int32_t esi_1 = 0;
        
        if (arg1 > 0)
        {
            do
            {
                uint32_t var_64_5 = *(arg3 + esi_1);
                sub_10008110(&var_48, u"%02X ");
                int16_t* eax_20 = var_48;
                sub_10007af0(&var_44, eax_20, *(eax_20 - 0xc));
                esi_1 += 1;
            } while (esi_1 < arg1);
        }
        
        int32_t var_64_7 = 0x3b;
        sub_10008110(&var_48, &data_10040804);
        int16_t* eax_21 = var_48;
        sub_10007af0(&var_44, eax_21, *(eax_21 - 0xc));
        int16_t lpSystemTime;
        GetLocalTime(&lpSystemTime);
        int32_t var_28 = 0;
        int32_t var_24_1 = 0;
        int16_t var_20_1 = 0;
        char var_36;
        *var_28[2] = var_36;
        char var_32;
        var_24_1 = var_32;
        char var_2e;
        uint16_t var_20_2 = var_2e;
        var_28 = (lpSystemTime % 0x64);
        char var_30;
        *var_24_1[2] = var_30;
        int32_t eax_26;
        int32_t edx_5;
        eax_26 = MultiByteToWideChar(3, 0, &data_10040802, 0xffffffff, nullptr, 0);
        
        if ((eax_26 - 1) <= 0)
            sub_10006c50();
        else
        {
            if (((*(lpWideCharStr - 8) - (eax_26 - 1)) | (1 - *(lpWideCharStr - 4))) < 0)
            {
                sub_10007c20(&lpWideCharStr_1, edx_5, (eax_26 - 1));
                lpWideCharStr = lpWideCharStr_1;
            }
            
            MultiByteToWideChar(3, 0, &data_10040802, 0xffffffff, lpWideCharStr, (eax_26 - 1));
            sub_10007730((eax_26 - 1), &lpWideCharStr_1);
        }
        
        int16_t* ebx_1;
        
        for (int32_t i = 0; i < 5; i += 1)
        {
            uint32_t var_64_11 = *(&var_28 + (i << 1));
            sub_10008110(&var_48, u"%02d");
            ebx_1 = var_48;
            sub_10007af0(&lpWideCharStr_1, ebx_1, *(ebx_1 - 0xc));
        }
        
        sub_10007af0(&lpWideCharStr_1, u".log", 4);
        wchar16* lpWideCharStr_2 = lpWideCharStr_1;
        int32_t* var_3c = nullptr;
        sub_1000d1a0(&var_3c, lpWideCharStr_2, &data_10040830);
        int16_t var_2a;
        uint32_t var_70_1 = var_2a;
        int16_t var_2c;
        uint32_t var_74_1 = var_2c;
        uint32_t var_78_1 = var_2e;
        uint32_t var_7c_1 = var_30;
        sub_1000d240(var_3c, u"[%02d:%02d:%02d %03d]; ");
        sub_1000d540(var_3c, var_44, &lpWideCharStr_1);
        sub_1000d240(var_3c, &data_10040868);
        sub_1000d570(var_3c);
        sub_1000d900(var_3c);
        var_4 = 1;
        
        if ((*(lpWideCharStr_2 - 4) == 0 && sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x6b, nullptr, u"nRefs != 0") == 1))
            breakpoint();
        
        int32_t edx_8 = *(lpWideCharStr_2 - 4);
        *(lpWideCharStr_2 - 4) -= 1;
        
        if ((edx_8 - 1) <= 0)
            *(**(lpWideCharStr_2 - 0x10) + 4)(&lpWideCharStr_2[-8]);
        
        var_4 = 0;
        int32_t* esi_6 = (var_44 - 0x10);
        
        if ((esi_6[3] == 0 && sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x6b, nullptr, u"nRefs != 0") == 1))
            breakpoint();
        
        int32_t eax_39 = esi_6[3];
        esi_6[3] -= 1;
        
        if ((eax_39 - 1) <= 0)
            *(**esi_6 + 4)(esi_6);
        
        int32_t var_4_1 = 0xffffffff;
        
        if ((*(ebx_1 - 4) == 0 && sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x6b, nullptr, u"nRefs != 0") == 1))
            breakpoint();
        
        int32_t ecx_17 = *(ebx_1 - 4);
        *(ebx_1 - 4) -= 1;
        
        if ((ecx_17 - 1) <= 0)
            *(**(ebx_1 - 0x10) + 4)(&ebx_1[-8]);
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return sub_1000ac70((eax_2 ^ &var_4c));
}

int32_t __thiscall SendDataToPort(int32_t arg1, uint8_t* arg2, uint32_t arg3, int32_t arg4)
{
    int32_t lpNumberOfBytesWritten = arg1;
    HANDLE hFile = *((arg4 << 2) + &data_10048a1c);
    
    if (hFile == 0xffffffff)
        return 0x37;
    
    PurgeComm(hFile, PURGE_RXABORT | PURGE_RXCLEAR | PURGE_TXABORT | PURGE_TXCLEAR);
    WriteFile(*((arg4 << 2) + &data_10048a1c), arg2, arg3, &lpNumberOfBytesWritten, nullptr);
    
    if (lpNumberOfBytesWritten != arg3)
        return 0x30;
    
    if (*((arg4 << 2) + &data_10047604) != 0)
        sub_10002350(arg3, &data_1004086c, arg2);
    
    return 0;
}

int32_t __stdcall GetDataFromPort(int32_t* arg1, int32_t arg2)
{
    __chkstk(0x20e4);
    void var_8;
    int32_t eax_1 = (__security_cookie ^ &var_8);
    char* lpBuffer_1 = lpBuffer;
    
    if (*((arg2 << 2) + &data_10048a1c) == 0xffffffff)
        return sub_1000ac70((eax_1 ^ &var_8));
    
    int32_t __saved_ebp = 0x3e8;
    
    if (data_10048acc != 0)
        __saved_ebp = (data_100489f8 * 0x64);
    
    *arg1 = 0;
    sub_1000fae0(&lpBuffer, 0, 0x20d0);
    data_10048a18 = GetTickCount();
    int32_t eax_10;
    
    do
    {
        if (ReadFile(*((arg2 << 2) + &data_10048a1c), &lpBuffer, 0x64, &__return_addr, nullptr) != 0)
        {
            void* const __return_addr_1 = __return_addr;
            
            if (__return_addr_1 > 0)
            {
                sub_10013c90((*arg1 + lpBuffer_1), &lpBuffer, __return_addr_1);
                void* const __return_addr_2 = __return_addr;
                *arg1 += __return_addr_2;
                
                if (*((arg2 << 2) + &data_10047604) != 0)
                    sub_10002350(__return_addr_2, &data_10040874, &lpBuffer);
            }
            
            __return_addr_1 = *lpBuffer_1;
            
            if (((__return_addr_1 + 1) == *arg1 && __return_addr_1 > 3))
                return sub_1000ac70((eax_1 ^ &var_8));
        }
        
        uint32_t eax_9 = GetTickCount();
        data_10048a14 = eax_9;
        eax_10 = (eax_9 - data_10048a18);
        
        if ((eax_10 > 0x1f4 && *arg1 == 0))
            break;
    } while (eax_10 <= __saved_ebp);
    return sub_1000ac70((eax_1 ^ &var_8));
}

uint8_t __stdcall GetCRC(int32_t arg1, int32_t arg2)
{
    void* ecx = nullptr;
    uint32_t eax = 0xffff;
    
    if (arg2 > 0)
    {
        do
        {
            uint32_t eax_1 = (eax ^ *(ecx + arg1));
            
            if ((eax_1 & 1) != 0)
                eax_1 ^= 0x10810;
            
            uint32_t eax_2 = (eax_1 >> 1);
            
            if ((eax_2 & 1) != 0)
                eax_2 ^= 0x10810;
            
            uint32_t eax_3 = (eax_2 >> 1);
            
            if ((eax_3 & 1) != 0)
                eax_3 ^= 0x10810;
            
            uint32_t eax_4 = (eax_3 >> 1);
            
            if ((eax_4 & 1) != 0)
                eax_4 ^= 0x10810;
            
            uint32_t eax_5 = (eax_4 >> 1);
            
            if ((eax_5 & 1) != 0)
                eax_5 ^= 0x10810;
            
            uint32_t eax_6 = (eax_5 >> 1);
            
            if ((eax_6 & 1) != 0)
                eax_6 ^= 0x10810;
            
            uint32_t eax_7 = (eax_6 >> 1);
            
            if ((eax_7 & 1) != 0)
                eax_7 ^= 0x10810;
            
            uint32_t eax_8 = (eax_7 >> 1);
            
            if ((eax_8 & 1) != 0)
                eax_8 ^= 0x10810;
            
            ecx += 1;
            eax = (eax_8 >> 1);
        } while (ecx < arg2);
    }
    
    *(ecx + arg1) = eax;
    uint8_t result = (eax >> 8);
    *((ecx + arg1) + 1) = result;
    return result;
}

int32_t __stdcall CheckCRC(char* arg1, int32_t arg2)
{
    GetCRC(arg1, arg2);
    
    if ((arg1[(arg2 + 1)] == 0 && arg1[arg2] == 0))
        return 0;
    
    return 0x31;
}

int32_t __stdcall GetQueryDataFromPort(void* arg1)
{
    int32_t ebp;
    int32_t var_4 = ebp;
    __chkstk(0x628c);
    void var_8;
    int32_t eax_1 = (__security_cookie ^ &var_8);
    int32_t* lpNumberOfBytesRead_1 = lpNumberOfBytesRead;
    int32_t edi = arg_c;
    __return_addr = arg1;
    int32_t* lpNumberOfBytesRead_4 = lpNumberOfBytesRead_1;
    
    if (*((edi << 2) + &data_10048a1c) == 0xffffffff)
        return sub_1000ac70((eax_1 ^ &var_8));
    
    CRITICAL_SECTION* lpNumberOfBytesRead_3 = &data_100489fc;
    EnterCriticalSection(lpNumberOfBytesRead_3);
    arg1 = 0x3e8;
    
    if (data_10048acc != 0)
        arg1 = (data_100489f8 * 0x64);
    
    lpNumberOfBytesRead_3 = 0x20d0;
    *lpNumberOfBytesRead_1 = 0;
    sub_1000fae0(&arg_c, 0, lpNumberOfBytesRead_3);
    data_10048a18 = GetTickCount();
    
    while (true)
    {
        lpNumberOfBytesRead_3 = 0x20d0;
        lpNumberOfBytesRead = nullptr;
        sub_1000fae0(&lpBuffer, 0, lpNumberOfBytesRead_3);
        HANDLE hFile = *((edi << 2) + &data_10048a1c);
        lpNumberOfBytesRead_3 = nullptr;
        
        if (ReadFile(hFile, &lpBuffer, 0x64, &lpNumberOfBytesRead, lpNumberOfBytesRead_3) != 0)
        {
            CRITICAL_SECTION* lpNumberOfBytesRead_2 = lpNumberOfBytesRead;
            
            if (lpNumberOfBytesRead_2 > 0)
            {
                void* ecx_3 = *lpNumberOfBytesRead_1;
                lpNumberOfBytesRead_3 = lpNumberOfBytesRead_2;
                sub_10013c90((ecx_3 + 0x10047670), &lpBuffer, lpNumberOfBytesRead_3);
                *lpNumberOfBytesRead_1 += lpNumberOfBytesRead_2;
                
                if (*((edi << 2) + &data_10047604) != 0)
                {
                    lpNumberOfBytesRead_3 = &lpBuffer;
                    sub_10002350(lpNumberOfBytesRead_2, &data_10040874, lpNumberOfBytesRead_3);
                }
            }
            
            CRITICAL_SECTION* lpNumberOfBytesRead_5 = *lpNumberOfBytesRead_1;
            lpNumberOfBytesRead_3 = lpNumberOfBytesRead_5;
            sub_10013c90(&arg_c, &data_10047670, lpNumberOfBytesRead_3);
            int32_t edi_2 = (arg_c + 1);
            
            if (lpNumberOfBytesRead_5 >= edi_2)
            {
                while (true)
                {
                    lpNumberOfBytesRead_1 = *arg_c[3];
                    
                    if (((((lpNumberOfBytesRead_1 == 1 || lpNumberOfBytesRead_1 == 2) || lpNumberOfBytesRead_1 == 3) || lpNumberOfBytesRead_1 == 4) || lpNumberOfBytesRead_1 == 0xfb))
                    {
                        lpNumberOfBytesRead_3 = 0x20d0;
                        sub_1000fae0(&arg_41ac, 0, lpNumberOfBytesRead_3);
                        
                        if (lpNumberOfBytesRead_5 >= edi_2)
                        {
                            if (lpNumberOfBytesRead_5 != edi_2)
                            {
                            label_10002b80:
                                
                                if ((lpNumberOfBytesRead_1 == 0xfb || lpNumberOfBytesRead_1 == 1))
                                {
                                    if (edi_2 == lpNumberOfBytesRead_5)
                                    {
                                    label_10002c22:
                                        lpNumberOfBytesRead_3 = *lpNumberOfBytesRead_4;
                                        sub_10013c90(__return_addr, &data_10047670, lpNumberOfBytesRead_3);
                                        lpNumberOfBytesRead_3 = &data_100489fc;
                                        LeaveCriticalSection(lpNumberOfBytesRead_3);
                                        return sub_1000ac70((eax_1 ^ &var_8));
                                    }
                                }
                                else if ((lpNumberOfBytesRead_1 == 2 && edi_2 == lpNumberOfBytesRead_5))
                                    goto label_10002c22;
                                
                                uint32_t eax_9 = arg_c;
                                lpNumberOfBytesRead_5 += (0xffffffff - eax_9);
                                lpNumberOfBytesRead_3 = lpNumberOfBytesRead_5;
                                sub_10013c90(&arg_41ac, ((&lpNumberOfBytesRead_3 + eax_9) + 0x25), lpNumberOfBytesRead_3);
                                lpNumberOfBytesRead_3 = 0x20d0;
                                sub_1000fae0(&arg_c, 0, lpNumberOfBytesRead_3);
                                lpNumberOfBytesRead_3 = lpNumberOfBytesRead_5;
                                sub_10013c90(&arg_c, &arg_41ac, lpNumberOfBytesRead_3);
                                edi_2 = (arg_c + 1);
                                
                                if (lpNumberOfBytesRead_5 >= edi_2)
                                    continue;
                            }
                            else if ((lpNumberOfBytesRead_1 != 3 && lpNumberOfBytesRead_1 != 4))
                                goto label_10002b80;
                        }
                    }
                    
                    lpNumberOfBytesRead_1 = lpNumberOfBytesRead_4;
                    break;
                }
            }
        }
        
        uint32_t eax_11 = GetTickCount();
        data_10048a14 = eax_11;
        int32_t eax_12 = (eax_11 - data_10048a18);
        
        if (eax_12 <= 0x3e8)
        {
            if (eax_12 > arg1)
                goto label_10002c55;
        }
        else if ((*lpNumberOfBytesRead_1 == 0 || eax_12 > arg1))
        {
        label_10002c55:
            lpNumberOfBytesRead_3 = &data_100489fc;
            LeaveCriticalSection(lpNumberOfBytesRead_3);
            return sub_1000ac70((eax_1 ^ &var_8));
        }
        
        edi = arg_c;
    }
}

uint32_t __stdcall GetReaderInformation(char* arg1, int16_t* arg2, char* arg3, int16_t* arg4, char* arg5, char* arg6, char* arg7, char* arg8, int32_t arg9)
{
    EnterCriticalSection(&data_100489fc);
    data_10048a71 = *arg1;
    data_10048a72 = 0x21;
    data_10048a70 = 4;
    GetCRC(0x10048a70, 3);
    sub_1000fae0(&data_10047670, 0, 0x1388);
    uint32_t ecx_1 = (data_10048a70 + 1);
    data_1004766c = 0;
    SendDataToPort(ecx_1, &data_10048a70, ecx_1, arg9);
    int32_t var_c_1 = arg9;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    if (data_10047672 != 0x21)
    {
        LeaveCriticalSection(&data_100489fc);
        return 0xee;
    }
    
    if (data_10047673 == 0)
    {
        *arg1 = data_10047671;
        *arg2 = data_10047674;
        *arg3 = data_10047676;
        *arg4 = data_10047677;
        int16_t ecx_3;
        ecx_3 = *(data_10047677 + 1);
        *arg5 = ecx_3;
        *arg6 = data_10047679;
        *arg7 = data_1004767a;
        *arg8 = data_1004767b;
        data_100489f8 = (data_1004767b * 0x64);
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

int32_t __stdcall OpenComPort(char* arg1)
{
    EnterCriticalSection(&data_100489fc);
    int32_t esi = arg_4;
    
    if (*((esi << 2) + &data_100475d0) != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x35;
    }
    
    char ebx = arg_c;
    int32_t* ebp_1;
    
    for (int32_t i = 0; i < 5; i += 1)
    {
        int32_t eax_2 = _OpenCom@8(esi, ebx);
        ebp_1 = arg_10;
        
        if (eax_2 == 0)
        {
            arg_4 = 0xff;
            
            for (int32_t j = 0; j < 2; j += 1)
            {
                *ebp_1 = esi;
                void var_b;
                void var_a;
                void var_9;
                void var_8;
                void var_4;
                
                if (GetReaderInformation(&arg_4, &var_4, &var_9, &var_8, &var_a, &var_b, &arg_10, &arg_c, esi) == 0)
                {
                    uint32_t eax_3;
                    eax_3 = arg_4;
                    int32_t ebx_2 = (esi * 0x90);
                    *arg1 = eax_3;
                    *((esi << 2) + &data_100475d0) = 1;
                    
                    if (sub_10007030((ebx_2 + 0x10048ae4)) == 0)
                    {
                        void* ecx_4 = *(*(ebx_2 + 0x10048ad8) + 4);
                        void* ecx_5 = (ecx_4 + (ebx_2 + 0x10048ad8));
                        int32_t eax_7 = (*((ecx_4 + (ebx_2 + 0x10048ad8)) + 8) | 2);
                        
                        if (*(ecx_5 + 0x28) == 0)
                            eax_7 |= 4;
                        
                        sub_10001e30(ecx_5, eax_7);
                    }
                    
                    if ((*((*(*(ebx_2 + 0x10048ad8) + 4) + ebx_2) + 0x10048ae0) & 6) == 0)
                        *((esi << 2) + &data_10047604) = 1;
                    else
                        *((esi << 2) + &data_10047604) = 0;
                    
                    if ((*((esi << 2) + &data_10047604) != 0 && sub_100070d0((ebx_2 + 0x10048ae4)) == 0))
                    {
                        void* ecx_7 = *(*(ebx_2 + 0x10048ad8) + 4);
                        void* ecx_8 = (ecx_7 + (ebx_2 + 0x10048ad8));
                        int32_t eax_12 = (*((ecx_7 + (ebx_2 + 0x10048ad8)) + 8) | 2);
                        
                        if (*(ecx_8 + 0x28) == 0)
                            eax_12 |= 4;
                        
                        sub_10001e30(ecx_8, eax_12);
                    }
                    
                    LeaveCriticalSection(&data_100489fc);
                    return 0;
                }
            }
            
            CloseHandle(*((esi << 2) + &data_10048a1c));
            break;
        }
    }
    
    *ebp_1 = 0xffffffff;
    LeaveCriticalSection(&data_100489fc);
    return 0x30;
}

int32_t __stdcall AutoOpenComPort(int32_t* arg1, int32_t arg2, int32_t arg3, char** arg4)
{
    EnterCriticalSection(&data_100489fc);
    int32_t result;
    
    for (char* i = 1; i < 0xd; i = &i[1])
    {
        char** var_14_1 = arg4;
        int32_t var_18_1 = arg3;
        int32_t var_1c_1 = arg2;
        result = OpenComPort(i);
        
        if (result == 0)
        {
            *arg1 = i;
            *arg4 = i;
            LeaveCriticalSection(&data_100489fc);
            return 0;
        }
    }
    
    *arg4 = 0xffffffff;
    *arg1 = 0xffffffff;
    LeaveCriticalSection(&data_100489fc);
    return result;
}

int32_t Inventory_G2(char arg1, char arg2, char* arg3, char arg4, char arg5, char arg6, void* arg7, char** arg8, uint32_t* arg9, int32_t arg10)
{
    __chkstk(0x2724);
    int32_t eax_1 = (__security_cookie ^ &__return_addr);
    CRITICAL_SECTION* __saved_ebx = &data_100489fc;
    __return_addr = arg7;
    char* lpCriticalSection_1 = nullptr;
    EnterCriticalSection(__saved_ebx);
    int32_t __saved_ebx_1 = 0x1388;
    char __saved_ebp = 0;
    char* lpCriticalSection = &arg_10;
    sub_1000fae0(lpCriticalSection, __saved_ebp, __saved_ebx_1);
    int128_t* var_18 = 0x1388;
    sub_1000fae0(&arg_1398, 0, var_18);
    data_10048a71 = *arg3;
    data_10048a72 = 1;
    char eax_3;
    
    if (arg6 != 1)
        eax_3 = 4;
    else
    {
        data_10048a73 = arg4;
        data_10048a74 = arg5;
        eax_3 = 6;
    }
    
    int32_t __saved_ebp_1 = 0x10048a70;
    data_10048a70 = eax_3;
    GetCRC(__saved_ebp_1, (eax_3 - 1));
    int32_t __saved_ebx_3 = 0x1388;
    char __saved_ebp_2 = 0;
    lpCriticalSection = &data_10047670;
    data_10048acc = 1;
    int32_t ecx_2 = sub_1000fae0(lpCriticalSection, __saved_ebp_2, __saved_ebx_3);
    uint32_t eax_5 = (data_10048a70 + 1);
    lpCriticalSection = &data_10048a70;
    SendDataToPort(ecx_2, lpCriticalSection, eax_5, arg10);
    int32_t __saved_ebx_5 = arg10;
    int32_t __saved_ebp_4 = 0x1004766c;
    lpCriticalSection = &data_10047670;
    int32_t eax_6 = GetQueryDataFromPort(lpCriticalSection);
    data_10048acc = 0;
    
    if (eax_6 != 0)
        LeaveCriticalSection(&data_100489fc);
    else
    {
        char* i = data_1004766c;
        lpCriticalSection = i;
        var_18 = &data_10047670;
        sub_10013c90(&arg_10, var_18, lpCriticalSection);
        int32_t ebx;
        ebx = arg1;
        
        while (i > 0)
        {
            uint32_t esi_3 = arg_10;
            
            if ((((ebx == 1 || ebx == 2) || ebx == 3) || ebx == 4))
            {
                *arg9 = arg2;
                lpCriticalSection = (esi_3 - 6);
                var_18 = &arg_15;
                sub_10013c90(((&var_18 + lpCriticalSection_1) + 0x13b0), var_18, lpCriticalSection);
                i = data_1004766c;
                void* eax_9 = (i - esi_3);
                lpCriticalSection_1 = &lpCriticalSection_1[(esi_3 - 6)];
                
                if ((eax_9 - 1) > 0)
                {
                    lpCriticalSection = (eax_9 - 1);
                    var_18 = ((&lpCriticalSection + esi_3) + 0x25);
                    sub_10013c90(&arg_10, var_18, lpCriticalSection);
                    ebx = arg1;
                }
            }
            
            i -= (esi_3 + 1);
            data_1004766c = i;
        }
        
        int128_t* __return_addr_1 = __return_addr;
        lpCriticalSection = lpCriticalSection_1;
        var_18 = &arg_1398;
        sub_10013c90(__return_addr_1, var_18, lpCriticalSection);
        lpCriticalSection = &data_100489fc;
        *arg8 = lpCriticalSection_1;
        LeaveCriticalSection(lpCriticalSection);
    }
    
    return sub_1000ac70((eax_1 ^ &__return_addr));
}

uint32_t __stdcall ReadCard_G2(char* arg1, int128_t* arg2, char arg3, char arg4, char arg5, int32_t* arg6, char arg7, char arg8, char arg9, int128_t* arg10, char arg11, int32_t* arg12, int32_t arg13)
{
    EnterCriticalSection(&data_100489fc);
    int32_t ebx;
    ebx = arg11;
    uint32_t esi = ebx;
    data_10048a71 = *arg1;
    data_10048a72 = 2;
    data_10048a73 = (ebx >> 1);
    sub_10013c90(&data_10048a74, arg2, esi);
    *(esi + 0x10048a74) = arg3;
    *(esi + 0x10048a75) = arg4;
    *(esi + 0x10048a76) = arg5;
    *(esi + 0x10048a77) = *arg6;
    
    if (arg9 != 1)
        ebx += 0xc;
    else
    {
        int32_t* eax_2;
        eax_2 = arg8;
        *(esi + 0x10048a7b) = arg7;
        *(esi + 0x10048a7c) = eax_2;
        ebx += 0xe;
    }
    
    data_10048a70 = ebx;
    GetCRC(0x10048a70, (ebx - 1));
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg13);
    int32_t var_10_3 = arg13;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_3 = data_1004766c;
    GetCRC(0x10047670, esi_3);
    
    if ((*(esi_3 + 0x10047671) != 0 || *(esi_3 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_3 = data_10047673;
    
    if (eax_3 == 0)
    {
        *arg1 = data_10047671;
        sub_10013c90(arg10, &data_10047674, (data_1004766c - 6));
        *arg12 = 0xffffffff;
        LeaveCriticalSection(&data_100489fc);
        return 0;
    }
    
    if (eax_3 == 0xfc)
        *arg12 = *data_10047674;
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall WriteCard_G2(char* arg1, int128_t* arg2, char arg3, char arg4, char arg5, int128_t* arg6, int32_t* arg7, char arg8, char arg9, char arg10, uint8_t arg11, int32_t* arg12, int32_t arg13)
{
    EnterCriticalSection(&data_100489fc);
    int32_t ebx;
    ebx = arg5;
    data_10048a71 = *arg1;
    uint32_t esi = arg11;
    data_10048a72 = 3;
    data_10048a73 = (ebx >> 1);
    data_10048a74 = (arg11 >> 1);
    sub_10013c90(&data_10048a75, arg2, esi);
    uint32_t edi = ebx;
    *(esi + 0x10048a75) = arg3;
    *(esi + 0x10048a76) = arg4;
    sub_10013c90((esi + 0x10048a77), arg6, edi);
    ebx += arg11;
    *((edi + esi) + 0x10048a77) = *arg7;
    
    if (arg10 != 1)
        ebx += 0xc;
    else
    {
        int32_t* edx_2;
        edx_2 = arg9;
        *((edi + esi) + 0x10048a7b) = arg8;
        *((edi + esi) + 0x10048a7c) = edx_2;
        ebx += 0xe;
    }
    
    data_10048a70 = ebx;
    GetCRC(0x10048a70, (ebx - 1));
    sub_1000fae0(&data_10047670, 0, 0x1388);
    uint32_t ecx_5 = (data_10048a70 + 1);
    SendDataToPort(ecx_5, &data_10048a70, ecx_5, arg13);
    Sleep(0x64);
    int32_t var_14_3 = arg13;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_3 = data_1004766c;
    GetCRC(0x10047670, esi_3);
    
    if ((*(esi_3 + 0x10047671) != 0 || *(esi_3 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_6 = data_10047673;
    
    if (eax_6 == 0)
    {
        *arg1 = data_10047671;
        *arg12 = 0xffffffff;
        LeaveCriticalSection(&data_100489fc);
        return 0;
    }
    
    if (eax_6 == 0xfc)
        *arg12 = *data_10047674;
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall WriteBlock_G2(char* arg1, int128_t* arg2, char arg3, char arg4, char arg5, int128_t* arg6, int32_t* arg7, char arg8, char arg9, char arg10, uint8_t arg11, int32_t* arg12, int32_t arg13)
{
    EnterCriticalSection(&data_100489fc);
    int32_t ebx;
    ebx = arg5;
    data_10048a71 = *arg1;
    uint32_t esi = arg11;
    data_10048a72 = 0x10;
    data_10048a73 = (ebx >> 1);
    data_10048a74 = (arg11 >> 1);
    sub_10013c90(&data_10048a75, arg2, esi);
    uint32_t edi = ebx;
    *(esi + 0x10048a75) = arg3;
    *(esi + 0x10048a76) = arg4;
    sub_10013c90((esi + 0x10048a77), arg6, edi);
    ebx += arg11;
    *((edi + esi) + 0x10048a77) = *arg7;
    
    if (arg10 != 1)
        ebx += 0xc;
    else
    {
        int32_t* edx_2;
        edx_2 = arg9;
        *((edi + esi) + 0x10048a7b) = arg8;
        *((edi + esi) + 0x10048a7c) = edx_2;
        ebx += 0xe;
    }
    
    data_10048a70 = ebx;
    GetCRC(0x10048a70, (ebx - 1));
    sub_1000fae0(&data_10047670, 0, 0x1388);
    uint32_t ecx_5 = (data_10048a70 + 1);
    SendDataToPort(ecx_5, &data_10048a70, ecx_5, arg13);
    Sleep(0x64);
    int32_t var_14_3 = arg13;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_3 = data_1004766c;
    GetCRC(0x10047670, esi_3);
    
    if ((*(esi_3 + 0x10047671) != 0 || *(esi_3 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_6 = data_10047673;
    
    if (eax_6 == 0)
    {
        *arg1 = data_10047671;
        *arg12 = 0xffffffff;
        LeaveCriticalSection(&data_100489fc);
        return 0;
    }
    
    if (eax_6 == 0xfc)
        *arg12 = *data_10047674;
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall SetEASAlarm_G2(char* arg1, int128_t* arg2, int32_t* arg3, char arg4, char arg5, char arg6, char arg7, char arg8, int32_t* arg9, int32_t arg10)
{
    EnterCriticalSection(&data_100489fc);
    int32_t ebx;
    ebx = arg8;
    uint32_t esi = ebx;
    data_10048a71 = *arg1;
    data_10048a72 = 0xc;
    data_10048a73 = (ebx >> 1);
    sub_10013c90(&data_10048a74, arg2, esi);
    *(esi + 0x10048a74) = *arg3;
    *(esi + 0x10048a78) = arg7;
    
    if (arg6 != 1)
        ebx += 0xa;
    else
    {
        int32_t* eax_1;
        eax_1 = arg4;
        int32_t ecx_1;
        ecx_1 = arg5;
        *(esi + 0x10048a79) = eax_1;
        *(esi + 0x10048a7a) = ecx_1;
        ebx += 0xc;
    }
    
    data_10048a70 = ebx;
    GetCRC(0x10048a70, (ebx - 1));
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg10);
    int32_t var_10_3 = arg10;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_3 = data_1004766c;
    GetCRC(0x10047670, esi_3);
    
    if ((*(esi_3 + 0x10047671) != 0 || *(esi_3 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_4 = data_10047673;
    
    if (eax_4 == 0)
    {
        *arg1 = data_10047671;
        *arg9 = 0xffffffff;
        LeaveCriticalSection(&data_100489fc);
        return 0;
    }
    
    if (eax_4 == 0xfc)
        *arg9 = *data_10047674;
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall CheckEASAlarm_G2(char* arg1, int32_t* arg2, int32_t arg3)
{
    EnterCriticalSection(&data_100489fc);
    data_10048a71 = *arg1;
    data_10048a72 = 0xd;
    data_10048a70 = 4;
    GetCRC(0x10048a70, 3);
    data_10048acc = 0;
    sub_1000fae0(&data_10047670, 0, 0x1388);
    uint32_t ecx_1 = (data_10048a70 + 1);
    SendDataToPort(ecx_1, &data_10048a70, ecx_1, arg3);
    int32_t var_c_1 = arg3;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_1 = data_10047673;
    
    if (eax_1 == 0)
    {
        *arg1 = data_10047671;
        *arg2 = 0xffffffff;
        LeaveCriticalSection(&data_100489fc);
        return 0;
    }
    
    if (eax_1 == 0xfc)
        *arg2 = *data_10047674;
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall SetCardProtect_G2(char* arg1, int128_t* arg2, char arg3, char arg4, int32_t* arg5, char arg6, char arg7, char arg8, char arg9, int32_t* arg10, int32_t arg11)
{
    EnterCriticalSection(&data_100489fc);
    int32_t ebx;
    ebx = arg9;
    uint32_t esi = ebx;
    data_10048a71 = *arg1;
    data_10048a72 = 6;
    data_10048a73 = (ebx >> 1);
    sub_10013c90(&data_10048a74, arg2, esi);
    *(esi + 0x10048a74) = arg3;
    *(esi + 0x10048a75) = arg4;
    *(esi + 0x10048a76) = *arg5;
    
    if (arg8 != 1)
        ebx += 0xb;
    else
    {
        int32_t* eax_2;
        eax_2 = arg7;
        *(esi + 0x10048a7a) = arg6;
        *(esi + 0x10048a7b) = eax_2;
        ebx += 0xd;
    }
    
    data_10048a70 = ebx;
    GetCRC(0x10048a70, (ebx - 1));
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg11);
    int32_t var_c_3 = arg11;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_3 = data_1004766c;
    GetCRC(0x10047670, esi_3);
    
    if ((*(esi_3 + 0x10047671) != 0 || *(esi_3 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_3 = data_10047673;
    
    if (eax_3 == 0)
        *arg10 = 0xffffffff;
    else if (eax_3 == 0xfc)
    {
        *arg10 = *data_10047674;
        LeaveCriticalSection(&data_100489fc);
        return data_10047673;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall Writedfre(char* arg1, char* arg2, char* arg3, int32_t arg4)
{
    EnterCriticalSection(&data_100489fc);
    data_10048a71 = *arg1;
    data_10048a72 = 0x22;
    char* eax;
    eax = *arg2;
    data_10048a73 = eax;
    char* edx;
    edx = *arg3;
    data_10048a74 = edx;
    data_10048a70 = 6;
    GetCRC(0x10048a70, 5);
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg4);
    int32_t var_8_1 = arg4;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall WriteComAdr(char* arg1, char* arg2, int32_t arg3)
{
    EnterCriticalSection(&data_100489fc);
    data_10048a71 = *arg1;
    data_10048a72 = 0x24;
    char* eax;
    eax = *arg2;
    data_10048a73 = eax;
    data_10048a70 = 5;
    GetCRC(0x10048a70, 4);
    data_10048acc = 0;
    sub_1000fae0(&data_10047670, 0, 0x1388);
    uint32_t ecx_2 = (data_10048a70 + 1);
    SendDataToPort(ecx_2, &data_10048a70, ecx_2, arg3);
    int32_t var_8_1 = arg3;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall WriteScanTime(char* arg1, char* arg2, int32_t arg3)
{
    EnterCriticalSection(&data_100489fc);
    data_10048a71 = *arg1;
    data_10048a72 = 0x25;
    char* eax;
    eax = *arg2;
    data_10048a73 = eax;
    data_10048a70 = 5;
    GetCRC(0x10048a70, 4);
    data_10048acc = 0;
    sub_1000fae0(&data_10047670, 0, 0x1388);
    uint32_t ecx_2 = (data_10048a70 + 1);
    SendDataToPort(ecx_2, &data_10048a70, ecx_2, arg3);
    int32_t var_8_1 = arg3;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall Writebaud(char* arg1, char* arg2, int32_t arg3)
{
    EnterCriticalSection(&data_100489fc);
    data_10048a71 = *arg1;
    data_10048a72 = 0x28;
    data_10048a73 = *arg2;
    data_10048a70 = 5;
    GetCRC(0x10048a70, 4);
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg3);
    int32_t var_28_1 = arg3;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* edi_1 = data_1004766c;
    GetCRC(0x10047670, edi_1);
    
    if ((*(edi_1 + 0x10047671) != 0 || *(edi_1 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    HANDLE hFile = *((arg3 << 2) + &data_10048a1c);
    data_10048a50 = 0x1c;
    GetCommState(hFile, &data_10048a50);
    uint32_t eax_3 = *arg2;
    
    if (eax_3 > 6)
        goto label_10004024;
    
    switch (eax_3)
    {
        case 0:
        {
            data_10048a54 = 0x2580;
        label_10004024:
            HANDLE hFile_2 = *((arg3 << 2) + &data_10048a1c);
            data_10048a63 = 0;
            data_10048a64 = 0;
            data_10048a62 = 8;
            HANDLE hObject;
            
            if (SetCommState(hFile_2, &data_10048a50) != 0)
            {
                int32_t lpCommTimeouts;
                GetCommTimeouts(*((arg3 << 2) + &data_10048a1c), &lpCommTimeouts);
                HANDLE hFile_1 = *((arg3 << 2) + &data_10048a1c);
                __builtin_memcpy(&lpCommTimeouts, "\x0f\x00\x00\x00\x0a\x00\x00\x00\x0a\x00\x00\x00\x14\x00\x00\x00\x14\x00\x00\x00", 0x14);
                
                if (SetCommTimeouts(hFile_1, &lpCommTimeouts) != 0)
                {
                    SetCommMask(*((arg3 << 2) + &data_10048a1c), EV_RXCHAR);
                    SetupComm(*((arg3 << 2) + &data_10048a1c), 0x400, 0x400);
                    PurgeComm(&data_10048a1c, PURGE_RXCLEAR | PURGE_TXCLEAR);
                    LeaveCriticalSection(&data_100489fc);
                    return data_10047673;
                }
                
                hObject = *((arg3 << 2) + &data_10048a1c);
            }
            else
                hObject = *((arg3 << 2) + &data_10048a1c);
            
            CloseHandle(hObject);
            break;
        }
        case 1:
        {
            data_10048a54 = 0x4b00;
            goto label_10004024;
        }
        case 2:
        {
            data_10048a54 = 0x9600;
            goto label_10004024;
        }
        case 4:
        {
            data_10048a54 = 0xdac0;
            goto label_10004024;
        }
        case 5:
        {
            data_10048a54 = 0xe100;
            goto label_10004024;
        }
        case 6:
        {
            data_10048a54 = 0x1c200;
            goto label_10004024;
        }
    }
    
    LeaveCriticalSection(&data_100489fc);
    return 0x30;
}

uint32_t __stdcall SetPowerDbm(char* arg1, char arg2, int32_t arg3)
{
    EnterCriticalSection(&data_100489fc);
    data_10048a71 = *arg1;
    data_10048a72 = 0x2f;
    data_10048a73 = arg2;
    data_10048a70 = 5;
    GetCRC(0x10048a70, 4);
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg3);
    int32_t var_8_1 = arg3;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall BuzzerAndLEDControl(char* arg1, char arg2, char arg3, char arg4, int32_t arg5)
{
    EnterCriticalSection(&data_100489fc);
    char* eax;
    eax = arg3;
    data_10048a71 = *arg1;
    data_10048a72 = 0x33;
    data_10048a73 = arg2;
    data_10048a74 = eax;
    data_10048a75 = arg4;
    data_10048a70 = 7;
    GetCRC(0x10048a70, 6);
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg5);
    int32_t var_8_1 = arg5;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall EraseCard_G2(char* arg1, int128_t* arg2, char arg3, char arg4, char arg5, int32_t* arg6, char arg7, char arg8, char arg9, char arg10, int32_t* arg11, int32_t arg12)
{
    EnterCriticalSection(&data_100489fc);
    int32_t ebx;
    ebx = arg10;
    uint32_t esi = ebx;
    data_10048a71 = *arg1;
    data_10048a72 = 7;
    data_10048a73 = (ebx >> 1);
    sub_10013c90(&data_10048a74, arg2, esi);
    *(esi + 0x10048a74) = arg3;
    *(esi + 0x10048a75) = arg4;
    *(esi + 0x10048a76) = arg5;
    *(esi + 0x10048a77) = *arg6;
    
    if (arg9 != 1)
        ebx += 0xc;
    else
    {
        int32_t* ecx_2;
        ecx_2 = arg8;
        *(esi + 0x10048a7b) = arg7;
        *(esi + 0x10048a7c) = ecx_2;
        ebx += 0xe;
    }
    
    data_10048a70 = ebx;
    GetCRC(0x10048a70, (ebx - 1));
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg12);
    int32_t var_c_3 = arg12;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_3 = data_1004766c;
    GetCRC(0x10047670, esi_3);
    
    if ((*(esi_3 + 0x10047671) != 0 || *(esi_3 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_5 = data_10047673;
    
    if (eax_5 == 0)
        *arg11 = 0xffffffff;
    else if (eax_5 == 0xfc)
    {
        *arg11 = *data_10047674;
        LeaveCriticalSection(&data_100489fc);
        return data_10047673;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall WriteEPC_G2(char* arg1, int32_t* arg2, int128_t* arg3, char arg4, int32_t* arg5, int32_t arg6)
{
    EnterCriticalSection(&data_100489fc);
    int32_t ebx;
    ebx = arg4;
    char ecx = *arg1;
    data_10048a73 = (ebx >> 1);
    data_10048a71 = ecx;
    data_10048a72 = 4;
    *data_10048a74 = *arg2;
    sub_10013c90(&*(data_10048a76 + 2), arg3, ebx);
    ebx += 9;
    data_10048a70 = ebx;
    GetCRC(0x10048a70, (ebx - 1));
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg6);
    int32_t var_c_3 = arg6;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_3 = data_10047673;
    
    if (eax_3 == 0)
        *arg5 = 0xffffffff;
    else if (eax_3 == 0xfc)
    {
        *arg5 = *data_10047674;
        LeaveCriticalSection(&data_100489fc);
        return data_10047673;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall DestroyCard_G2(char* arg1, int128_t* arg2, int32_t* arg3, char arg4, char arg5, char arg6, char arg7, int32_t* arg8, int32_t arg9)
{
    EnterCriticalSection(&data_100489fc);
    int32_t ebx;
    ebx = arg7;
    uint32_t esi = ebx;
    data_10048a71 = *arg1;
    data_10048a72 = 5;
    data_10048a73 = (ebx >> 1);
    sub_10013c90(&data_10048a74, arg2, esi);
    *(esi + 0x10048a74) = *arg3;
    
    if (arg6 != 1)
        ebx += 9;
    else
    {
        int32_t* ecx_1;
        ecx_1 = arg5;
        *(esi + 0x10048a78) = arg4;
        *(esi + 0x10048a79) = ecx_1;
        ebx += 0xb;
    }
    
    data_10048a70 = ebx;
    GetCRC(0x10048a70, (ebx - 1));
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg9);
    int32_t var_c_3 = arg9;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_3 = data_1004766c;
    GetCRC(0x10047670, esi_3);
    
    if ((*(esi_3 + 0x10047671) != 0 || *(esi_3 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_5 = data_10047673;
    
    if (eax_5 == 0)
        *arg8 = 0xffffffff;
    else if (eax_5 == 0xfc)
    {
        *arg8 = *data_10047674;
        LeaveCriticalSection(&data_100489fc);
        return data_10047673;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall SetReadProtect_G2(char* arg1, int128_t* arg2, int32_t* arg3, char arg4, char arg5, char arg6, char arg7, int32_t* arg8, int32_t arg9)
{
    EnterCriticalSection(&data_100489fc);
    int32_t ebx;
    ebx = arg7;
    uint32_t esi = ebx;
    data_10048a71 = *arg1;
    data_10048a72 = 8;
    data_10048a73 = (ebx >> 1);
    sub_10013c90(&data_10048a74, arg2, esi);
    *(esi + 0x10048a74) = *arg3;
    
    if (arg6 != 1)
        ebx += 9;
    else
    {
        int32_t* ecx_1;
        ecx_1 = arg5;
        *(esi + 0x10048a78) = arg4;
        *(esi + 0x10048a79) = ecx_1;
        ebx += 0xb;
    }
    
    data_10048a70 = ebx;
    GetCRC(0x10048a70, (ebx - 1));
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg9);
    int32_t var_c_3 = arg9;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_3 = data_1004766c;
    GetCRC(0x10047670, esi_3);
    
    if ((*(esi_3 + 0x10047671) != 0 || *(esi_3 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_5 = data_10047673;
    
    if (eax_5 == 0)
        *arg8 = 0xffffffff;
    else if (eax_5 == 0xfc)
    {
        *arg8 = *data_10047674;
        LeaveCriticalSection(&data_100489fc);
        return data_10047673;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall SetMultiReadProtect_G2(char* arg1, int32_t* arg2, int32_t* arg3, int32_t arg4)
{
    EnterCriticalSection(&data_100489fc);
    data_10048a71 = *arg1;
    data_10048a72 = 9;
    *data_10048a73 = *arg2;
    data_10048a70 = 8;
    GetCRC(0x10048a70, 7);
    data_10048acc = 0;
    sub_1000fae0(&data_10047670, 0, 0x1388);
    uint32_t ecx_2 = (data_10048a70 + 1);
    SendDataToPort(ecx_2, &data_10048a70, ecx_2, arg4);
    int32_t var_8_1 = arg4;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_2 = data_10047673;
    
    if (eax_2 == 0)
        *arg3 = 0xffffffff;
    else if (eax_2 == 0xfc)
    {
        *arg3 = *data_10047674;
        LeaveCriticalSection(&data_100489fc);
        return data_10047673;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall RemoveReadProtect_G2(char* arg1, int32_t* arg2, int32_t* arg3, int32_t arg4)
{
    EnterCriticalSection(&data_100489fc);
    data_10048a71 = *arg1;
    data_10048a72 = 0xa;
    *data_10048a73 = *arg2;
    data_10048a70 = 8;
    GetCRC(0x10048a70, 7);
    data_10048acc = 0;
    sub_1000fae0(&data_10047670, 0, 0x1388);
    uint32_t ecx_2 = (data_10048a70 + 1);
    SendDataToPort(ecx_2, &data_10048a70, ecx_2, arg4);
    int32_t var_8_1 = arg4;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_2 = data_10047673;
    
    if (eax_2 == 0)
        *arg3 = 0xffffffff;
    else if (eax_2 == 0xfc)
    {
        *arg3 = *data_10047674;
        LeaveCriticalSection(&data_100489fc);
        return data_10047673;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall CheckReadProtected_G2(char* arg1, char* arg2, int32_t* arg3, int32_t arg4)
{
    EnterCriticalSection(&data_100489fc);
    data_10048a71 = *arg1;
    data_10048a72 = 0xb;
    data_10048a70 = 4;
    GetCRC(0x10048a70, 3);
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg4);
    int32_t var_8_1 = arg4;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_1 = data_10047673;
    
    if (eax_1 == 0)
    {
        *arg3 = 0xffffffff;
        *arg2 = *data_10047674;
    }
    else if (eax_1 == 0xfc)
    {
        *arg3 = *data_10047674;
        LeaveCriticalSection(&data_100489fc);
        return data_10047673;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall LockUserBlock_G2(char* arg1, int128_t* arg2, int32_t* arg3, char arg4, char arg5, char arg6, char arg7, char arg8, int32_t* arg9, int32_t arg10)
{
    EnterCriticalSection(&data_100489fc);
    int32_t ebx;
    ebx = arg8;
    uint32_t esi = ebx;
    data_10048a71 = *arg1;
    data_10048a72 = 0xe;
    data_10048a73 = (ebx >> 1);
    sub_10013c90(&data_10048a74, arg2, esi);
    *(esi + 0x10048a74) = *arg3;
    *(esi + 0x10048a78) = arg7;
    
    if (arg6 != 1)
        ebx += 0xa;
    else
    {
        int32_t* ecx_1;
        ecx_1 = arg4;
        int32_t edx_1;
        edx_1 = arg5;
        *(esi + 0x10048a79) = ecx_1;
        *(esi + 0x10048a7a) = edx_1;
        ebx += 0xc;
    }
    
    data_10048a70 = ebx;
    GetCRC(0x10048a70, (ebx - 1));
    data_10048acc = 0;
    sub_1000fae0(&data_10047670, 0, 0x1388);
    uint32_t ecx_3 = (data_10048a70 + 1);
    SendDataToPort(ecx_3, &data_10048a70, ecx_3, arg10);
    int32_t var_c_3 = arg10;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_3 = data_1004766c;
    GetCRC(0x10047670, esi_3);
    
    if ((*(esi_3 + 0x10047671) != 0 || *(esi_3 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_5 = data_10047673;
    
    if (eax_5 == 0)
        *arg9 = 0xffffffff;
    else if (eax_5 == 0xfc)
    {
        *arg9 = *data_10047674;
        LeaveCriticalSection(&data_100489fc);
        return data_10047673;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall Inventory_6B(char* arg1, int32_t* arg2, int32_t arg3)
{
    EnterCriticalSection(&data_100489fc);
    data_10048a71 = *arg1;
    data_10048a72 = 0x50;
    data_10048a70 = 4;
    GetCRC(0x10048a70, 3);
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg3);
    int32_t var_8_1 = arg3;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    if (data_10047670 == 0xd)
    {
        *arg2 = *data_10047674;
        arg2[1] = *(data_10047677 + 1);
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall inventory2_6B(char* arg1, char arg2, char arg3, char arg4, int32_t* arg5, int128_t* arg6, uint32_t* arg7, int32_t arg8)
{
    EnterCriticalSection(&data_100489fc);
    char* eax;
    eax = arg3;
    data_10048a71 = *arg1;
    data_10048a74 = eax;
    data_10048a72 = 0x51;
    data_10048a73 = arg2;
    data_10048a75 = arg4;
    data_10048a76 = *arg5;
    data_10048a7a = arg5[1];
    data_10048a70 = 0xf;
    GetCRC(0x10048a70, 0xe);
    data_10048acc = 0;
    sub_1000fae0(&data_10047670, 0, 0x1388);
    uint32_t ecx_2 = (data_10048a70 + 1);
    SendDataToPort(ecx_2, &data_10048a70, ecx_2, arg8);
    int32_t var_8_1 = arg8;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    if (data_10047670 > 5)
    {
        *arg7 = *data_10047674;
        uint32_t* eax_3;
        eax_3 = *data_10047674;
        
        if (eax_3 > 0)
            sub_10013c90(arg6, &*(data_10047674 + 1), (eax_3 * 8));
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall ReadCard_6B(char* arg1, int32_t* arg2, char arg3, char arg4, int128_t* arg5, int32_t* arg6, int32_t arg7)
{
    EnterCriticalSection(&data_100489fc);
    data_10048a71 = *arg1;
    data_10048a72 = 0x52;
    data_10048a73 = arg3;
    *data_10048a74 = *arg2;
    int32_t* eax_1;
    eax_1 = arg4;
    *(data_10048a76 + 2) = arg2[1];
    *(data_10048a7a + 2) = eax_1;
    data_10048a70 = 0xe;
    GetCRC(0x10048a70, 0xd);
    data_10048acc = 0;
    sub_1000fae0(&data_10047670, 0, 0x1388);
    uint32_t ecx_3 = (data_10048a70 + 1);
    SendDataToPort(ecx_3, &data_10048a70, ecx_3, arg7);
    int32_t var_8_1 = arg7;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_2 = data_10047673;
    
    if (eax_2 == 0)
    {
        if (data_10047670 > 5)
            sub_10013c90(arg5, &data_10047674, arg4);
        
        *arg6 = 0xffffffff;
        int32_t var_8_4 = 0x100489fc;
    }
    else if (eax_2 == 0xfc)
    {
        *arg6 = *data_10047674;
        LeaveCriticalSection(&data_100489fc);
        return data_10047673;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall WriteCard_6B(char* arg1, int32_t* arg2, char arg3, int128_t* arg4, char arg5, char* arg6, int32_t* arg7, int32_t arg8)
{
    EnterCriticalSection(&data_100489fc);
    int32_t ebx;
    ebx = arg5;
    data_10048a71 = *arg1;
    data_10048a72 = 0x53;
    data_10048a73 = arg3;
    *data_10048a74 = *arg2;
    *(data_10048a76 + 2) = arg2[1];
    sub_10013c90(&*(data_10048a7a + 2), arg4, ebx);
    data_10048a70 = (ebx + 0x13);
    GetCRC(0x10048a70, ((ebx + 0x13) - 1));
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg8);
    int32_t var_c_3 = arg8;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_6 = data_10047673;
    
    if (eax_6 == 0)
    {
        *arg7 = 0xffffffff;
        *arg6 = ebx;
    }
    else if (eax_6 == 0xfc)
    {
        *arg7 = *data_10047674;
        LeaveCriticalSection(&data_100489fc);
        return data_10047673;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall LockByte_6B(char* arg1, int32_t* arg2, char arg3, int32_t* arg4, int32_t arg5)
{
    EnterCriticalSection(&data_100489fc);
    data_10048a71 = *arg1;
    data_10048a72 = 0x55;
    data_10048a73 = arg3;
    *data_10048a74 = *arg2;
    *(data_10048a76 + 2) = arg2[1];
    data_10048a70 = 0xd;
    GetCRC(0x10048a70, 0xc);
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg5);
    int32_t var_8_1 = arg5;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_4 = data_10047673;
    
    if (eax_4 == 0)
        *arg4 = 0xffffffff;
    else if (eax_4 == 0xfc)
    {
        *arg4 = *data_10047674;
        LeaveCriticalSection(&data_100489fc);
        return data_10047673;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

uint32_t __stdcall CheckLock_6B(char* arg1, int32_t* arg2, char arg3, uint8_t* arg4, int32_t* arg5, int32_t arg6)
{
    EnterCriticalSection(&data_100489fc);
    data_10048a71 = *arg1;
    data_10048a72 = 0x54;
    data_10048a73 = arg3;
    *data_10048a74 = *arg2;
    *(data_10048a76 + 2) = arg2[1];
    data_10048a70 = 0xd;
    GetCRC(0x10048a70, 0xc);
    data_10048acc = 0;
    SendDataToPort(sub_1000fae0(&data_10047670, 0, 0x1388), &data_10048a70, (data_10048a70 + 1), arg6);
    int32_t var_8_1 = arg6;
    int32_t result = GetDataFromPort(&data_10047670, 0x1004766c);
    data_10048acc = 0;
    
    if (result != 0)
    {
        LeaveCriticalSection(&data_100489fc);
        return result;
    }
    
    void* esi_2 = data_1004766c;
    GetCRC(0x10047670, esi_2);
    
    if ((*(esi_2 + 0x10047671) != 0 || *(esi_2 + 0x10047670) != 0))
    {
        LeaveCriticalSection(&data_100489fc);
        return 0x31;
    }
    
    uint8_t eax_4 = data_10047673;
    
    if (eax_4 == 0)
    {
        *arg5 = 0xffffffff;
        *arg4 = *data_10047674;
    }
    else if (eax_4 == 0xfc)
    {
        *arg5 = *data_10047674;
        LeaveCriticalSection(&data_100489fc);
        return data_10047673;
    }
    
    LeaveCriticalSection(&data_100489fc);
    return data_10047673;
}

void __convention("regparm") sub_10005630(int32_t* arg1)
{
    int32_t* esi_1 = (*arg1 - 0x10);
    
    if ((esi_1[3] == 0 && sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x6b, nullptr, u"nRefs != 0") == 1))
        breakpoint();
    
    int32_t ecx = esi_1[3];
    esi_1[3] -= 1;
    
    if ((ecx - 1) <= 0)
        *(**esi_1 + 4)(esi_1);
}

int32_t* __convention("regparm") sub_10005680(int32_t* arg1)
{
    int32_t cchWideChar = (MultiByteToWideChar(3, 0, &data_10040802, 0xffffffff, nullptr, 0) - 1);
    
    if (cchWideChar <= 0)
    {
        sub_10006c50();
        return arg1;
    }
    
    void* eax_1 = *arg1;
    int32_t edx_1 = (*(eax_1 - 8) - cchWideChar);
    
    if (((1 - *(eax_1 - 4)) | edx_1) < 0)
        sub_10007c20(arg1, edx_1, cchWideChar);
    
    MultiByteToWideChar(3, 0, &data_10040802, 0xffffffff, *arg1, cchWideChar);
    sub_10007730(cchWideChar, arg1);
    return arg1;
}

int32_t* __thiscall sub_100056f0(int32_t* arg1, int128_t* arg2)
{
    int32_t var_4_1 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034c68;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t* var_10 = arg1;
    int32_t __saved_edi;
    int32_t var_1c = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_10_1 = arg1;
    *arg1 = 0;
    int32_t var_4 = 0;
    arg1[7] = 0xf;
    arg1[6] = 0;
    arg1[2] = 0;
    
    if (arg2 == 0)
        sub_10032900(u"invalid null pointer", u"E:\Program Files\Microsoft Visua…", 0x43c);
    
    int128_t* eax_3 = arg2;
    void* edx = (eax_3 + 1);
    char i;
    
    do
    {
        i = *eax_3;
        eax_3 += 1;
    } while (i != 0);
    sub_100077a0(arg1, arg2, (eax_3 - edx));
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg1;
}

int32_t* __thiscall sub_10005790(int32_t* arg1, int32_t* arg2)
{
    int32_t var_4_1 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034a58;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t* var_10 = arg1;
    int32_t __saved_esi;
    int32_t var_18 = (__security_cookie ^ &__saved_esi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_10_1 = arg1;
    *arg1 = 0;
    
    if (*arg2 == 0xfffffffd)
        *arg1 = 0xfffffffd;
    
    int32_t var_4 = 0;
    arg1[6] = 0;
    arg1[7] = 0xf;
    arg1[2] = 0;
    sub_10006da0(arg1, arg2, nullptr, 0xffffffff);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg1;
}

int32_t __fastcall sub_10005800(int32_t* arg1)
{
    if (arg1[7] >= 0x10)
        sub_1000ab80(arg1[2]);
    
    arg1[7] = 0xf;
    arg1[6] = 0;
    arg1[2] = 0;
    /* tailcall */
    return sub_10001290(arg1);
}

void* __fastcall sub_10005830(void* arg1)
{
    if (*(arg1 + 0x1c) < 0x10)
        return (arg1 + 8);
    
    return *(arg1 + 8);
}

int32_t __fastcall sub_10005840(void* arg1)
{
    return *(arg1 + 0x18);
}

void* __stdcall sub_10005850(int32_t arg1)
{
    int32_t esi = arg1;
    
    if (esi <= 0)
        esi = 0;
    else if ((COMBINE(0, 0xffffffff) / esi) < 1)
    {
        arg1 = 0;
        int32_t var_c;
        sub_1000c090(&var_c, &arg1);
        var_c = 0x10037f68;
        sub_1000ed00(&var_c, &data_10042750);
        /* no return */
    }
    
    return __wcstoi64_l(esi, &data_100401e0, "E:\Program Files\Microsoft Visua…", 0x61);
}

int32_t __stdcall sub_100058c0(int32_t arg1)
{
    int32_t result = arg1;
    
    if (result != 0)
        result = __mktime32(result);
    
    return result;
}

int32_t* __fastcall sub_100058e0(void*** arg1)
{
    *arg1 = &data_10040ec4;
    return sub_10033d70(arg1);
}

void* __fastcall sub_100058f0(void* arg1)
{
    void* result = *(arg1 - 8);
    *((*(result + 4) + arg1) - 8) = 0x10040f10;
    return result;
}

int32_t __fastcall sub_10005900(int32_t* arg1)
{
    int32_t* eax = arg1[0xe];
    *arg1 = 0x10040ed4;
    sub_100082c0(eax);
    /* tailcall */
    return sub_10033f00(&arg1[1]);
}

int32_t sub_10005920() __pure
{
    return 0xffffffff;
}

uint32_t __fastcall sub_10005930(int32_t* arg1)
{
    int32_t result = *(*arg1 + 0x10)();
    
    if (result == 0xffffffff)
        return result;
    
    int32_t* eax_2 = arg1[0xc];
    *eax_2 -= 1;
    int32_t* eax_3 = arg1[8];
    char* ecx = *eax_3;
    *eax_3 = &ecx[1];
    return *ecx;
}

int32_t __thiscall sub_10005960(int32_t* arg1, int32_t arg2, int32_t arg3)
{
    return *(*arg1 + 0x1c)(arg2, 0xffffffff, arg3);
}

void* __thiscall sub_10005980(int32_t* arg1, void* arg2, int32_t arg3, void* arg4)
{
    int32_t* var_4 = arg1;
    void* i = arg4;
    void* result = nullptr;
    void* result_1 = nullptr;
    
    if (i <= 0)
        return 0;
    
    void* ebx = arg2;
    
    do
    {
        void* i_2 = sub_10006f80(arg1);
        
        if (i_2 <= 0)
        {
            int32_t eax_6 = *(*arg1 + 0x14)();
            
            if (eax_6 == 0xffffffff)
                break;
            
            result += 1;
            *ebx = eax_6;
            ebx += 1;
            result_1 = result;
            i -= 1;
        }
        else
        {
            void* i_1 = i_2;
            
            if (i < i_2)
                i_1 = i;
            
            sub_1000ad50(ebx, arg3, *arg1[8], i_1);
            int32_t* eax_3 = arg1[0xc];
            *eax_3 -= i_1;
            result_1 += i_1;
            int32_t* eax_4 = arg1[8];
            ebx += i_1;
            i -= i_1;
            *eax_4 += i_1;
            result = result_1;
        }
    } while (i > 0);
    
    return result;
}

void* __thiscall sub_10005a10(int32_t* arg1, void* arg2, void* arg3)
{
    int32_t* var_4 = arg1;
    void* i = arg3;
    void* result = nullptr;
    void* result_1 = nullptr;
    
    if (i <= 0)
        return 0;
    
    void* ebx = arg2;
    
    do
    {
        void* i_2 = sub_10006fa0(arg1);
        
        if (i_2 <= 0)
        {
            if (*(*arg1 + 4)(*ebx) == 0xffffffff)
                break;
            
            result += 1;
            ebx += 1;
            result_1 = result;
            i -= 1;
        }
        else
        {
            void* i_1 = i_2;
            
            if (i < i_2)
                i_1 = i;
            
            sub_1000ad50(*arg1[9], i_2, ebx, i_1);
            int32_t* eax_3 = arg1[0xd];
            *eax_3 -= i_1;
            result_1 += i_1;
            int32_t* eax_4 = arg1[9];
            ebx += i_1;
            i -= i_1;
            *eax_4 += i_1;
            result = result_1;
        }
    } while (i > 0);
    
    return result;
}

int32_t* __stdcall sub_10005aa0(int32_t* arg1)
{
    *arg1 = 0xffffffff;
    arg1[2] = 0;
    arg1[3] = 0;
    arg1[4] = 0;
    return arg1;
}

int32_t* __stdcall sub_10005ac0(int32_t* arg1)
{
    *arg1 = 0xffffffff;
    arg1[2] = 0;
    arg1[3] = 0;
    arg1[4] = 0;
    return arg1;
}

int32_t __fastcall sub_10005ae0(int32_t arg1) __pure
{
    return arg1;
}

int32_t sub_10005af0() __pure
{
    return 0;
}

int32_t sub_10005b00() __pure
{
    return;
}

int32_t* __thiscall sub_10005b10(int32_t* arg1, int32_t arg2)
{
    int32_t var_4_2 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034f67;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_edi;
    int32_t var_24 = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_10 = arg1;
    int32_t var_14 = 0;
    
    if (arg2 != 0)
    {
        *arg1 = 0x10040f68;
        arg1[2] = 0x10040f70;
        arg1[0x17] = &data_10040ecc;
        int32_t var_4 = 0;
        int32_t var_14_1 = 1;
    }
    
    sub_10006fc0(arg1, &arg1[3]);
    int32_t var_4_1 = 1;
    int32_t ecx = *(*arg1 + 4);
    *(arg1 + ecx) = &data_10040f64;
    sub_10007930(ecx, &arg1[3]);
    arg1[7] = &arg1[5];
    arg1[0xb] = &arg1[9];
    arg1[0xc] = &arg1[0xa];
    arg1[3] = 0x10040f28;
    arg1[0x15] = 0;
    *(arg1 + 0x4d) = 0;
    arg1[8] = &arg1[6];
    arg1[0xf] = &arg1[0xd];
    arg1[0x10] = &arg1[0xe];
    arg1[6] = 0;
    *arg1[0xc] = 0;
    *arg1[0x10] = 0;
    *arg1[7] = 0;
    int32_t edx_4 = data_10049230;
    *arg1[0xb] = 0;
    *arg1[0xf] = 0;
    arg1[0x16] = 0;
    arg1[0x14] = edx_4;
    arg1[0x12] = 0;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg1;
}

int32_t __fastcall sub_10005c00(void* arg1)
{
    int32_t var_4_1 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034c3b;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    void* var_10 = arg1;
    int32_t __saved_esi;
    int32_t var_18 = (__security_cookie ^ &__saved_esi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void* var_10_1 = arg1;
    *((*(*(arg1 - 0x5c) + 4) + arg1) - 0x5c) = &data_10040f64;
    int32_t var_4 = 0;
    sub_10005cc0((arg1 - 0x50));
    *((*(*(arg1 - 0x5c) + 4) + (arg1 - 0x50)) - 0xc) = &data_10040f20;
    int32_t result = *(*(arg1 - 0x54) + 4);
    *((result + (arg1 - 0x50)) - 4) = &data_10040f18;
    *((*(*(arg1 - 0x5c) + 4) + (arg1 - 0x50)) - 0xc) = 0x10040f10;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

void* __fastcall sub_10005c90(void* arg1)
{
    *((*(*(arg1 - 0xc) + 4) + arg1) - 0xc) = &data_10040f20;
    *((*(*(arg1 - 4) + 4) + arg1) - 4) = &data_10040f18;
    void* result = *(arg1 - 0xc);
    *((*(result + 4) + arg1) - 0xc) = 0x10040f10;
    return result;
}

int32_t __fastcall sub_10005cc0(int32_t* arg1)
{
    int32_t var_4_2 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034c08;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t* var_10 = arg1;
    int32_t __saved_esi;
    int32_t var_18 = (__security_cookie ^ &__saved_esi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_10_1 = arg1;
    *arg1 = 0x10040f28;
    int32_t var_4 = 0;
    
    if (arg1[0x12] != 0)
        sub_100070d0(arg1);
    
    int32_t var_4_1 = 0xffffffff;
    int32_t* eax_3 = arg1[0xe];
    *arg1 = 0x10040ed4;
    sub_100082c0(eax_3);
    int32_t result = sub_10033f00(&arg1[1]);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t __thiscall sub_10005d40(void* arg1, int32_t arg2)
{
    int32_t var_c = 0xffffffff;
    int32_t (* var_10)(void* arg1) = sub_10034a17;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    void var_94;
    int32_t eax_2 = (__security_cookie ^ &var_94);
    int32_t __saved_edi;
    int32_t var_a4 = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void* ebx = arg1;
    void* var_84 = ebx;
    int32_t var_8c = 0;
    
    if (arg2 != 0xffffffff)
    {
        int32_t* ecx = *(ebx + 0x24);
        int32_t* ecx_1;
        int32_t edx_1;
        
        if (*ecx != 0)
        {
            edx_1 = *ecx;
            ecx_1 = *(ebx + 0x34);
        }
        
        if ((*ecx == 0 || edx_1 >= (*ecx_1 + edx_1)))
        {
            char** ecx_3 = *(ebx + 0x4c);
            
            if (ecx_3 != 0)
            {
                if (*(ebx + 0x3c) != 0)
                {
                    char var_8e = arg2;
                    void var_3c;
                    sub_10006d10(&var_3c);
                    int32_t var_c_1 = 0;
                    void var_6c;
                    int32_t* eax_10 = sub_10006f50(&var_3c, &var_6c);
                    var_c_1 = 1;
                    void var_60;
                    int32_t* var_88 = sub_10006f50(&var_3c, &var_60);
                    var_c_1 = 2;
                    int32_t eax_12 = sub_10007a60(eax_10);
                    char var_8d;
                    int32_t var_78;
                    int32_t var_74;
                    void* var_24;
                    int32_t esi_7 = *(**(ebx + 0x3c) + 0x14)((ebx + 0x44), &var_8e, &var_8d, &var_74, sub_10007a60(var_88), (var_24 + eax_12), &var_78);
                    var_c_1 = 1;
                    void var_80;
                    sub_10032890(&var_80, 3);
                    var_c_1 = 3;
                    sub_10001240(&var_60);
                    var_c_1 = 1;
                    sub_100328d0(&var_80);
                    var_c_1 = 0;
                    sub_10032890(&var_88, 3);
                    var_c_1 = 4;
                    sub_10001240(&var_6c);
                    var_c_1 = 0;
                    int32_t edx_6 = sub_100328d0(&var_88);
                    
                    if (esi_7 >= 0)
                    {
                        while (true)
                        {
                            if (esi_7 > 1)
                            {
                                if (esi_7 != 3)
                                    break;
                                
                                sub_10002020(*(ebx + 0x4c), edx_6, var_8e);
                                int32_t var_c_3 = 0xffffffff;
                                sub_10005800(&var_3c);
                                goto label_10005f07;
                            }
                            
                            var_c_1 = 5;
                            void var_54;
                            int32_t eax_19 = sub_10007a60(sub_10006f50(&var_3c, &var_54));
                            uint32_t ebx_3 = (var_78 - eax_19);
                            var_c_1 = 0;
                            void var_70;
                            sub_10032890(&var_70, 3);
                            var_c_1 = 6;
                            sub_10001240(&var_54);
                            var_c_1 = 0;
                            int32_t ecx_19 = sub_100328d0(&var_70);
                            uint32_t eax_22;
                            
                            if (ebx_3 > 0)
                            {
                                var_c_1 = 7;
                                var_8c |= 1;
                                void var_48;
                                eax_22 = sub_1000db10(sub_10007a60(sub_10006f50(&var_3c, &var_48)), 1, ebx_3, *(var_84 + 0x4c));
                                var_8d = 1;
                            }
                            
                            if ((ebx_3 <= 0 || ebx_3 == eax_22))
                                var_8d = 0;
                            
                            var_c_1 = 0;
                            
                            if ((var_8c & 1) != 0)
                            {
                                var_8c &= 0xfffffffe;
                                sub_10006be0(ecx_19);
                            }
                            
                            if (var_8d != 0)
                                break;
                            
                            *(var_84 + 0x41) = 1;
                            
                            if (var_74 != &var_8e)
                            {
                                int32_t var_c_4 = 0xffffffff;
                                sub_10005800(&var_3c);
                                goto label_10005f07;
                            }
                            
                            if (ebx_3 <= 0)
                            {
                                void* ecx_22 = var_24;
                                
                                if (ecx_22 >= 0x20)
                                    break;
                                
                                if ((0xffffffff - ecx_22) <= 8)
                                {
                                    sub_10033f50();
                                    /* no return */
                                }
                                
                                void* esi_12 = (ecx_22 + 8);
                                
                                if (esi_12 > 0xfffffffe)
                                {
                                    sub_10033f50();
                                    /* no return */
                                }
                                
                                int32_t var_20;
                                int32_t eax_24 = var_20;
                                char* var_34;
                                bool cond:0_1;
                                
                                if (eax_24 >= esi_12)
                                {
                                    cond:0_1 = esi_12 <= 0;
                                    
                                    if (esi_12 != 0)
                                        goto label_1000607b;
                                    
                                    char* eax_33 = var_34;
                                    var_24 = esi_12;
                                    
                                    if (eax_24 < 0x10)
                                        eax_33 = &var_34;
                                    
                                    *eax_33 = 0;
                                }
                                else
                                {
                                    sub_10007c70(&var_3c, esi_12, ecx_22);
                                    eax_24 = var_20;
                                    ecx_22 = var_24;
                                    cond:0_1 = esi_12 <= 0;
                                label_1000607b:
                                    
                                    if (!(cond:0_1))
                                    {
                                        char* edx_9 = var_34;
                                        
                                        if (eax_24 < 0x10)
                                            edx_9 = &var_34;
                                        
                                        void* ecx_24 = (ecx_22 + edx_9);
                                        *ecx_24 = 0;
                                        *(ecx_24 + 4) = 0;
                                        char* eax_25 = var_34;
                                        var_24 = esi_12;
                                        
                                        if (var_20 < 0x10)
                                            eax_25 = &var_34;
                                        
                                        *(eax_25 + esi_12) = 0;
                                    }
                                }
                            }
                            
                            int32_t* eax_26 = sub_10006f50(&var_3c, &var_6c);
                            var_c_1 = 1;
                            int32_t* eax_27 = sub_10006f50(&var_3c, &var_60);
                            var_c_1 = 2;
                            int32_t eax_28 = sub_10007a60(eax_26);
                            esi_7 = *(**(var_84 + 0x3c) + 0x14)((var_84 + 0x44), &var_8e, &var_8d, &var_74, sub_10007a60(eax_27), (var_24 + eax_28), &var_78);
                            var_c_1 = 1;
                            sub_10032890(&var_80, 3);
                            var_c_1 = 3;
                            sub_10001240(&var_60);
                            var_c_1 = 1;
                            sub_100328d0(&var_80);
                            var_c_1 = 0;
                            sub_10032890(&var_88, 3);
                            var_c_1 = 4;
                            sub_10001240(&var_6c);
                            var_c_1 = 0;
                            edx_6 = sub_100328d0(&var_88);
                            
                            if (esi_7 < 0)
                                break;
                            
                            ebx = var_84;
                        }
                    }
                    
                    int32_t var_c_2 = 0xffffffff;
                    sub_10005800(&var_3c);
                }
                else
                    sub_1000c720(arg2, ecx_3);
            }
        }
        else
        {
            *ecx_1 -= 1;
            int32_t* ebx_1 = *(ebx + 0x24);
            char* ecx_2 = *ebx_1;
            *ebx_1 = &ecx_2[1];
            *ecx_2 = arg2;
        }
    }
    
label_10005f07:
    fsbase->NtTib.ExceptionList = ExceptionList;
    return sub_1000ac70((eax_2 ^ &var_94));
}

int32_t __thiscall sub_10006220(void* arg1, int32_t arg2)
{
    void* eax = **(arg1 + 0x20);
    
    if ((eax != 0 && (**(arg1 + 0x10) < eax && (arg2 == 0xffffffff || *(eax - 1) == arg2))))
    {
        int32_t* eax_2 = *(arg1 + 0x30);
        *eax_2 += 1;
        int32_t* ecx = *(arg1 + 0x20);
        *ecx -= 1;
        int32_t eax_5 = -((arg2 + 1));
        return ((eax_5 - eax_5) & arg2);
    }
    
    int32_t* eax_8 = *(arg1 + 0x4c);
    
    if (((eax_8 != 0 && (arg2 != 0xffffffff && *(arg1 + 0x3c) == 0)) && sub_1000c970(arg2, eax_8) != 0xffffffff))
        return arg2;
    
    return 0xffffffff;
}

uint32_t __fastcall sub_10006290(int32_t* arg1)
{
    int32_t* eax = arg1[8];
    char* ecx = *eax;
    
    if (ecx != 0)
    {
        int32_t eax_1 = *eax;
        
        if (eax_1 < (*arg1[0xc] + eax_1))
            return *ecx;
    }
    
    int32_t result = *(*arg1 + 0x14)();
    
    if (result == 0xffffffff)
        return result;
    
    *(*arg1 + 8)(result);
    return result;
}

int32_t __fastcall sub_100062e0(void* arg1)
{
    int32_t var_c = 0xffffffff;
    int32_t (* var_10)(void* arg1) = sub_10034bcb;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    void var_9c;
    int32_t eax_2 = (__security_cookie ^ &var_9c);
    int32_t __saved_edi;
    int32_t var_ac = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t ecx_2;
    
    if (**(arg1 + 0x20) != 0)
        ecx_2 = **(arg1 + 0x20);
    
    if ((**(arg1 + 0x20) == 0 || ecx_2 >= (**(arg1 + 0x30) + ecx_2)))
    {
        int32_t* ecx_5 = *(arg1 + 0x4c);
        
        if (ecx_5 != 0)
        {
            if (*(arg1 + 0x3c) != 0)
            {
                int32_t* var_3c = nullptr;
                int32_t var_20_1 = 0xf;
                void* var_24_1 = nullptr;
                char var_34 = 0;
                int32_t var_c_1 = 0;
                uint32_t i = sub_1000c4d0(ecx_5);
                
                if (i != 0xffffffff)
                {
                    do
                    {
                        if ((0xffffffff - var_24_1) <= 1)
                        {
                            sub_10033f50();
                            /* no return */
                        }
                        
                        void* esi_2 = (var_24_1 + 1);
                        
                        if (esi_2 > 0xfffffffe)
                        {
                            sub_10033f50();
                            /* no return */
                        }
                        
                        int32_t eax_14 = var_20_1;
                        bool cond:0_1;
                        
                        if (eax_14 >= esi_2)
                        {
                            cond:0_1 = esi_2 <= 0;
                            
                            if (esi_2 != 0)
                                goto label_10006433;
                            
                            char* eax_31 = var_34;
                            var_24_1 = nullptr;
                            
                            if (eax_14 < 0x10)
                                eax_31 = &var_34;
                            
                            *eax_31 = 0;
                        }
                        else
                        {
                            sub_10007c70(&var_3c, esi_2, var_24_1);
                            eax_14 = var_20_1;
                            cond:0_1 = esi_2 <= 0;
                        label_10006433:
                            
                            if (!(cond:0_1))
                            {
                                char* eax_15 = var_34;
                                
                                if (eax_14 < 0x10)
                                    eax_15 = &var_34;
                                
                                *(eax_15 + var_24_1) = i;
                                char* eax_16 = var_34;
                                var_24_1 = esi_2;
                                
                                if (var_20_1 < 0x10)
                                    eax_16 = &var_34;
                                
                                *(eax_16 + esi_2) = 0;
                            }
                        }
                        int32_t* var_6c;
                        int32_t* eax_17 = sub_10006f50(&var_3c, &var_6c);
                        var_c_1 = 1;
                        int32_t* var_78;
                        int32_t* eax_18 = sub_10006f50(&var_3c, &var_78);
                        var_c_1 = 2;
                        int32_t eax_19 = sub_10007a60(eax_17);
                        char var_95;
                        int32_t var_94;
                        int32_t var_90;
                        int32_t eax_24 = *(**(arg1 + 0x3c) + 0x10)((arg1 + 0x44), sub_10007a60(eax_18), (var_24_1 + eax_19), &var_94, &var_95, &var_94, &var_90);
                        var_c_1 = 1;
                        void var_80;
                        sub_10032890(&var_80, 3);
                        var_c_1 = 3;
                        int32_t* eax_25 = var_78;
                        
                        if ((eax_25 != 0 && *eax_25 != 0xfffffffd))
                        {
                            int32_t* esi_9 = eax_25;
                            
                            if (*eax_25 != 0)
                            {
                                int32_t eax_26;
                                
                                do
                                {
                                    eax_26 = *esi_9;
                                    
                                    if (eax_26 == &var_78)
                                        break;
                                    
                                    esi_9 = (eax_26 + 4);
                                } while (*(eax_26 + 4) != 0);
                            }
                            
                            if (*esi_9 == 0)
                                sub_10032900(u"ITERATOR LIST CORRUPTED!", u"E:\Program Files\Microsoft Visua…", 0xbd);
                            
                            int32_t var_74;
                            *esi_9 = var_74;
                            var_78 = nullptr;
                        }
                        
                        var_c_1 = 1;
                        sub_100328d0(&var_80);
                        var_c_1 = 0;
                        void var_8c;
                        sub_10032890(&var_8c, 3);
                        var_c_1 = 4;
                        int32_t* esi_10 = var_6c;
                        
                        if ((esi_10 != 0 && *esi_10 != 0xfffffffd))
                        {
                            if (*esi_10 == 0)
                                sub_10032900(u"ITERATOR LIST CORRUPTED!", u"E:\Program Files\Microsoft Visua…", 0xbd);
                            else
                            {
                                int32_t eax_27;
                                
                                do
                                {
                                    eax_27 = *esi_10;
                                    
                                    if (eax_27 == &var_6c)
                                        break;
                                    
                                    esi_10 = (eax_27 + 4);
                                } while (*(eax_27 + 4) != 0);
                                
                                if (*esi_10 == 0)
                                    sub_10032900(u"ITERATOR LIST CORRUPTED!", u"E:\Program Files\Microsoft Visua…", 0xbd);
                            }
                            
                            int32_t var_68;
                            *esi_10 = var_68;
                            var_6c = nullptr;
                        }
                        
                        var_c_1 = 0;
                        sub_100328d0(&var_8c);
                        
                        if (eax_24 < 0)
                            break;
                        
                        if (eax_24 <= 1)
                        {
                            int32_t** ecx_22 = &var_3c;
                            
                            if (var_90 != &var_95)
                            {
                                var_c_1 = 5;
                                void var_54;
                                int32_t eax_36;
                                int32_t ecx_28;
                                eax_36 = sub_10007a60(sub_10006f50(ecx_22, &var_54));
                                void* j = ((var_24_1 - var_94) + eax_36);
                                var_c_1 = 0;
                                sub_10006be0(ecx_28);
                                
                                while (j > 0)
                                {
                                    int32_t eax_37 = *((j + var_94) - 1);
                                    j -= 1;
                                    sub_1000c970(eax_37, *(arg1 + 0x4c));
                                }
                                
                                int32_t var_c_4 = 0xffffffff;
                                sub_10005800(&var_3c);
                                goto label_100063c4;
                            }
                            
                            var_c_1 = 6;
                            void var_48;
                            int32_t eax_33 = sub_10007a60(sub_10006f50(ecx_22, &var_48));
                            sub_10006ec0(&var_3c, nullptr, (var_94 - eax_33));
                            var_c_1 = 0;
                            void var_7c;
                            sub_10032890(&var_7c, 3);
                            var_c_1 = 7;
                            sub_10001240(&var_48);
                            var_c_1 = 0;
                            sub_100328d0(&var_7c);
                        }
                        else
                        {
                            if (eax_24 != 3)
                                break;
                            
                            if (var_24_1 >= 1)
                            {
                                var_c_1 = 8;
                                var_c_1 = 0;
                                void var_60;
                                sub_10006be0(sub_1000ad50(&var_95, 1, sub_10007a60(sub_10006f50(&var_3c, &var_60)), 1));
                                int32_t var_c_3 = 0xffffffff;
                                sub_10005800(&var_3c);
                                goto label_100063c4;
                            }
                        }
                        
                        i = sub_1000c4d0(*(arg1 + 0x4c));
                    } while (i != 0xffffffff);
                }
                
                int32_t var_c_2 = 0xffffffff;
                sub_10005800(&var_3c);
            }
            else
                sub_1000c4d0(ecx_5);
        }
    }
    else
    {
        int32_t* ecx_3 = *(arg1 + 0x30);
        *ecx_3 -= 1;
        int32_t* eax_6 = *(arg1 + 0x20);
        char* ecx_4 = *eax_6;
        *eax_6 = &ecx_4[1];
        *ecx_4;
    }
    
label_100063c4:
    fsbase->NtTib.ExceptionList = ExceptionList;
    return sub_1000ac70((eax_2 ^ &var_9c));
}

int32_t* __thiscall sub_10006790(int32_t* arg1, int32_t* arg2, int32_t arg3, enum SET_FILE_POINTER_MOVE_METHOD arg4)
{
    int32_t ebx_1;
    
    if (((*arg1[8] != &arg1[0x10] || arg4 != FILE_CURRENT) || arg1[0xf] != 0))
        ebx_1 = arg3;
    else
        ebx_1 = (arg3 - 1);
    
    if ((arg1[0x13] != 0 && sub_10007200(arg1) != 0))
    {
        if ((ebx_1 != 0 || arg4 != FILE_CURRENT))
        {
            if (sub_1000e000(arg1[0x13], ebx_1, arg4) == 0)
                goto label_100067f8;
        }
        else
        {
        label_100067f8:
            int32_t var_10;
            
            if (sub_1000e250(arg1[0x13], &var_10) == 0)
            {
                if (*arg1[8] == &arg1[0x10])
                {
                    *arg1[4] = &arg1[0x10];
                    *arg1[8] = (arg1 + 0x41);
                    *arg1[0xc] = (arg1 * 0);
                }
                
                arg2[2] = var_10;
                int32_t ecx_7 = arg1[0x11];
                *arg2 = 0;
                int32_t var_c;
                arg2[3] = var_c;
                arg2[4] = ecx_7;
                return arg2;
            }
        }
    }
    
    *arg2 = 0xffffffff;
    arg2[2] = 0;
    arg2[3] = 0;
    arg2[4] = 0;
    return arg2;
}

int32_t* __thiscall sub_10006870(int32_t* arg1, int32_t* arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6)
{
    bool cond:0 = arg1[0x13] == 0;
    int32_t var_10 = arg4;
    
    if (((!(cond:0) && sub_10007200(arg1) != 0) && sub_1000e360(arg1[0x13], &var_10) == 0))
    {
        if (arg3 == 0)
        {
        label_100068dc:
            
            if (sub_1000e250(arg1[0x13], &var_10) == 0)
            {
                int32_t* edx = arg1[8];
                arg1[0x11] = arg6;
                
                if (*edx == &arg1[0x10])
                {
                    *arg1[4] = &arg1[0x10];
                    *arg1[8] = (arg1 + 0x41);
                    *arg1[0xc] = (arg1 * 0);
                }
                
                arg2[2] = var_10;
                int32_t ecx_7 = arg1[0x11];
                *arg2 = 0;
                arg2[3] = arg5;
                arg2[4] = ecx_7;
                return arg2;
            }
        }
        else if (sub_1000e000(arg1[0x13], arg3, FILE_CURRENT) == 0)
            goto label_100068dc;
    }
    
    *arg2 = 0xffffffff;
    arg2[2] = 0;
    arg2[3] = 0;
    arg2[4] = 0;
    return arg2;
}

void* __thiscall sub_10006960(void* arg1, void* arg2, int32_t arg3)
{
    void** ecx = *(arg1 + 0x4c);
    
    if (ecx != 0)
    {
        int32_t eax_1;
        
        if ((arg2 != 0 || arg3 != 0))
            eax_1 = 0;
        else
            eax_1 = (arg3 + 4);
        
        if (sub_1000e450(ecx, arg2, eax_1, arg3) == 0)
        {
            sub_10007160(*(arg1 + 0x4c), arg1, 1);
            return arg1;
        }
    }
    
    return 0;
}

int32_t __fastcall sub_100069b0(int32_t* arg1)
{
    if (((arg1[0x13] != 0 && *(*arg1 + 4)(0xffffffff) != 0xffffffff) && sub_1000d570(arg1[0x13]) < 0))
        return 0xffffffff;
    
    return 0;
}

int32_t* __thiscall sub_100069e0(void* arg1, int32_t* arg2)
{
    return sub_10007620(arg1, sub_10008330(arg2));
}

int32_t* __thiscall sub_10006a00(int32_t* arg1, void* arg2)
{
    sub_1000c150(arg1, arg2);
    *arg1 = 0x10037f68;
    return arg1;
}

int32_t __fastcall CRRU9809::CRRU9809(int32_t arg1) __pure
{
    return arg1;
}

int32_t* __thiscall sub_10006a30(void* arg1, char arg2)
{
    *((*(*(arg1 - 4) + 4) + arg1) - 4) = &data_10040f18;
    *arg1 = &data_10040ec4;
    sub_10033d70(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80((arg1 - 4));
    
    return (arg1 - 4);
}

void*** __thiscall sub_10006a70(void*** arg1, char arg2)
{
    *arg1 = &data_10040ec4;
    sub_10033d70(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80(arg1);
    
    return arg1;
}

int32_t* __thiscall sub_10006aa0(void* arg1, char arg2)
{
    *((*(*(arg1 - 8) + 4) + arg1) - 8) = 0x10040f10;
    *arg1 = &data_10040ec4;
    sub_10033d70(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80((arg1 - 8));
    
    return (arg1 - 8);
}

int32_t* __thiscall sub_10006ae0(int32_t* arg1, char arg2)
{
    int32_t* eax = arg1[0xe];
    *arg1 = 0x10040ed4;
    sub_100082c0(eax);
    sub_10033f00(&arg1[1]);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80(arg1);
    
    return arg1;
}

void* __thiscall sub_10006b20(void* arg1, char arg2)
{
    sub_10005c00(arg1);
    *arg1 = &data_10040ec4;
    sub_10033d70(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80((arg1 - 0x5c));
    
    return (arg1 - 0x5c);
}

int32_t* __thiscall sub_10006b60(void* arg1, char arg2)
{
    *((*(*(arg1 - 0xc) + 4) + arg1) - 0xc) = &data_10040f20;
    *((*(*(arg1 - 4) + 4) + arg1) - 4) = &data_10040f18;
    *((*(*(arg1 - 0xc) + 4) + arg1) - 0xc) = 0x10040f10;
    *arg1 = &data_10040ec4;
    sub_10033d70(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80((arg1 - 0xc));
    
    return (arg1 - 0xc);
}

int32_t* __thiscall sub_10006bc0(int32_t* arg1, char arg2)
{
    sub_10005cc0(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80(arg1);
    
    return arg1;
}

int32_t* __fastcall sub_10006be0(int32_t arg1)
{
    int32_t var_4_2 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034898;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t var_10 = arg1;
    int32_t var_14 = (__security_cookie ^ &var_10);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    sub_10032890(&var_10, 3);
    int32_t var_4 = 0;
    int32_t* edi;
    sub_10001240(edi);
    int32_t var_4_1 = 0xffffffff;
    int32_t* result = sub_100328d0(&var_10);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t* __fastcall j_sub_10001290(int32_t* arg1)
{
    /* tailcall */
    return sub_10001290(arg1);
}

void sub_10006c50()
{
    int32_t* ebx;
    void* ecx_2 = *ebx;
    int32_t* ebp = *(ecx_2 - 0x10);
    
    if (*(ecx_2 - 0xc) != 0)
    {
        int32_t eax_1 = *(ecx_2 - 4);
        
        if (eax_1 < 0)
        {
            if ((*(ecx_2 - 8) < 0 && sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x356, nullptr, u"nLength <= GetData()->nAllocLeng…") == 1))
                breakpoint();
            
            void* eax_3 = *ebx;
            
            if (*(eax_3 - 8) < 0)
            {
                sub_100010a0(0x80070057);
                /* no return */
            }
            
            *(eax_3 - 0xc) = 0;
            **ebx = 0;
            return;
        }
        
        if ((eax_1 == 0 && sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x6b, nullptr, u"nRefs != 0") == 1))
            breakpoint();
        
        int32_t edx_1 = *(ecx_2 - 4);
        *(ecx_2 - 4) -= 1;
        
        if ((edx_1 - 1) <= 0)
            *(**(ecx_2 - 0x10) + 4)((ecx_2 - 0x10));
        
        *ebx = (*(*ebp + 0xc)() + 0x10);
    }
}

int32_t* __stdcall sub_10006d10(int32_t* arg1)
{
    int32_t var_4_1 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034998;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_edi;
    int32_t var_1c = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    *arg1 = 0;
    int32_t var_4 = 0;
    arg1[7] = 0xf;
    void* edi = &arg1[2];
    arg1[6] = 0;
    *edi = 0;
    
    if (arg1[7] < 8)
        sub_10007c70(arg1, 8, arg1[6]);
    
    void* ecx_2;
    
    if (arg1[7] < 0x10)
        ecx_2 = edi;
    else
        ecx_2 = *edi;
    
    *ecx_2 = 0;
    *(ecx_2 + 4) = 0;
    arg1[6] = 8;
    
    if (arg1[7] >= 0x10)
        edi = *edi;
    
    *(edi + 8) = 0;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg1;
}

void* __thiscall sub_10006da0(void* arg1, void* arg2, void* arg3, void* arg4)
{
    if (*(arg2 + 0x18) < arg3)
    {
        sub_100341f0();
        /* no return */
    }
    
    void* edi_1 = (*(arg2 + 0x18) - arg3);
    
    if (arg4 < edi_1)
        edi_1 = arg4;
    
    if (arg1 == arg2)
    {
        sub_10006ec0(arg1, (edi_1 + arg3), 0xffffffff);
        sub_10006ec0(arg1, nullptr, arg3);
        return arg1;
    }
    
    if (edi_1 > 0xfffffffe)
    {
        sub_10033f50();
        /* no return */
    }
    
    int32_t eax_2 = *(arg1 + 0x1c);
    bool cond:0;
    
    if (eax_2 >= edi_1)
    {
        cond:0 = edi_1 <= 0;
        
        if (edi_1 == 0)
        {
            *(arg1 + 0x18) = edi_1;
            
            if (eax_2 >= 0x10)
            {
                **(arg1 + 8) = 0;
                return arg1;
            }
            
            *(arg1 + 8) = 0;
            return arg1;
        }
    }
    else
    {
        sub_10007c70(arg1, edi_1, *(arg1 + 0x18));
        cond:0 = edi_1 <= 0;
    }
    
    if (!(cond:0))
    {
        void* edx_1;
        
        if (*(arg2 + 0x1c) < 0x10)
            edx_1 = (arg2 + 8);
        else
            edx_1 = *(arg2 + 8);
        
        int32_t ecx_3 = *(arg1 + 0x1c);
        char* ebx_1 = (arg1 + 8);
        char* eax_8;
        
        if (ecx_3 < 0x10)
            eax_8 = ebx_1;
        else
            eax_8 = *ebx_1;
        
        sub_1000ad50(eax_8, ecx_3, (edx_1 + arg3), edi_1);
        bool cond:1_1 = *(arg1 + 0x1c) < 0x10;
        *(arg1 + 0x18) = edi_1;
        
        if (!(cond:1_1))
            ebx_1 = *ebx_1;
        
        *(ebx_1 + edi_1) = 0;
    }
    
    return arg1;
}

void* __thiscall sub_10006e80(void* arg1, int128_t* arg2)
{
    void* edi = arg1;
    
    if (arg2 == 0)
        sub_10032900(u"invalid null pointer", u"E:\Program Files\Microsoft Visua…", 0x43c);
    
    char* eax = arg2;
    
    do
    {
        arg1 = *eax;
        eax = &eax[1];
    } while (arg1 != 0);
    
    return sub_100077a0(edi, arg2, (eax - &eax[1]));
}

void* __thiscall sub_10006ec0(void* arg1, void* arg2, void* arg3)
{
    void* ebx = arg2;
    
    if (*(arg1 + 0x18) < ebx)
    {
        sub_100341f0();
        /* no return */
    }
    
    void* edi = arg3;
    void* eax_1 = (*(arg1 + 0x18) - ebx);
    
    if (eax_1 < edi)
        edi = eax_1;
    
    if (edi > 0)
    {
        int32_t ecx = *(arg1 + 0x1c);
        void* ebp_1 = (arg1 + 8);
        
        if (ecx < 0x10)
            arg2 = ebp_1;
        else
            arg2 = *ebp_1;
        
        void* edx_2;
        
        if (ecx < 0x10)
            edx_2 = ebp_1;
        else
            edx_2 = *ebp_1;
        
        sub_1000aee0((edx_2 + ebx), (ecx - ebx), ((arg2 + ebx) + edi), (eax_1 - edi));
        char* eax_7 = (*(arg1 + 0x18) - edi);
        bool cond:0_1 = *(arg1 + 0x1c) < 0x10;
        *(arg1 + 0x18) = eax_7;
        
        if (!(cond:0_1))
            ebp_1 = *ebp_1;
        
        *(eax_7 + ebp_1) = 0;
    }
    
    return arg1;
}

int32_t* __fastcall sub_10006f50(int32_t** arg1, int32_t* arg2 @ esi)
{
    int32_t** var_4 = arg1;
    
    if (arg1[7] < 0x10)
    {
        sub_10007df0(arg1, arg2);
        return arg2;
    }
    
    arg1[2];
    sub_10007df0(arg1, arg2);
    return arg2;
}

int32_t __convention("regparm") sub_10006f80(void* arg1)
{
    if (**(arg1 + 0x20) == 0)
        return 0;
    
    return **(arg1 + 0x30);
}

int32_t __convention("regparm") sub_10006fa0(void* arg1)
{
    if (**(arg1 + 0x24) == 0)
        return 0;
    
    return **(arg1 + 0x34);
}

int32_t* __stdcall sub_10006fc0(int32_t* arg1, int32_t arg2)
{
    int32_t var_4 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034f1b;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t ecx;
    int32_t var_10 = ecx;
    int32_t __saved_esi;
    int32_t var_18 = (__security_cookie ^ &__saved_esi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_10_1 = 0;
    sub_100078a0(arg1, arg2);
    *((arg1 + *(arg1[2] + 4)) + 8) = &data_10040f18;
    *(arg1 + *(*arg1 + 4)) = &data_10040f20;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg1;
}

void* __fastcall sub_10007030(void* arg1)
{
    int32_t var_4_1 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034e28;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    void* var_10 = arg1;
    int32_t __saved_edi;
    int32_t var_1c = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    
    if (*(arg1 + 0x4c) == 0)
    {
        int32_t* eax_3 = sub_10034340(u"writelog.txt", 1, 0x40);
        
        if (eax_3 != 0)
        {
            sub_10007160(eax_3, arg1, 1);
            int32_t var_4 = 0;
            sub_10007620(arg1, sub_10008330(sub_10007a30(arg1, &var_10)));
            sub_10001670(&var_10);
            fsbase->NtTib.ExceptionList = ExceptionList;
            return arg1;
        }
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return 0;
}

int32_t* sub_100070d0(int32_t* arg1 @ esi)
{
    int32_t* result = arg1;
    int32_t eax_3;
    
    if (arg1[0x13] != 0)
    {
        if (sub_10007200(arg1) == 0)
            result = nullptr;
        
        eax_3 = sub_1000d900(arg1[0x13]);
    }
    
    if ((arg1[0x13] == 0 || eax_3 != 0))
        result = nullptr;
    
    arg1[4] = &arg1[2];
    arg1[0x12] = 0;
    *(arg1 + 0x41) = 0;
    arg1[8] = &arg1[6];
    arg1[9] = &arg1[7];
    arg1[5] = &arg1[3];
    arg1[0xc] = &arg1[0xa];
    arg1[0xd] = &arg1[0xb];
    arg1[3] = 0;
    *arg1[9] = 0;
    *arg1[0xd] = 0;
    *arg1[4] = 0;
    int32_t ecx_6 = data_10049230;
    *arg1[8] = 0;
    *arg1[0xc] = 0;
    arg1[0x13] = 0;
    arg1[0xf] = 0;
    arg1[0x11] = ecx_6;
    return result;
}

void __thiscall sub_10007160(int32_t arg1, void* arg2 @ eax, int32_t arg3)
{
    *(arg2 + 0x20) = (arg2 + 0x18);
    *(arg2 + 0x48) = arg3 == 1;
    *(arg2 + 0x24) = (arg2 + 0x1c);
    *(arg2 + 0x10) = (arg2 + 8);
    *(arg2 + 0x30) = (arg2 + 0x28);
    *(arg2 + 0x41) = 0;
    *(arg2 + 0x14) = (arg2 + 0xc);
    *(arg2 + 0x34) = (arg2 + 0x2c);
    *(arg2 + 0xc) = 0;
    **(arg2 + 0x24) = 0;
    **(arg2 + 0x34) = 0;
    **(arg2 + 0x10) = 0;
    **(arg2 + 0x20) = 0;
    **(arg2 + 0x30) = 0;
    
    if (arg1 != 0)
    {
        *(arg2 + 0x10) = (arg1 + 8);
        *(arg2 + 0x14) = (arg1 + 8);
        *(arg2 + 0x20) = arg1;
        *(arg2 + 0x24) = arg1;
        *(arg2 + 0x30) = (arg1 + 4);
        *(arg2 + 0x34) = (arg1 + 4);
    }
    
    *(arg2 + 0x4c) = arg1;
    *(arg2 + 0x44) = data_10049230;
    *(arg2 + 0x3c) = 0;
}

int32_t __fastcall sub_10007200(int32_t* arg1)
{
    int32_t var_c = 0xffffffff;
    int32_t (* var_10)(void* arg1) = sub_10034b51;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    void var_8c;
    int32_t eax_2 = (__security_cookie ^ &var_8c);
    int32_t ebx;
    int32_t var_90 = ebx;
    int32_t __saved_edi;
    int32_t var_9c = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_88 = 0;
    struct _EXCEPTION_REGISTRATION_RECORD** eax_5;
    
    if ((arg1[0xf] == 0 || *(arg1 + 0x41) == 0))
        eax_5 = 1;
    else if (*(*arg1 + 4)(0xffffffff) == 0xffffffff)
    {
    label_100075d8:
        int32_t eax_7;
        eax_7 = 0;
    }
    else
    {
        void var_3c;
        sub_10006d10(&var_3c);
        int32_t var_c_1 = 0;
        
        while (true)
        {
            int32_t* var_54;
            int32_t* eax_8 = sub_10006f50(&var_3c, &var_54);
            var_c_1 = 1;
            int32_t* var_6c;
            int32_t* eax_9 = sub_10006f50(&var_3c, &var_6c);
            var_c_1 = 2;
            int32_t eax_10 = sub_10007a60(eax_8);
            int32_t var_80;
            void* var_24;
            int32_t eax_14 = *(*arg1[0xf] + 0x18)(&arg1[0x11], sub_10007a60(eax_9), (var_24 + eax_10), &var_80);
            var_c_1 = 1;
            void var_74;
            sub_10032890(&var_74, 3);
            var_c_1 = 3;
            int32_t* eax_15 = var_6c;
            
            if ((eax_15 != 0 && *eax_15 != 0xfffffffd))
            {
                int32_t* esi_7 = eax_15;
                
                if (*eax_15 != 0)
                {
                    int32_t eax_16;
                    
                    do
                    {
                        eax_16 = *esi_7;
                        
                        if (eax_16 == &var_6c)
                            break;
                        
                        esi_7 = (eax_16 + 4);
                    } while (*(eax_16 + 4) != 0);
                }
                
                if (*esi_7 == 0)
                    sub_10032900(u"ITERATOR LIST CORRUPTED!", u"E:\Program Files\Microsoft Visua…", 0xbd);
                
                int32_t var_68;
                *esi_7 = var_68;
                var_6c = nullptr;
            }
            
            var_c_1 = 1;
            sub_100328d0(&var_74);
            var_c_1 = 0;
            void var_7c;
            sub_10032890(&var_7c, 3);
            var_c_1 = 4;
            int32_t* esi_8 = var_54;
            
            if ((esi_8 != 0 && *esi_8 != 0xfffffffd))
            {
                if (*esi_8 == 0)
                    sub_10032900(u"ITERATOR LIST CORRUPTED!", u"E:\Program Files\Microsoft Visua…", 0xbd);
                else
                {
                    int32_t eax_17;
                    
                    do
                    {
                        eax_17 = *esi_8;
                        
                        if (eax_17 == &var_54)
                            break;
                        
                        esi_8 = (eax_17 + 4);
                    } while (*(eax_17 + 4) != 0);
                    
                    if (*esi_8 == 0)
                        sub_10032900(u"ITERATOR LIST CORRUPTED!", u"E:\Program Files\Microsoft Visua…", 0xbd);
                }
                
                int32_t var_50;
                *esi_8 = var_50;
                var_54 = nullptr;
            }
            
            var_c_1 = 0;
            sub_100328d0(&var_7c);
            int32_t* ecx_8;
            
            if (eax_14 == 0)
            {
                *(arg1 + 0x41) = 0;
            label_1000741c:
                var_c_1 = 5;
                int32_t* var_60;
                int32_t eax_23 = sub_10007a60(sub_10006f50(&var_3c, &var_60));
                uint32_t ebx_5 = (var_80 - eax_23);
                var_c_1 = 0;
                void var_70;
                sub_10032890(&var_70, 3);
                var_c_1 = 6;
                int32_t* esi_11 = var_60;
                
                if ((esi_11 != 0 && *esi_11 != 0xfffffffd))
                {
                    if (*esi_11 == 0)
                        sub_10032900(u"ITERATOR LIST CORRUPTED!", u"E:\Program Files\Microsoft Visua…", 0xbd);
                    else
                    {
                        int32_t eax_24;
                        
                        do
                        {
                            eax_24 = *esi_11;
                            
                            if (eax_24 == &var_60)
                                break;
                            
                            esi_11 = (eax_24 + 4);
                        } while (*(eax_24 + 4) != 0);
                        
                        if (*esi_11 == 0)
                            sub_10032900(u"ITERATOR LIST CORRUPTED!", u"E:\Program Files\Microsoft Visua…", 0xbd);
                    }
                    
                    int32_t var_5c;
                    *esi_11 = var_5c;
                    var_60 = nullptr;
                }
                
                var_c_1 = 0;
                int32_t ecx_12 = sub_100328d0(&var_70);
                char var_89_1;
                uint32_t eax_27;
                
                if (ebx_5 > 0)
                {
                    var_c_1 = 7;
                    var_88 |= 1;
                    void var_48;
                    eax_27 = sub_1000db10(sub_10007a60(sub_10006f50(&var_3c, &var_48)), 1, ebx_5, arg1[0x13]);
                    var_89_1 = 1;
                }
                
                if ((ebx_5 <= 0 || ebx_5 == eax_27))
                    var_89_1 = 0;
                
                var_c_1 = 0;
                
                if ((var_88 & 1) != 0)
                {
                    var_88 &= 0xfffffffe;
                    sub_10006be0(ecx_12);
                }
                
                if (var_89_1 == 0)
                {
                    if (*(arg1 + 0x41) == 0)
                        int32_t var_c_4 = 0xffffffff;
                    else if (ebx_5 != 0)
                        continue;
                    else
                    {
                        if ((0xffffffff - var_24) <= 8)
                        {
                            sub_10033f50();
                            /* no return */
                        }
                        
                        void* esi_15 = (var_24 + 8);
                        
                        if (esi_15 > 0xfffffffe)
                        {
                            sub_10033f50();
                            /* no return */
                        }
                        
                        int32_t var_20;
                        int32_t eax_29 = var_20;
                        int32_t* var_34;
                        bool cond:5_1;
                        
                        if (eax_29 >= esi_15)
                        {
                            cond:5_1 = esi_15 <= 0;
                            
                            if (esi_15 == 0)
                            {
                                int32_t** eax_31 = var_34;
                                var_24 = esi_15;
                                
                                if (eax_29 < 0x10)
                                    eax_31 = &var_34;
                                
                                *eax_31 = nullptr;
                                continue;
                            }
                        }
                        else
                        {
                            sub_10007c70(&var_3c, esi_15, var_24);
                            eax_29 = var_20;
                            cond:5_1 = esi_15 <= 0;
                        }
                        
                        if (cond:5_1)
                            continue;
                        else
                        {
                            int32_t* ecx_17 = var_34;
                            
                            if (eax_29 < 0x10)
                                ecx_17 = &var_34;
                            
                            void* ecx_18 = (ecx_17 + var_24);
                            *ecx_18 = 0;
                            *(ecx_18 + 4) = 0;
                            int32_t** eax_30 = var_34;
                            var_24 = esi_15;
                            
                            if (var_20 < 0x10)
                                eax_30 = &var_34;
                            
                            *(eax_30 + esi_15) = 0;
                            continue;
                        }
                    }
                    
                    sub_10005800(&var_3c);
                    break;
                }
                
                int32_t var_c_3 = 0xffffffff;
                ecx_8 = &var_3c;
            }
            else
            {
                if (eax_14 == 1)
                    goto label_1000741c;
                
                int32_t var_c_2 = 0xffffffff;
                ecx_8 = &var_3c;
                
                if (eax_14 == 3)
                {
                    sub_10005800(ecx_8);
                    break;
                }
            }
            
            sub_10005800(ecx_8);
            goto label_100075d8;
        }
        
        eax_5 = 1;
    }
    fsbase->NtTib.ExceptionList = ExceptionList;
    return sub_1000ac70((eax_2 ^ &var_8c));
}

int32_t* sub_10007620(void* arg1 @ esi, int32_t* arg2 @ edi)
{
    char eax = *(*arg2 + 4)();
    
    if (eax != 0)
    {
        *(arg1 + 0x3c) = 0;
        return eax;
    }
    
    *(arg1 + 0x10) = (arg1 + 8);
    *(arg1 + 0x20) = (arg1 + 0x18);
    *(arg1 + 0x24) = (arg1 + 0x1c);
    *(arg1 + 0x3c) = arg2;
    *(arg1 + 0x14) = (arg1 + 0xc);
    *(arg1 + 0x30) = (arg1 + 0x28);
    *(arg1 + 0x34) = (arg1 + 0x2c);
    *(arg1 + 0xc) = 0;
    **(arg1 + 0x24) = 0;
    **(arg1 + 0x34) = 0;
    **(arg1 + 0x10) = 0;
    int32_t* eax_4 = *(arg1 + 0x20);
    *eax_4 = 0;
    **(arg1 + 0x30) = 0;
    return eax_4;
}

int32_t __stdcall sub_10007690(int32_t arg1, int32_t* arg2, int32_t arg3, int32_t* arg4)
{
    *arg2 = arg1;
    *arg4 = arg3;
    return 3;
}

int32_t __stdcall sub_100076b0(int32_t arg1, int32_t* arg2)
{
    *arg2 = arg1;
    return 3;
}

int32_t __stdcall sub_100076d0(int32_t arg1, int32_t arg2, int32_t arg3) __pure
{
    int32_t eax = (arg2 - arg1);
    
    if (arg3 >= eax)
        return eax;
    
    return arg3;
}

int32_t* __fastcall sub_100076f0(int32_t* arg1)
{
    *arg1 = 0;
    return arg1;
}

int32_t* __thiscall sub_10007700(int32_t* arg1, char arg2)
{
    *arg1 = 0x10040144;
    
    if ((arg2 & 1) != 0)
    {
        sub_10007700(0);
        __mktime32(arg1);
    }
    
    return arg1;
}

void* sub_10007730(int32_t arg1 @ esi, int32_t* arg2 @ edi)
{
    if ((arg1 < 0 && sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x355, nullptr, u"nLength >= 0") == 1))
        breakpoint();
    
    if ((arg1 > *(*arg2 - 8) && sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x356, nullptr, u"nLength <= GetData()->nAllocLeng…") == 1))
        breakpoint();
    
    if (arg1 >= 0)
    {
        void* result = *arg2;
        
        if (arg1 <= *(result - 8))
        {
            *(result - 0xc) = arg1;
            *(*arg2 + (arg1 << 1)) = 0;
            return result;
        }
    }
    
    sub_100010a0(0x80070057);
    /* no return */
}

void* __thiscall sub_100077a0(void* arg1, int128_t* arg2, void* arg3)
{
    if (arg3 != 0)
    {
        if (arg2 != 0)
            goto label_10007805;
        
        sub_10032900(u"invalid null pointer", u"E:\Program Files\Microsoft Visua…", 0x42c);
    label_100077cd:
        
        if (arg3 > 0xfffffffe)
        {
            sub_10033f50();
            /* no return */
        }
    }
    else if (arg2 != 0)
    {
    label_10007805:
        int32_t edx_1 = *(arg1 + 0x1c);
        void* eax_4 = (arg1 + 8);
        void* ecx_2;
        
        if (edx_1 < 0x10)
            ecx_2 = eax_4;
        else
            ecx_2 = *eax_4;
        
        if (arg2 >= ecx_2)
        {
            void* ecx_3;
            
            if (edx_1 < 0x10)
                ecx_3 = eax_4;
            else
                ecx_3 = *eax_4;
            
            if ((*(arg1 + 0x18) + ecx_3) > arg2)
            {
                if (edx_1 >= 0x10)
                    eax_4 = *eax_4;
                
                return sub_10006da0(arg1, arg1, (arg2 - eax_4), arg3);
            }
        }
        
        goto label_100077cd;
    }
    
    int32_t eax_1 = *(arg1 + 0x1c);
    bool cond:0;
    
    if (eax_1 >= arg3)
    {
        cond:0 = arg3 <= 0;
        
        if (arg3 == 0)
        {
            *(arg1 + 0x18) = arg3;
            
            if (eax_1 >= 0x10)
            {
                **(arg1 + 8) = arg3;
                return arg1;
            }
            
            *(arg1 + 8) = 0;
            return arg1;
        }
    }
    else
    {
        sub_10007c70(arg1, arg3, *(arg1 + 0x18));
        cond:0 = arg3 <= 0;
    }
    
    if (!(cond:0))
    {
        int32_t ecx_1 = *(arg1 + 0x1c);
        char* edi_1 = (arg1 + 8);
        char* eax_3;
        
        if (ecx_1 < 0x10)
            eax_3 = edi_1;
        else
            eax_3 = *edi_1;
        
        sub_1000ad50(eax_3, ecx_1, arg2, arg3);
        bool cond:1_1 = *(arg1 + 0x1c) < 0x10;
        *(arg1 + 0x18) = arg3;
        
        if (!(cond:1_1))
            edi_1 = *edi_1;
        
        *(edi_1 + arg3) = 0;
    }
    
    return arg1;
}

int32_t* __stdcall sub_100078a0(int32_t* arg1, int32_t arg2)
{
    int32_t var_4 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034ef0;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t ecx;
    int32_t var_10 = ecx;
    int32_t __saved_edi;
    int32_t var_20 = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_10_1 = 0;
    int32_t ecx_1 = *(*arg1 + 4);
    *(arg1 + ecx_1) = 0x10040f10;
    void* edx = *arg1;
    arg1[1] = 0;
    void* esi_1 = (*(edx + 4) + arg1);
    sub_10001f70(esi_1);
    void* var_24 = esi_1;
    *(esi_1 + 0x28) = arg2;
    *(esi_1 + 0x2c) = 0;
    *(esi_1 + 0x30) = sub_10008040(ecx_1);
    
    if (*(esi_1 + 0x28) == 0)
        sub_10001e30(esi_1, (*(esi_1 + 8) | 4));
    
    *(esi_1 + 4) = 0;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg1;
}

int32_t* __thiscall sub_10007930(int32_t arg1, int32_t* arg2)
{
    int32_t var_4_1 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_1003496b;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t var_10 = arg1;
    int32_t __saved_edi;
    int32_t var_20 = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    *arg2 = 0x10040ed4;
    sub_10033eb0(&arg2[1]);
    int32_t var_4 = 0;
    void* edi = sub_10033b20(4, &data_100401e0, "E:\Program Files\Microsoft Visua…", 0x1b);
    
    if (edi == 0)
        edi = nullptr;
    else
    {
        *edi = sub_10032cf0();
        void* eax_5 = __CrtGetAllocHook();
        sub_10032890(&var_10, 0);
        int32_t eax_6 = *(eax_5 + 4);
        
        if (eax_6 < 0xffffffff)
            *(eax_5 + 4) = (eax_6 + 1);
        
        sub_100328d0(&var_10);
    }
    
    arg2[4] = &arg2[2];
    arg2[8] = &arg2[6];
    arg2[9] = &arg2[7];
    arg2[0xe] = edi;
    arg2[5] = &arg2[3];
    arg2[0xc] = &arg2[0xa];
    arg2[0xd] = &arg2[0xb];
    arg2[3] = 0;
    *arg2[9] = 0;
    *arg2[0xd] = 0;
    *arg2[4] = 0;
    *arg2[8] = 0;
    *arg2[0xc] = 0;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg2;
}

int32_t* __convention("regparm") sub_10007a30(void* arg1, int32_t* arg2 @ edi)
{
    void* esi = **(arg1 + 0x38);
    *arg2 = esi;
    int32_t __saved_ecx;
    sub_10032890(&__saved_ecx, 0);
    int32_t eax = *(esi + 4);
    
    if (eax < 0xffffffff)
        *(esi + 4) = (eax + 1);
    
    sub_100328d0(&__saved_ecx);
    return arg2;
}

int32_t sub_10007a60(int32_t* arg1 @ esi)
{
    void* eax_5 = *arg1;
    
    if (eax_5 != 0)
    {
        int32_t result = arg1[2];
        
        if (result != 0)
        {
            void* ecx_1;
            
            if (*(eax_5 + 0x1c) < 0x10)
                ecx_1 = (eax_5 + 8);
            else
                ecx_1 = *(eax_5 + 8);
            
            if (result >= ecx_1)
            {
                void* ecx_2;
                
                if (*(eax_5 + 0x1c) < 0x10)
                    ecx_2 = (eax_5 + 8);
                else
                    ecx_2 = *(eax_5 + 8);
                
                if ((*(eax_5 + 0x18) + ecx_2) > result)
                    return result;
            }
        }
    }
    
    sub_10032900(u"string iterator not dereferencab…", u"E:\Program Files\Microsoft Visua…", 0x70);
    
    if (sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x71, nullptr, u"("Standard C++ Libraries Out of …") == 1)
        breakpoint();
    
    sub_1000c310(u""out of range"", u"std::_String_const_iterator<char…", u"E:\Program Files\Microsoft Visua…", 0x71, 0);
    return arg1[2];
}

void* __stdcall sub_10007af0(int32_t* arg1, int16_t* arg2, int32_t arg3)
{
    void* ecx = *arg1;
    int32_t ebp = arg3;
    int32_t ebx_2 = ((arg2 - ecx) >> 1);
    void* eax;
    eax = ebp >= 0;
    void* edi = *(ecx - 0xc);
    
    if (eax == 0)
    {
        if (sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x19d, eax, u"__atl_condVal") != 1)
        {
            sub_100010a0(0x80070057);
            /* no return */
        }
        
        breakpoint();
    }
    
    int32_t eax_2;
    
    if (arg2 != 0)
    {
        int16_t* eax_3 = arg2;
        int16_t i;
        
        do
        {
            i = *eax_3;
            eax_3 = &eax_3[1];
        } while (i != 0);
        eax_2 = ((eax_3 - &eax_3[1]) >> 1);
    }
    else
        eax_2 = 0;
    
    if (ebp > eax_2)
        ebp = eax_2;
    
    void* eax_5;
    eax_5 = (0x7fffffff - ebp) >= edi;
    
    if (eax_5 == 0)
    {
        if (sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x1a4, eax_5, u"__atl_condVal") != 1)
        {
            sub_100010a0(0x80070057);
            /* no return */
        }
        
        breakpoint();
    }
    
    void* esi_2 = (edi + ebp);
    
    if (((1 - *(ecx - 4)) | (*(ecx - 8) - esi_2)) < 0)
        sub_10007c20(arg1, (0x7fffffff - ebp), esi_2);
    
    int32_t ecx_4 = *arg1;
    int16_t* ebx_3 = (ecx_4 + (ebx_2 << 1));
    
    if (ebx_2 > edi)
        ebx_3 = arg2;
    
    int32_t eax_10 = (ebp * 2);
    sub_1000ad50((ecx_4 + (edi << 1)), eax_10, ebx_3, eax_10);
    
    if ((esi_2 < 0 && sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x246, nullptr, u"nNewLength >= 0") == 1))
        breakpoint();
    
    return sub_10007730(esi_2, arg1);
}

char** __convention("regparm") sub_10007c20(int32_t* arg1, int32_t arg2, int32_t arg3)
{
    void* eax = *arg1;
    int32_t edx = *(eax - 0xc);
    
    if (edx > arg3)
        arg3 = edx;
    
    if (*(eax - 4) > 1)
        return sub_10007ec0(arg1, arg3);
    
    int32_t result = *(eax - 8);
    
    if (result >= arg3)
        return result;
    
    int32_t edi_2;
    
    if (result <= 0x400)
        edi_2 = (result * 2);
    else
        edi_2 = (result + 0x400);
    
    if (edi_2 < arg3)
        edi_2 = arg3;
    
    return sub_10007f60(edi_2);
}

char* __thiscall sub_10007c70(void* arg1, void* arg2, void* arg3)
{
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = __ehhandler$?_FullAliasWait@_TaskCollection@details@Concurrency@@AAEXPAV123@@Z;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_ebp;
    int32_t var_3c = (__security_cookie ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_14 = &var_3c;
    void* var_18 = arg1;
    void* esi_1 = (arg2 | 0xf);
    
    if (esi_1 <= 0xfffffffe)
    {
        int32_t ebx_1 = *(arg1 + 0x1c);
        uint32_t ecx_1 = (ebx_1 >> 1);
        
        if (((esi_1 / 3) < ecx_1 && ebx_1 <= (0xfffffffe - ecx_1)))
            esi_1 = (ecx_1 + ebx_1);
    }
    else
        esi_1 = arg2;
    
    void* ecx_2 = (esi_1 + 1);
    int32_t var_8_1 = 0;
    
    if (ecx_2 <= 0)
        ecx_2 = nullptr;
    else if ((COMBINE(0, 0xffffffff) / ecx_2) < 1)
    {
        int32_t var_1c = 0;
        int32_t var_2c;
        sub_1000c090(&var_2c, &var_1c);
        var_2c = 0x10037f68;
        sub_1000ed00(&var_2c, &data_10042750);
        /* no return */
    }
    
    void* result_2 = sub_1000e720(ecx_2);
    
    if (arg3 > 0)
    {
        void* eax_8;
        
        if (*(arg1 + 0x1c) < 0x10)
            eax_8 = (arg1 + 8);
        else
            eax_8 = *(arg1 + 8);
        
        sub_1000ad50(result_2, (esi_1 + 1), eax_8, arg3);
    }
    
    if (*(arg1 + 0x1c) >= 0x10)
        sub_1000ab80(*(arg1 + 8));
    
    char* result_1 = result_2;
    char* result = (arg1 + 8);
    *result = 0;
    *result = result_1;
    *(arg1 + 0x1c) = esi_1;
    *(arg1 + 0x18) = arg3;
    
    if (esi_1 >= 0x10)
        result = result_1;
    
    *(result + arg3) = 0;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

void sub_10007db1(void* arg1 @ ebp) __noreturn
{
    void* esi = *(arg1 - 0x14);
    
    if (*(esi + 0x1c) >= 0x10)
        sub_1000ab80(*(esi + 8));
    
    *(esi + 0x1c) = 0xf;
    *(esi + 0x18) = 0;
    *(esi + 8) = 0;
    sub_1000ed00(0, nullptr);
    /* no return */
}

int32_t* __thiscall sub_10007df0(int32_t** arg1, int32_t* arg2)
{
    int32_t var_4_1 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034918;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_edi;
    int32_t var_18 = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    *arg2 = 0;
    arg2[1] = 0;
    int32_t var_4 = 0;
    int32_t ebx;
    
    if (arg1 != 0)
    {
        if (ebx == 0)
        {
        label_10007e6a:
            
            if (sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x4c, nullptr, u"("_Pstring == NULL || _Ptr != NU…") == 1)
                breakpoint();
            
            sub_1000c310(u""invalid argument"", u"std::_String_const_iterator<char…", u"E:\Program Files\Microsoft Visua…", 0x4c, 0);
        }
        else
        {
            int32_t edx_1 = arg1[7];
            void* eax_3 = &arg1[2];
            void* ecx;
            
            if (edx_1 < 0x10)
                ecx = eax_3;
            else
                ecx = *eax_3;
            
            if (ecx > ebx)
                goto label_10007e6a;
            
            if (edx_1 >= 0x10)
                eax_3 = *eax_3;
            
            if (ebx > (arg1[6] + eax_3))
                goto label_10007e6a;
        }
    }
    
    sub_100011c0(arg2, arg1);
    arg2[2] = ebx;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg2;
}

char** __stdcall sub_10007ec0(char** arg1, int32_t arg2)
{
    int32_t ebp = arg2;
    void* esi = *arg1;
    int32_t ebx = *(esi - 0xc);
    void* eax_3 = ***(**(esi - 0x10) + 0x10)()(ebp, 2);
    
    if (eax_3 == 0)
    {
        sub_10008100();
        /* no return */
    }
    
    if (ebx < ebp)
        ebp = ebx;
    
    sub_1000ad50((eax_3 + 0x10), ((ebp * 2) + 2), esi, ((ebp * 2) + 2));
    *(eax_3 + 4) = ebx;
    
    if ((*(esi - 4) == 0 && sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x6b, nullptr, u"nRefs != 0") == 1))
        breakpoint();
    
    int32_t edx_2 = *(esi - 4);
    *(esi - 4) -= 1;
    
    if ((edx_2 - 1) <= 0)
        *(**(esi - 0x10) + 4)((esi - 0x10));
    
    *arg1 = (eax_3 + 0x10);
    return arg1;
}

int32_t sub_10007f60(int32_t arg1 @ edi)
{
    int32_t* ebx;
    int32_t* esi_1 = (*ebx - 0x10);
    
    if ((esi_1[2] >= arg1 && sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x344, nullptr, u"pOldData->nAllocLength < nLength") == 1))
        breakpoint();
    
    if ((esi_1[2] < arg1 && arg1 > 0))
    {
        int32_t eax_3 = *(**esi_1 + 8)(esi_1, arg1, 2);
        
        if (eax_3 != 0)
        {
            *ebx = (eax_3 + 0x10);
            return (eax_3 + 0x10);
        }
    }
    
    sub_10008100();
    /* no return */
}

void* __stdcall sub_10007fd0(int32_t arg1)
{
    int32_t ecx = arg1;
    
    if (ecx <= 0)
        ecx = 0;
    else if ((COMBINE(0, 0xffffffff) / ecx) < 1)
    {
        arg1 = 0;
        int32_t var_c;
        sub_1000c090(&var_c, &arg1);
        var_c = 0x10037f68;
        sub_1000ed00(&var_c, &data_10042750);
        /* no return */
    }
    
    return sub_1000e720(ecx);
}

int32_t sub_10008030() __pure
{
    return 0xffffffff;
}

int32_t __fastcall sub_10008040(int32_t arg1)
{
    int32_t var_4_2 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034ec8;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t var_10 = arg1;
    int32_t __saved_edi;
    int32_t var_20 = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_4 = 0;
    int32_t* eax_5 = sub_10008170(sub_10001f40(arg_4, &arg_4));
    int32_t var_4_1 = 0xffffffff;
    void* edi_1 = arg_4;
    
    if (edi_1 != 0)
    {
        sub_10032890(&var_10, 0);
        int32_t eax_6 = *(edi_1 + 4);
        
        if ((eax_6 > 0 && eax_6 < 0xffffffff))
            *(edi_1 + 4) = (eax_6 - 1);
        
        int32_t esi_1 = *(edi_1 + 4);
        int32_t esi_2 = -(esi_1);
        void* esi_5 = (!((esi_2 - esi_2)) & edi_1);
        sub_100328d0(&var_10);
        
        if (esi_5 != 0)
        {
            **esi_5(0);
            __mktime32(esi_5);
        }
    }
    
    int32_t result = *(*eax_5 + 0x18)(0x20);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

void sub_10008100() __noreturn
{
    sub_100010a0(0x8007000e);
    /* no return */
}

void* sub_10008110(int32_t* arg1, int32_t arg2)
{
    if ((arg2 == 0 && sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x8e5, nullptr, u"AtlIsValidString( pszFormat )") == 1))
        breakpoint();
    
    return sub_10008480(arg1, &arg_c);
}

void sub_10008150(wchar16 const* const arg1)
{
    if (arg1 != 0)
        return;
    
    arg1 = u"invalid null pointer";
    /* tailcall */
    return sub_10032900();
}

int32_t __fastcall sub_10008170(int32_t* arg1)
{
    int32_t var_4_2 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034df8;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_edi;
    int32_t var_34 = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void var_1c;
    sub_10032890(&var_1c, 0);
    int32_t var_4 = 0;
    bool cond:0 = data_1004618c != 0;
    int32_t result_3 = data_10049228;
    int32_t result_1 = result_3;
    void var_20;
    
    if (!(cond:0))
    {
        sub_10032890(&var_20, 0);
        
        if (data_1004618c == 0)
        {
            int32_t eax_4 = (data_10046188 + 1);
            data_10046188 = eax_4;
            data_1004618c = eax_4;
        }
        
        sub_100328d0(&var_20);
    }
    
    int32_t esi = data_1004618c;
    void* eax_5 = *arg1;
    int32_t result_2;
    
    if (esi >= *(eax_5 + 0xc))
    {
        result_2 = 0;
        
        if (*(eax_5 + 0x14) == 0)
            goto label_1000821e;
        
        goto label_10008208;
    }
    
    result_2 = *(*(eax_5 + 8) + (esi << 2));
    int32_t result;
    
    if ((result_2 != 0 || *(eax_5 + 0x14) == 0))
    {
    label_1000821e:
        result = result_2;
    label_10008220:
        
        if (result == 0)
            goto label_10008224;
    }
    else
    {
    label_10008208:
        void* eax_6 = __CrtGetAllocHook();
        
        if (esi < *(eax_6 + 0xc))
        {
            result = *(*(eax_6 + 8) + (esi << 2));
            goto label_10008220;
        }
        
    label_10008224:
        
        if (result_3 == 0)
        {
            sub_10001810(&result_1, arg1);
            result = result_1;
            data_10049228 = result;
            sub_10032890(&var_20, 0);
            int32_t eax_7 = *(result + 4);
            
            if (eax_7 < 0xffffffff)
                *(result + 4) = (eax_7 + 1);
            
            sub_100328d0(&var_20);
            sub_100329b0(result);
        }
        else
            result = result_3;
    }
    
    int32_t var_4_1 = 0xffffffff;
    sub_100328d0(&var_1c);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

void sub_100082c0(int32_t* arg1)
{
    int32_t* ebx = arg1;
    
    if (ebx != 0)
    {
        void* edi_1 = *ebx;
        
        if (edi_1 != 0)
        {
            sub_10032890(&arg1, 0);
            int32_t eax_1 = *(edi_1 + 4);
            
            if ((eax_1 > 0 && eax_1 < 0xffffffff))
                *(edi_1 + 4) = (eax_1 - 1);
            
            int32_t esi_1 = *(edi_1 + 4);
            int32_t esi_2 = -(esi_1);
            void* esi_5 = (!((esi_2 - esi_2)) & edi_1);
            sub_100328d0(&arg1);
            
            if (esi_5 != 0)
            {
                **esi_5(0);
                __mktime32(esi_5);
            }
        }
        
        __mktime32(ebx);
    }
}

int32_t __fastcall sub_10008330(int32_t* arg1)
{
    int32_t var_4_2 = 0xffffffff;
    int32_t (* var_8)(void* arg1) = sub_10034df8;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_edi;
    int32_t var_34 = (__security_cookie ^ &__saved_edi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void var_1c;
    sub_10032890(&var_1c, 0);
    int32_t var_4 = 0;
    bool cond:0 = data_10049234 != 0;
    int32_t result_3 = data_1004922c;
    int32_t result_1 = result_3;
    void var_20;
    
    if (!(cond:0))
    {
        sub_10032890(&var_20, 0);
        
        if (data_10049234 == 0)
        {
            int32_t eax_4 = (data_10046188 + 1);
            data_10046188 = eax_4;
            data_10049234 = eax_4;
        }
        
        sub_100328d0(&var_20);
    }
    
    int32_t esi = data_10049234;
    void* eax_5 = *arg1;
    int32_t result_2;
    
    if (esi >= *(eax_5 + 0xc))
    {
        result_2 = 0;
        
        if (*(eax_5 + 0x14) == 0)
            goto label_100083de;
        
        goto label_100083c8;
    }
    
    result_2 = *(*(eax_5 + 8) + (esi << 2));
    int32_t result;
    
    if ((result_2 != 0 || *(eax_5 + 0x14) == 0))
    {
    label_100083de:
        result = result_2;
    label_100083e0:
        
        if (result == 0)
            goto label_100083e4;
    }
    else
    {
    label_100083c8:
        void* eax_6 = __CrtGetAllocHook();
        
        if (esi < *(eax_6 + 0xc))
        {
            result = *(*(eax_6 + 8) + (esi << 2));
            goto label_100083e0;
        }
        
    label_100083e4:
        
        if (result_3 == 0)
        {
            sub_10008530(&result_1, arg1);
            result = result_1;
            data_1004922c = result;
            sub_10032890(&var_20, 0);
            int32_t eax_7 = *(result + 4);
            
            if (eax_7 < 0xffffffff)
                *(result + 4) = (eax_7 + 1);
            
            sub_100328d0(&var_20);
            sub_100329b0(result);
        }
        else
            result = result_3;
    }
    
    int32_t var_4_1 = 0xffffffff;
    sub_100328d0(&var_1c);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

void* __stdcall sub_10008480(int32_t* arg1 @ eax, int32_t arg2)
{
    void* ebx;
    
    if (ebx == 0)
    {
        if (sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x75e, ebx, u"AtlIsValidString( pszFormat )") != 1)
        {
            sub_100010a0(0x80070057);
            /* no return */
        }
        
        breakpoint();
    }
    
    int32_t eax_1 = _vprintf(ebx, arg2);
    void* eax_2 = *arg1;
    int32_t edx_1 = (*(eax_2 - 8) - eax_1);
    
    if (((1 - *(eax_2 - 4)) | edx_1) < 0)
        sub_10007c20(arg1, edx_1, eax_1);
    
    sub_1000bc20(*arg1, (eax_1 + 1), ebx, arg2);
    
    if ((eax_1 < 0 && sub_1000b040(2, u"E:\Program Files\Microsoft Visua…", 0x246, nullptr, u"nNewLength >= 0") == 1))
        breakpoint();
    
    return sub_10007730(eax_1, arg1);
}

int32_t sub_10008530(int32_t* arg1 @ edi, int32_t* arg2)
{
    int32_t var_c = 0xffffffff;
    int32_t (* var_10)(void* arg1) = sub_10034dc3;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_esi;
    int32_t var_d4 = (__security_cookie ^ &__saved_esi);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t ebx = 0;
    int32_t var_c8 = 0;
    
    if ((arg1 != 0 && *arg1 == 0))
    {
        int32_t var_a0_1 = 0x100401e0;
        int32_t* esi_1 = sub_10033b20(8, &data_100401e0, "E:\Program Files\Microsoft Visua…", 0x311);
        int32_t* var_a4_1 = esi_1;
        int32_t var_c_1 = 0;
        int32_t* i_1;
        void var_9c;
        
        if (esi_1 == 0)
            esi_1 = nullptr;
        else
        {
            int32_t* var_d8_1 = &i_1;
            int32_t* eax_4 = sub_100016d0(arg2);
            var_c_1 = 1;
            var_c8 = 1;
            sub_10001380(&var_9c, eax_4);
            ebx = 3;
            esi_1[1] = 0;
            *esi_1 = 0x10040fc4;
        }
        
        int32_t var_c_2 = 2;
        *arg1 = esi_1;
        
        if ((ebx & 2) != 0)
        {
            ebx &= 0xfffffffd;
            var_c8 = ebx;
            sub_10001420(&var_9c);
        }
        
        int32_t var_c_3 = 0xffffffff;
        
        if ((ebx & 1) != 0)
        {
            int32_t var_a8;
            char var_bc;
            
            if (var_a8 >= 0x10)
                sub_1000ab80(var_bc);
            int32_t var_a8_1 = 0xf;
            int32_t var_ac_1 = 0;
            char var_bc_1 = 0;
            sub_10032890(&var_c8, 3);
            int32_t* i = i_1;
            
            if (i != 0xfffffffd)
            {
                while (i != 0)
                {
                    *i = 0;
                    i = i_1[1];
                    i_1 = i;
                }
                
                i_1 = nullptr;
            }
            
            sub_100328d0(&var_c8);
        }
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return 2;
}

int32_t* __fastcall sub_100086a0(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    sub_100086f0(arg1);
    arg1[6] = 0;
    arg1[7] = 0;
    arg1[8] = 0;
    arg1[9] = 0;
    arg1[0xa] = 0;
    return arg1;
}

int32_t* __fastcall sub_100086f0(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<uint8_t> > > >::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<uint8_t> > > >(arg1);
    std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<uint8_t> > > >::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<uint8_t> > > >(&arg1[3]);
    return arg1;
}

int32_t* __fastcall std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<uint8_t> > > >::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<uint8_t> > > >(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    *arg1 = 0;
    arg1[1] = 0;
    arg1[2] = 0;
    return arg1;
}

int32_t sub_10008750()
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    int32_t eax_3 = *sub_1000eca0();
    *sub_1000eca0() = 0;
    uint32_t var_12c_1 = GetCurrentProcessId();
    char const (* var_130_1)[0x29] = data_10044004;
    void var_114;
    int32_t eax_6 = __snwprintf_s(&var_114, 0x104, 0x103, data_10044008);
    
    if (*sub_1000eca0() == 0)
        *sub_1000eca0() = eax_3;
    else
        sub_10008870(*sub_1000eca0());
    
    if ((eax_6 == 0xffffffff || eax_6 >= 0x104))
    {
        void var_120;
        int32_t var_11c = *sub_10001090(&var_120, 0x80004005);
        sub_1000ed00(&var_11c, &data_100426a4);
        /* no return */
    }
    
    if (_dup2_internal(&data_10045520, &var_114, 0x400000) != 0)
        return sub_1000ac70((eax_1 ^ &__saved_ebp));
    
    void var_128;
    int32_t var_124 = *sub_10001090(&var_128, 0x8007000e);
    sub_1000ed00(&var_124, &data_100426a4);
    /* no return */
}

void* sub_10008870(void* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    switch (arg1)
    {
        case nullptr:
        case 0x50:
        {
            return arg1;
            break;
        }
        case 0xc:
        {
            sub_100010a0(0x8007000e);
            /* no return */
        }
        case 0x16:
        case 0x22:
        {
            sub_100010a0(0x80070057);
            /* no return */
        }
    }
    
    sub_100010a0(0x80004005);
    /* no return */
}

int32_t* __thiscall sub_10008930(int32_t* arg1, int32_t (* arg2)(int32_t arg1, PSTR arg2, int32_t arg3, void* arg4, int32_t arg5))
{
    int32_t* var_8 = arg1;
    *arg1 = 0x10000000;
    arg1[1] = 0;
    arg1[1] = sub_10008aa0(*arg1, arg2);
    return arg1;
}

int32_t* __fastcall sub_10008970(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    sub_10009fa0(arg1, 0);
    return sub_10008990(arg1);
}

int32_t* __fastcall sub_10008990(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    __crt_unique_heap_ptr<struct __crt_lc_time_data,struct __crt_internal_free_policy>(&arg1[3]);
    return __crt_unique_heap_ptr<struct __crt_lc_time_data,struct __crt_internal_free_policy>(arg1);
}

int32_t* __fastcall __crt_unique_heap_ptr<struct __crt_lc_time_data,struct __crt_internal_free_policy>(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    return sub_100089d0(arg1);
}

int32_t* __fastcall sub_100089d0(int32_t* arg1)
{
    int32_t* result = arg1;
    
    if (*result != 0)
    {
        for (int32_t i = 0; i < arg1[1]; i += 1)
        {
        }
        
        __mktime32(*arg1);
        result = arg1;
        *result = 0;
    }
    
    arg1[1] = 0;
    arg1[2] = 0;
    return result;
}

int32_t __fastcall sub_10008a40(void* arg1)
{
    void* var_8 = arg1;
    sub_10008b20(*(arg1 + 4));
    return 1;
}

HANDLE sub_10008a60()
{
    int32_t ecx;
    int32_t var_8 = ecx;
    HANDLE result = OpenEventA(EVENT_MODIFY_STATE, 0, data_10044000);
    
    if (result == 0)
        return result;
    
    SetEvent(result);
    return CloseHandle(result);
}

int32_t __stdcall sub_10008aa0(HMODULE arg1, int32_t (* arg2)(int32_t arg1, PSTR arg2, int32_t arg3, void* arg4, int32_t arg5))
{
    int32_t eax_1 = sub_1000a1d0(&data_10045520, arg1);
    void* eax_2 = sub_1000a040(&data_10045520, eax_1);
    
    if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x2b, nullptr, u"pModule != 0") == 1))
        breakpoint();
    
    if (eax_2 != 0)
    {
        sub_1000aa50(eax_2, arg2);
        sub_10008a60();
    }
    
    return (eax_1 + 1);
}

int32_t __stdcall sub_10008b20(int32_t arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    sub_1000a700(&data_10045520, (arg1 - 1));
    sub_10008a60();
    return 1;
}

int32_t __stdcall sub_10008b50(int32_t arg1, PSTR arg2)
{
    if (arg2 == 0)
        return 0;
    
    void var_10c;
    int32_t result = sub_10008ba0(arg1, std::_Ptr_base<class __ExceptionPtr>::_Get(sub_100091f0(&var_10c, arg2)));
    sub_10009220(&var_10c);
    return result;
}

int32_t __stdcall sub_10008ba0(int32_t arg1, int16_t* arg2)
{
    if (arg2 == 0)
        return 0;
    
    int32_t eax_3 = sub_1000a440(&data_10045520, (arg1 - 1), arg2);
    sub_10008a60();
    return (eax_3 + 1);
}

int32_t __fastcall Concurrency::details::ExecutionResource::GetVirtualProcessorRoot(void* arg1)
{
    void* var_8 = arg1;
    return *(arg1 + 0x1c);
}

int32_t __stdcall sub_10008c10(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    void* var_c = arg1;
    
    if (var_c == 0)
        var_c = &data_10045520;
    
    int32_t* eax_1 = sub_1000a0f0(var_c, (arg2 - 1));
    
    if (eax_1 != 0)
    {
        if (arg4 == 0)
            eax_1[1] = 0;
        else if (arg4 == 1)
            eax_1[1] = 1;
        else if (arg4 == 2)
            eax_1[1] = 2;
        else if (sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0xae, nullptr, u"false") == 1)
            breakpoint();
        
        *eax_1 = arg3;
    }
    
    return 1;
}

int32_t __fastcall __crt_cached_ptd_host::get_errno(int32_t arg1) __pure
{
    int32_t var_8 = arg1;
    return (arg1 + 0x18);
}

int32_t sub_10008ce0(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, void* arg5, int32_t arg6, int32_t arg7)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    int32_t var_8 = 0;
    int16_t lpOutputString = 0;
    void var_812;
    sub_1000fae0(&var_812, 0, 0x7fe);
    int32_t var_81c = 0;
    int32_t var_c;
    
    if (sub_10009030(arg1, arg4, arg5, &var_c, &var_8) != 0)
    {
        int32_t var_824;
        int32_t var_820;
        
        if (*(Concurrency::details::ExecutionResource::GetVirtualProcessorRoot(&data_10045520) + 0x42b) != 0)
        {
            var_824 = *sub_1000eca0();
            *sub_1000eca0() = 0;
            int32_t var_834_1 = arg3;
            int32_t var_838_1 = arg2;
            var_820 = sub_1000fb60(&&__saved_ebp[-0x204], 0x400, 0x3ff, u"%S(%d) : ");
            
            if (*sub_1000eca0() == 0)
                *sub_1000eca0() = var_824;
            else
                sub_10008870(*sub_1000eca0());
            
            if (var_820 >= 0)
                var_81c = var_820;
            else
                var_81c = 0x400;
        }
        
        int32_t var_82c;
        int32_t var_828;
        
        if (((var_81c >= 0 && (var_81c < 0x400 && var_c != 0)) && *(Concurrency::details::ExecutionResource::GetVirtualProcessorRoot(&data_10045520) + 0x42a) != 0))
        {
            var_82c = *sub_1000eca0();
            *sub_1000eca0() = 0;
            int32_t var_834_3 = __crt_cached_ptd_host::get_errno(var_c);
            var_828 = sub_1000fb60(((&__saved_ebp + (var_81c << 1)) - 0x810), (0x400 - var_81c), ((0x400 - var_81c) - 1), u"%s: ");
            
            if (*sub_1000eca0() == 0)
                *sub_1000eca0() = var_82c;
            else
                sub_10008870(*sub_1000eca0());
            
            if (var_828 >= 0)
                var_81c += var_828;
            else
                var_81c = 0x400;
        }
        
        int32_t var_830;
        
        if ((var_81c >= 0 && var_81c < 0x400))
        {
            var_830 = *sub_1000eca0();
            *sub_1000eca0() = 0;
            __vsnwprintf_s(((&__saved_ebp + (var_81c << 1)) - 0x810), (0x400 - var_81c), ((0x400 - var_81c) - 1), arg6, arg7);
            
            if (*sub_1000eca0() == 0)
                *sub_1000eca0() = var_830;
            else
                sub_10008870(*sub_1000eca0());
        }
        
        if (var_8 == 0)
            OutputDebugStringW(&lpOutputString);
        else
            var_8(0, 0, 0, 0, &data_100363c8, &lpOutputString, var_830, var_82c, var_828, var_824, var_820, var_81c, 0x400);
    }
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

void* __stdcall sub_10009030(int32_t arg1, int32_t arg2, void* arg3, int32_t* arg4, int32_t* arg5)
{
    char var_d = 0;
    
    if (((arg4 == 0 || arg5 == 0) && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x242, nullptr, u"ppCategory && pfnCrtDbgReport") == 1))
        breakpoint();
    
    *arg4 = 0;
    *arg5 = 0;
    void* eax_2 = Concurrency::details::ExecutionResource::GetVirtualProcessorRoot(&data_10045520);
    
    if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x247, nullptr, u"pProcess") == 1))
        breakpoint();
    
    void* var_8 = sub_1000a040(&data_10045520, (arg1 - 1));
    
    if ((var_8 == 0 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x24a, nullptr, u"pModule != 0") == 1))
        breakpoint();
    
    void* result;
    
    if (var_8 == 0)
        result = 0;
    else
    {
        *arg5 = sub_100091d0(var_8);
        int32_t* var_14_1 = sub_1000a0f0(&data_10045520, (arg2 - 1));
        
        if (var_14_1 == 0)
            result = 0;
        else
        {
            char var_d_1 = 1;
            char var_15_1 = 0;
            
            if ((((*(eax_2 + 0x429) != 0 && *(var_8 + 0x418) == 0) && *(var_14_1 + 4) == 0) && arg3 <= *(eax_2 + 0x424)))
                var_15_1 = 1;
            else if (((*(var_8 + 0x418) == 1 && var_14_1[1] == 0) && arg3 <= *(var_8 + 0x414)))
                var_15_1 = 1;
            else if ((var_14_1[1] == 1 && arg3 <= *var_14_1))
                var_15_1 = 1;
            
            if (var_15_1 == 0)
                result = 0;
            else
            {
                uint32_t eax_6 = *(eax_2 + 0x42a);
                int32_t eax_7 = -(eax_6);
                *arg4 = ((eax_7 - eax_7) & var_14_1);
                result = 1;
            }
        }
    }
    
    return result;
}

int32_t __fastcall sub_100091d0(void* arg1)
{
    void* var_8 = arg1;
    return *(arg1 + 0x424);
}

int32_t* __thiscall sub_100091f0(int32_t* arg1, PSTR arg2)
{
    int32_t* var_8 = arg1;
    *arg1 = &arg1[1];
    sub_10009270(arg1, arg2, 3);
    return arg1;
}

char* __fastcall sub_10009220(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    return sub_100093e0(*arg1, &arg1[1], 0x80);
}

int32_t __fastcall std::_Ptr_base<class __ExceptionPtr>::_Get(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    return *arg1;
}

int32_t* __thiscall sub_10009270(int32_t* arg1, PSTR arg2, uint32_t arg3)
{
    int32_t* result;
    
    if (arg2 != 0)
    {
        int32_t eax_1 = (lstrlenA(arg2) + 1);
        sub_10009420(arg1, eax_1, &arg1[1], 0x80);
        int32_t eax_6 = MultiByteToWideChar(arg3, 0, arg2, eax_1, *arg1, eax_1);
        int32_t eax_7 = -(eax_6);
        int32_t eax_8 = (eax_7 - eax_7);
        result = (eax_8 + 1);
        int32_t* result_1 = result;
        
        if (eax_8 != 0xffffffff)
        {
            result = GetLastError();
            
            if (result == 0x7a)
            {
                int32_t cchWideChar = MultiByteToWideChar(arg3, 0, arg2, eax_1, nullptr, 0);
                sub_10009420(arg1, cchWideChar, &arg1[1], 0x80);
                int32_t eax_14 = MultiByteToWideChar(arg3, 0, arg2, eax_1, *arg1, cchWideChar);
                int32_t eax_15 = -(eax_14);
                result = ((eax_15 - eax_15) + 1);
                result_1 = result;
            }
        }
        
        if (result_1 != 0)
        {
            sub_10009370();
            /* no return */
        }
    }
    else
    {
        result = arg1;
        *result = 0;
    }
    
    return result;
}

void sub_10009370() __noreturn
{
    sub_100010a0(_HRESULT_FROM_WIN32(GetLastError()));
    /* no return */
}

int32_t sub_10009391(int32_t* arg1 @ ebp)
{
    *arg1;
}

int32_t _HRESULT_FROM_WIN32(int32_t arg1) __pure
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if (arg1 > 0)
        return ((arg1 | 0x70000) | 0x80000000);
    
    return arg1;
}

char* sub_100093e0(int32_t arg1, char* arg2, int32_t arg3)
{
    if (arg1 == arg2)
        return sub_1000fae0(arg2, 0xfe, (arg3 << 1));
    
    return __mktime32(arg1);
}

int32_t* sub_10009420(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    int32_t eax_1;
    eax_1 = arg1 != 0;
    
    if ((eax_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x72, nullptr, u"__atl_condVal") == 1))
        breakpoint();
    
    if (eax_1 == 0)
    {
        sub_100010a0(0x80070057);
        /* no return */
    }
    
    int32_t eax_3;
    eax_3 = arg2 >= 0;
    
    if ((eax_3 == 0 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x73, nullptr, u"__atl_condVal") == 1))
        breakpoint();
    
    if (eax_3 == 0)
    {
        sub_100010a0(0x80070057);
        /* no return */
    }
    
    int32_t eax_5;
    eax_5 = arg3 != 0;
    
    if ((eax_5 == 0 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x74, nullptr, u"__atl_condVal") == 1))
        breakpoint();
    
    if (eax_5 == 0)
    {
        sub_100010a0(0x80070057);
        /* no return */
    }
    
    int32_t* result;
    
    if (*arg1 == arg3)
    {
        if (arg2 <= arg4)
        {
            result = arg1;
            *result = arg3;
        }
        else
        {
            result = sub_10010560(arg2, 2);
            *arg1 = result;
        }
    }
    else if (arg2 <= arg4)
    {
        result = __mktime32(*arg1);
        *arg1 = arg3;
    }
    else
    {
        void* eax_9 = sub_10010b70(*arg1, arg2, 2);
        
        if (eax_9 == 0)
        {
            sub_100010a0(0x8007000e);
            /* no return */
        }
        
        result = arg1;
        *result = eax_9;
    }
    
    if (*arg1 != 0)
        return result;
    
    sub_100010a0(0x8007000e);
    /* no return */
}

int32_t* __thiscall sub_10009590(int32_t* arg1, PSTR arg2, int32_t arg3)
{
    int32_t* var_8 = arg1;
    *arg1 = 0;
    *arg1 = sub_10009610(&data_10045554, arg2);
    sub_100095e0(*arg1, arg3, 0);
    return arg1;
}

int32_t __stdcall sub_100095e0(int32_t arg1, int32_t arg2, int32_t arg3)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t var_8_1 = ecx;
    sub_10008c10(nullptr, arg1, arg2, arg3);
    return -((0xffffffff + 1));
}

int32_t __thiscall sub_10009610(void* arg1, PSTR arg2)
{
    void* var_8 = arg1;
    return sub_10008b50(*(arg1 + 4), arg2);
}

int32_t* __thiscall sub_10009630(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    *arg1 = 0x100366f0;
    arg1[1] = arg2;
    arg1[2] = 0;
    
    if ((arg2 == 0 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x52, nullptr, u"hHeap != 0") == 1))
        breakpoint();
    
    return arg1;
}

int32_t __thiscall sub_10009680(void* arg1, uint32_t arg2)
{
    void* var_8 = arg1;
    return HeapAlloc(*(arg1 + 4), HEAP_NONE, arg2);
}

void __thiscall sub_100096b0(void* arg1, int32_t arg2)
{
    if (((arg2 != 0 && HeapFree(*(arg1 + 4), HEAP_NONE, arg2) == 0) && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x89, nullptr, u"bSuccess") == 1))
        breakpoint();
}

int32_t __thiscall sub_10009710(int32_t* arg1, int32_t arg2, uint32_t arg3)
{
    int32_t* var_8 = arg1;
    
    if (arg2 == 0)
        return **arg1(arg3);
    
    if (arg3 != 0)
        return HeapReAlloc(arg1[1], HEAP_NONE, arg2, arg3);
    
    *(*arg1 + 4)(arg2);
    return 0;
}

uint32_t __thiscall sub_10009770(void* arg1, int32_t arg2)
{
    void* var_8 = arg1;
    return HeapSize(*(arg1 + 4), HEAP_NONE, arg2);
}

int32_t* __thiscall sub_100097a0(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    sub_100097d0(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80(arg1);
    
    return arg1;
}

int32_t* __fastcall sub_100097d0(int32_t* arg1)
{
    int32_t* result = arg1;
    *result = 0x100366f0;
    
    if (arg1[2] != 0)
    {
        result = arg1;
        
        if (result[1] != 0)
        {
            result = HeapDestroy(arg1[1]);
            
            if (result == 0)
            {
                result = sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x66, nullptr, u"bSuccess");
                
                if (result == 1)
                    breakpoint();
            }
        }
    }
    
    return result;
}

int32_t* __thiscall sub_10009830(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    *arg1 = 0x10036718;
    arg1[1] = arg2;
    sub_10009870(&arg1[2]);
    sub_100098c0(&arg1[2], arg1);
    return arg1;
}

int32_t* __fastcall sub_10009870(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    *arg1 = 0;
    arg1[3] = 2;
    arg1[1] = 0;
    arg1[2] = 0;
    arg1[4] = 0;
    *(arg1 + 0x12) = 0;
    return arg1;
}

int32_t __thiscall sub_100098c0(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    
    if ((*arg1 != 0 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x91, nullptr, u"pStringMgr == 0") == 1))
        breakpoint();
    
    *arg1 = arg2;
    return arg2;
}

void** __thiscall sub_10009900(void* arg1, int32_t arg2, int32_t arg3)
{
    int32_t eax_2 = sub_10009c00((arg2 + 1), 8);
    int32_t var_10;
    int32_t var_c;
    
    if ((sub_10009ac0(&var_10, eax_2, arg3) >= 0 && sub_10009bd0(&var_c, 0x10, var_10) >= 0))
    {
        *(arg1 + 4);
        void** result = ***(arg1 + 4)(var_c);
        
        if (result == 0)
            return nullptr;
        
        *result = arg1;
        result[3] = 1;
        result[2] = (eax_2 - 1);
        result[1] = 0;
        return result;
    }
    
    return nullptr;
}

int32_t __thiscall sub_100099b0(void* arg1, int32_t* arg2)
{
    void* var_8 = arg1;
    
    if ((*arg2 != arg1 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x51, nullptr, u"pData->pStringMgr == this") == 1))
        breakpoint();
    
    *(arg1 + 4);
    return *(**(arg1 + 4) + 4)(arg2, arg1);
}

void* __thiscall sub_10009a00(void* arg1, int32_t* arg2, int32_t arg3, int32_t arg4)
{
    if ((*arg2 != arg1 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x5a, nullptr, u"pData->pStringMgr == this") == 1))
        breakpoint();
    
    int32_t eax_4 = sub_10009c00((arg3 + 1), 8);
    int32_t var_c;
    int32_t var_8;
    
    if ((sub_10009ac0(&var_c, eax_4, arg4) >= 0 && sub_10009bd0(&var_8, 0x10, var_c) >= 0))
    {
        *(arg1 + 4);
        void* result = *(**(arg1 + 4) + 8)(arg2, var_8);
        
        if (result == 0)
            return nullptr;
        
        *(result + 8) = (eax_4 - 1);
        return result;
    }
    
    return nullptr;
}

int32_t sub_10009ac0(int32_t* arg1, int32_t arg2, int32_t arg3)
{
    int32_t eax_1;
    int32_t edx;
    edx = HIGHD((arg2 * arg3));
    eax_1 = LOWD((arg2 * arg3));
    
    if ((edx > 0 || eax_1 > 0xffffffff))
        return 0x80070057;
    
    *arg1 = eax_1;
    return 0;
}

void* __fastcall sub_10009b00(void* arg1)
{
    void* var_8 = arg1;
    sub_10009b20((arg1 + 8));
    return (arg1 + 8);
}

int32_t __fastcall sub_10009b20(void* arg1)
{
    void* var_8 = arg1;
    
    if ((*(arg1 + 0xc) <= 0 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x55, nullptr, u"nRefs > 0") == 1))
        breakpoint();
    
    int32_t result = *(arg1 + 0xc);
    *(arg1 + 0xc) += 1;
    return result;
}

int32_t __fastcall _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(int32_t arg1) __pure
{
    int32_t var_8 = arg1;
    return arg1;
}

int32_t* __thiscall sub_10009b80(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    std::_Func_base<void,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil>::~_Func_base<void,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil>(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80(arg1);
    
    return arg1;
}

int32_t* __fastcall std::_Func_base<void,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil>::~_Func_base<void,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil>(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    *arg1 = 0x10036718;
    return arg1;
}

int32_t sub_10009bd0(int32_t* arg1, int32_t arg2, int32_t arg3)
{
    if ((0xffffffff - arg2) < arg3)
        return 0x80070057;
    
    *arg1 = (arg2 + arg3);
    return 0;
}

int32_t __stdcall sub_10009c00(int32_t arg1, int32_t arg2) __pure
{
    return (((arg1 + arg2) - 1) & !((arg2 - 1)));
}

int32_t __thiscall _dup2_internal(void* arg1, PSTR arg2, uint32_t arg3)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041990;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_6c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_70 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    sub_10009fa0(arg1, 0);
    
    if (((*(arg1 + 0x24) != 0 || *(arg1 + 0x2c) != 0) && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x1a, nullptr, u"!m_hMap && !m_pBufferStart") == 1))
        breakpoint();
    
    HANDLE var_20 = nullptr;
    int32_t var_8_1 = 0;
    
    if ((OpenThreadToken(GetCurrentThread(), 0x6, 1, &var_20) == 0 || var_20 == 0))
    {
    label_10009cfd:
        *(arg1 + 0x24) = CreateFileMappingA(0xffffffff, nullptr, 0x4000004, 0, arg3, arg2);
        
        if (*(arg1 + 0x24) != 0)
        {
            enum WIN32_ERROR eax_9 = GetLastError();
            *(arg1 + 0x2c) = MapViewOfFile(*(arg1 + 0x24), FILE_MAP_ALL_ACCESS, 0, 0, 0);
            
            if (*(arg1 + 0x2c) != 0)
            {
                void lpSystemInfo;
                GetSystemInfo(&lpSystemInfo);
                uint32_t dwSize_1;
                
                if (eax_9 != ERROR_ALREADY_EXISTS)
                {
                    uint32_t dwSize;
                    
                    for (dwSize = dwSize_1; dwSize < 0x448; dwSize += dwSize_1)
                    {
                    }
                    
                    if (VirtualAlloc(*(arg1 + 0x2c), dwSize, MEM_COMMIT, PAGE_READWRITE) != 0)
                    {
                        int32_t var_74_6 = *(arg1 + 0x2c);
                        int32_t* eax_26 = Platform::Details::Heap::Allocate(0x448);
                        int32_t* var_60_1;
                        
                        if (eax_26 == 0)
                            var_60_1 = nullptr;
                        else
                            var_60_1 = sub_1000aa90(eax_26, arg3);
                        
                        *(arg1 + 0x1c) = var_60_1;
                        *(*(arg1 + 0x1c) + 0x414) = dwSize;
                        *(*(arg1 + 0x1c) + 0x41c) = 0x448;
                        *(arg1 + 0x20) = dwSize_1;
                        *(arg1 + 0x28) = 1;
                    }
                }
                else
                {
                    *(arg1 + 0x1c) = *(arg1 + 0x2c);
                    
                    if ((*(arg1 + 0x1c) != 0 && sub_10009f80(*(arg1 + 0x1c)) != 0))
                    {
                        int32_t eax_16 = *(*(arg1 + 0x1c) + 0x414);
                        char* eax_17 = sub_10009f80(*(arg1 + 0x1c));
                        
                        if (sub_10012a20(*(arg1 + 0x2c), eax_17, eax_16) == 0)
                        {
                            sub_10009f50(*(arg1 + 0x1c));
                            *(arg1 + 0x1c) = sub_10009f80(*(arg1 + 0x1c));
                            UnmapViewOfFile(*(arg1 + 0x2c));
                            *(arg1 + 0x2c) = *(arg1 + 0x1c);
                            *(arg1 + 0x20) = dwSize_1;
                            *(arg1 + 0x28) = 1;
                        }
                    }
                }
            }
        }
    }
    else
    {
        if (RevertToSelf() != 0)
            goto label_10009cfd;
        
        CloseHandle(var_20);
        var_20 = nullptr;
    }
    
    int32_t var_8_2 = 0xfffffffe;
    sub_10009e9f(&__saved_ebp);
    int32_t result;
    result = *(arg1 + 0x28);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

void sub_10009e9f(void* arg1 @ ebp)
{
    if (*(arg1 - 0x1c) != 0)
    {
        *(arg1 - 0x50) = SetThreadToken(nullptr, *(arg1 - 0x1c));
        
        if ((*(arg1 - 0x50) == 0 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x72, nullptr, u"bSuccess") == 1))
            breakpoint();
        
        CloseHandle(*(arg1 - 0x1c));
    }
    
    if (*(*(arg1 - 0x58) + 0x28) == 0)
    {
        if (*(*(arg1 - 0x58) + 0x2c) != 0)
        {
            UnmapViewOfFile(*(*(arg1 - 0x58) + 0x2c));
            *(*(arg1 - 0x58) + 0x2c) = 0;
        }
        
        if (*(*(arg1 - 0x58) + 0x24) != 0)
        {
            CloseHandle(*(*(arg1 - 0x58) + 0x24));
            *(*(arg1 - 0x58) + 0x24) = 0;
        }
    }
}

int32_t __fastcall sub_10009f50(void* arg1)
{
    void* var_8 = arg1;
    *(arg1 + 0x434) += 1;
    return *(arg1 + 0x434);
}

int32_t __fastcall sub_10009f80(void* arg1)
{
    void* var_8 = arg1;
    return *(arg1 + 0x438);
}

void* __thiscall sub_10009fa0(void* arg1, char arg2)
{
    void* var_8 = arg1;
    void* result = arg1;
    
    if (*(result + 0x28) != 0)
    {
        if ((sub_1000a010(*(arg1 + 0x1c)) == 0 || arg2 != 0))
            UnmapViewOfFile(*(arg1 + 0x2c));
        
        *(arg1 + 0x2c) = 0;
        CloseHandle(*(arg1 + 0x24));
        result = arg1;
        *(result + 0x24) = 0;
        *(arg1 + 0x28) = 0;
    }
    
    return result;
}

int32_t __fastcall sub_1000a010(void* arg1)
{
    void* var_8 = arg1;
    *(arg1 + 0x434) -= 1;
    return *(arg1 + 0x434);
}

int32_t __thiscall sub_1000a040(void* arg1, int32_t arg2)
{
    if (arg2 == 0xffffffff)
        return 0;
    
    int32_t eax_2 = sub_1000a0d0(*(arg1 + 0x1c));
    
    if ((arg2 >= eax_2 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0xcb, nullptr, u"iModule < modcnt") == 1))
        breakpoint();
    
    if ((arg2 >= 0 && arg2 < eax_2))
        return ((arg2 * 0x428) + (*(arg1 + 0x1c) + 0x448));
    
    return 0;
}

int32_t __fastcall sub_1000a0d0(void* arg1)
{
    void* var_8 = arg1;
    return *(arg1 + 0x43c);
}

int32_t __thiscall sub_1000a0f0(void* arg1, int32_t arg2)
{
    if (arg2 == sub_1000a1b0(*(arg1 + 0x1c)))
        return 0;
    
    if (((arg2 >= sub_1000a1b0(*(arg1 + 0x1c)) && arg2 != 0xffffffff) && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0xff, nullptr, u"(iCategory < m_pProcess->Categor…") == 1))
        breakpoint();
    
    if (arg2 < 0)
        return 0;
    
    return (((sub_1000a190(*(arg1 + 0x1c)) + *(arg1 + 0x1c)) - (arg2 * 0x98)) - 0x98);
}

int32_t __fastcall sub_1000a190(void* arg1)
{
    void* var_8 = arg1;
    return *(arg1 + 0x430);
}

int32_t __fastcall sub_1000a1b0(void* arg1)
{
    void* var_8 = arg1;
    return *(arg1 + 0x440);
}

int32_t __thiscall sub_1000a1d0(void* arg1, HMODULE arg2)
{
    void* eax = Concurrency::details::ExecutionResource::GetVirtualProcessorRoot(arg1);
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x13d, nullptr, u"pProcess") == 1))
        breakpoint();
    
    int32_t i = 0xffffffff;
    
    while (i == 0xffffffff)
    {
        for (int32_t j = 0; j < sub_1000a0d0(eax); j += 1)
        {
            if (i != 0xffffffff)
                break;
            
            int32_t* eax_3 = sub_1000a040(arg1, j);
            
            if ((eax_3 == 0 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x144, nullptr, u"pModule != 0") == 1))
                breakpoint();
            
            if (sub_1000a390(&eax_3[0x105]) != 0)
            {
                sub_1000a800(eax_3, arg2);
                *eax_3 = 0xffffffff;
                sub_1000a3d0(&eax_3[0x105], sub_1000ab60(eax));
                i = j;
            }
        }
        
        if (i == 0xffffffff)
        {
            void* lpAddress = (eax + *(eax + 0x414));
            VirtualAlloc(lpAddress, 0x2990, MEM_COMMIT, PAGE_READWRITE);
            *(eax + 0x414) += 0x2990;
            
            for (int32_t j_1 = 0; j_1 < 0xa; j_1 += 1)
            {
                void* var_38_4 = ((j_1 * 0x428) + lpAddress);
                int32_t* eax_12 = Platform::Details::Heap::Allocate(0x428);
                
                if (eax_12 == 0)
                    int32_t var_34_2 = 0;
                else
                    int32_t* var_34_1 = sub_1000aa10(eax_12);
            }
            
            sub_1000a410(eax, 0xa);
        }
    }
    
    return i;
}

int32_t __fastcall sub_1000a390(int32_t arg1)
{
    int32_t result;
    
    if (*(arg1 + 0xc) == 0)
    {
        if (InterlockedIncrement((arg1 + 8)) != 1)
            result = 0;
        else
            result = 1;
    }
    else
        result = 0;
    
    return result;
}

void __thiscall sub_1000a3d0(void* arg1, int32_t arg2)
{
    void* var_8 = arg1;
    
    if ((arg2 == 0 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x54, nullptr, u"nCookie != 0") == 1))
        breakpoint();
    
    *(arg1 + 0xc) = arg2;
}

void* __thiscall sub_1000a410(void* arg1, int32_t arg2)
{
    void* var_8 = arg1;
    *(arg1 + 0x43c) += arg2;
    return arg1;
}

int32_t __thiscall sub_1000a440(void* arg1, int32_t arg2, int16_t* arg3)
{
    int32_t i = 0xffffffff;
    void* eax = Concurrency::details::ExecutionResource::GetVirtualProcessorRoot(arg1);
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x166, nullptr, u"pProcess") == 1))
        breakpoint();
    
    int32_t* eax_2 = sub_1000a040(arg1, arg2);
    
    if (eax_2 != 0)
    {
        sub_1000a660(&eax_2[0x105]);
        
        while (i == 0xffffffff)
        {
            for (int32_t j = 0; j < sub_1000a1b0(eax); j += 1)
            {
                if (i != 0xffffffff)
                    break;
                
                int32_t eax_5 = sub_1000a0f0(arg1, j);
                
                if ((eax_5 == 0 && sub_1000b040(2, u"f:\dd\vctools\vc7libs\ship\atlmf…", 0x171, nullptr, u"pCategory != 0") == 1))
                    breakpoint();
                
                if (sub_1000a390(eax_5) != 0)
                {
                    sub_1000a9c0(eax_5, arg3, eax_2[0x108]);
                    *(eax_5 + 0x14) = *eax_2;
                    sub_1000a3d0(eax_5, sub_1000ab60(eax));
                    *eax_2 = j;
                    InterlockedIncrement(&eax_2[1]);
                    i = j;
                }
            }
            
            if (i == 0xffffffff)
            {
                void* lpAddress = (((sub_1000a190(eax) + eax) - *(eax + 0x418)) - 0x5f0);
                VirtualAlloc(lpAddress, 0x5f0, MEM_COMMIT, PAGE_READWRITE);
                *(eax + 0x418) += 0x5f0;
                
                for (int32_t j_1 = 0; j_1 < 0xa; j_1 += 1)
                {
                    void* var_3c_5 = ((j_1 * 0x98) + lpAddress);
                    int32_t* eax_19 = Platform::Details::Heap::Allocate(0x98);
                    
                    if (eax_19 == 0)
                        int32_t var_38_2 = 0;
                    else
                        int32_t* var_38_1 = sub_1000a940(eax_19);
                }
                
                sub_1000a6d0(eax, 0xa);
            }
        }
        
        sub_1000a6a0(&eax_2[0x105]);
    }
    
    *(eax + 0x428) = 0;
    return i;
}

int32_t __fastcall sub_1000a660(void* arg1)
{
    int32_t result;
    
    if ((InterlockedIncrement((arg1 + 8)) <= 1 || *(arg1 + 0xc) == 0))
    {
        sub_1000a6a0(arg1);
        result = 0;
    }
    else
        result = 1;
    
    return result;
}

int32_t __fastcall sub_1000a6a0(void* arg1)
{
    int32_t result = InterlockedDecrement((arg1 + 8));
    
    if (result == 0)
        *(arg1 + 0xc) = 0;
    
    return result;
}

void* __thiscall sub_1000a6d0(void* arg1, int32_t arg2)
{
    void* var_8 = arg1;
    *(arg1 + 0x440) += arg2;
    return arg1;
}

int32_t __thiscall sub_1000a700(void* arg1, int32_t arg2)
{
    int32_t* var_8 = sub_1000a040(arg1, arg2);
    int32_t result;
    
    if (var_8 == 0)
        result = 0;
    else
    {
        int32_t var_c_1 = *var_8;
        
        while (true)
        {
            if (var_c_1 == 0xffffffff)
            {
                sub_1000a6a0(&var_8[0x105]);
                result = 1;
                break;
            }
            
            void* eax_2 = sub_1000a0f0(arg1, var_c_1);
            
            if (eax_2 == 0)
            {
                sub_1000a6a0(&var_8[0x105]);
                result = 0;
                break;
            }
            
            var_c_1 = *(eax_2 + 0x14);
            InterlockedDecrement(&var_8[1]);
            *var_8 = var_c_1;
            sub_1000a6a0(eax_2);
        }
    }
    
    return result;
}

int32_t Platform::Details::Heap::Allocate(int32_t arg1) __pure
{
    return arg1;
}

int32_t* __fastcall sub_1000a7b0(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    *arg1 = 0xffffffff;
    arg1[1] = 0;
    arg1[0x104] = 0;
    arg1[2] = 0;
    arg1[0x84] = 0;
    return arg1;
}

int32_t __thiscall sub_1000a800(int32_t* arg1, HMODULE arg2)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    int16_t lpFilename = 0;
    void var_212;
    sub_1000fae0(&var_212, 0, 0x206);
    GetModuleFileNameW(arg2, &lpFilename, 0x104);
    int16_t var_e = 0;
    sub_10008870(sub_1000fe70(&arg1[2], 0x104, &lpFilename, 0xffffffff));
    void* i;
    
    for (i = ((arg1 + (sub_100136b0(&arg1[2]) << 1)) + 8); i > &arg1[2]; i -= 2)
    {
        if (*(i - 2) == 0x5c)
            break;
    }
    
    sub_10008870(sub_1000fe70(&arg1[0x84], 0x100, i, 0x3f));
    arg1[0x104] = arg2;
    arg1[1] = 0;
    *arg1 = 0xffffffff;
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t* __fastcall sub_1000a940(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    Concurrency::details::_Dynamic_array<class Concurrency::ITarget<enum Concurrency::agent_status>*>::_Init(arg1);
    arg1[4] = 0;
    sub_1000a9c0(arg1, &data_10036a94, 0);
    return arg1;
}

int32_t* __fastcall Concurrency::details::_Dynamic_array<class Concurrency::ITarget<enum Concurrency::agent_status>*>::_Init(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    *arg1 = 0;
    arg1[1] = 0;
    arg1[2] = 0;
    arg1[3] = 0;
    return arg1;
}

void* __thiscall sub_1000a9c0(void* arg1, int16_t* arg2, int32_t arg3)
{
    void* var_8 = arg1;
    sub_10008870(sub_1000fe70((arg1 + 0x18), 0x40, arg2, sub_100136b0(arg2)));
    *(arg1 + 0x10) = arg3;
    return arg1;
}

int32_t* __fastcall sub_1000aa10(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    sub_1000a7b0(arg1);
    Concurrency::details::_Dynamic_array<class Concurrency::ITarget<enum Concurrency::agent_status>*>::_Init(&arg1[0x105]);
    arg1[0x109] = 0;
    return arg1;
}

void __thiscall sub_1000aa50(void* arg1, int32_t (* arg2)(int32_t arg1, PSTR arg2, int32_t arg3, void* arg4, int32_t arg5))
{
    int32_t (* var_c)(int32_t arg1, PSTR arg2, int32_t arg3, void* arg4, int32_t arg5);
    
    if (arg2 == 0)
        var_c = sub_1000ed60;
    else
        var_c = arg2;
    
    *(arg1 + 0x424) = var_c;
}

int32_t* __thiscall sub_1000aa90(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    sub_1000a7b0(arg1);
    arg1[0x105] = 0;
    arg1[0x106] = 0;
    arg1[0x107] = 0;
    arg1[0x108] = 0;
    arg1[0x109] = 0;
    arg1[0x10a] = 0;
    *(arg1 + 0x429) = 1;
    *(arg1 + 0x42a) = 0;
    *(arg1 + 0x42b) = 0;
    arg1[0x10b] = GetCurrentProcessId();
    arg1[0x10c] = arg2;
    arg1[0x10d] = 1;
    arg1[0x111] = 0;
    arg1[0x10e] = arg1;
    sub_1000a800(arg1, nullptr);
    return arg1;
}

int32_t __fastcall sub_1000ab60(int32_t arg1)
{
    int32_t var_8 = arg1;
    return InterlockedIncrement((arg1 + 0x444), arg1);
}

int32_t sub_1000ab80(int32_t arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x100419b0;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_2c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t result = (__security_cookie_1 ^ &__saved_ebp);
    int32_t result_1 = result;
    fsbase->NtTib.ExceptionList = &ExceptionList;
    
    if (arg1 != 0)
    {
        __lock(4);
        int32_t var_8_1 = 0;
        
        if (((*(arg1 - 0xc) != 4 && (*(arg1 - 0xc) != 1 && (*(arg1 - 0xc) != 2 && *(arg1 - 0xc) != 3))) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x34, nullptr, u"_BLOCK_TYPE_IS_VALID(pHead->nBlo…") == 1))
            breakpoint();
        
        sub_10011340(arg1, *(arg1 - 0xc));
        int32_t var_8_2 = 0xfffffffe;
        result = sub_1000ac4a();
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1000ac4a()
{
    return __unlock(4);
}

void __fastcall sub_1000ac70(int32_t arg1)
{
    int32_t eax;
    int32_t edx;
    int32_t ebp;
    int32_t esi;
    int32_t edi;
    
    if (arg1 != __security_cookie)
        /* tailcall */
        return sub_100139e0(eax, edx, arg1, ebp, esi, edi);
}

int32_t __fastcall sub_1000ac80(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    *arg1 = 0x10036b54;
    return sub_10013af0(arg1);
}

int32_t* __thiscall sub_1000acb0(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    sub_1000ac80(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80(arg1);
    
    return arg1;
}

int32_t __thiscall sub_1000ace0(void* arg1, void* arg2)
{
    void* var_8 = arg1;
    int32_t eax_2 = sub_10013c00((arg2 + 9), (arg1 + 9));
    int32_t eax_3 = -(eax_2);
    return ((eax_3 - eax_3) + 1);
}

int32_t __mktime32(int32_t arg1)
{
    return sub_10011340(arg1, 1);
}

int32_t Concurrency::set_task_execution_resources(int32_t arg1)
{
    return sub_1000ab80(arg1);
}

int32_t sub_1000ad50(char* arg1, int32_t arg2, int128_t* arg3, void* arg4)
{
    if (arg4 == 0)
        return 0;
    
    int32_t eax_1;
    eax_1 = arg1 != 0;
    
    if ((eax_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x37, nullptr, u"dst != NULL") == 1))
        breakpoint();
    
    if (eax_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"dst != NULL", u"memcpy_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x37, 0);
        return 0x16;
    }
    
    if ((arg3 != 0 && arg2 >= arg4))
    {
        sub_10013c90(arg1, arg3, arg4);
        return 0;
    }
    
    sub_1000fae0(arg1, 0, arg2);
    int32_t edx_2;
    edx_2 = arg3 != 0;
    int32_t var_c_1 = edx_2;
    
    if (var_c_1 == 0)
    {
        int32_t eax_5;
        eax_5 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3d, nullptr, u"src != NULL");
        
        if (eax_5 == 1)
            breakpoint();
    }
    
    if (var_c_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"src != NULL", u"memcpy_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3d, 0);
        return 0x16;
    }
    
    int32_t edx_3 = (edx_2 - edx_2);
    
    if ((edx_3 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3e, nullptr, u"sizeInBytes >= count") == 1))
        breakpoint();
    
    if (edx_3 != 0xffffffff)
        return 0x16;
    
    *sub_1000eca0() = 0x22;
    sub_1000c310(u"sizeInBytes >= count", u"memcpy_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3e, 0);
    return 0x22;
}

int32_t sub_1000aee0(int128_t* arg1, int32_t arg2, int128_t* arg3, void* arg4)
{
    if (arg4 == 0)
        return 0;
    
    int32_t eax_1;
    eax_1 = arg1 != 0;
    
    if ((eax_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x36, nullptr, u"dst != NULL") == 1))
        breakpoint();
    
    if (eax_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"dst != NULL", u"memmove_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x36, 0);
        return 0x16;
    }
    
    int32_t edx_1;
    edx_1 = arg3 != 0;
    int32_t var_c_1 = edx_1;
    
    if (var_c_1 == 0)
    {
        int32_t eax_4;
        eax_4 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x37, nullptr, u"src != NULL");
        
        if (eax_4 == 1)
            breakpoint();
    }
    
    if (var_c_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"src != NULL", u"memmove_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x37, 0);
        return 0x16;
    }
    
    int32_t edx_2 = (edx_1 - edx_1);
    
    if ((edx_2 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x38, nullptr, u"sizeInBytes >= count") == 1))
        breakpoint();
    
    if (edx_2 != 0xffffffff)
    {
        sub_10014000(arg1, arg3, arg4, (edx_2 + 1), var_c_1, eax_1);
        return 0;
    }
    
    *sub_1000eca0() = 0x22;
    sub_1000c310(u"sizeInBytes >= count", u"memmove_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x38, 0);
    return 0x22;
}

int32_t sub_1000b040(int32_t arg1, PWSTR arg2, int32_t arg3, void* arg4, int32_t arg5)
{
    int32_t var_8_1 = 0;
    return __wsopen_dispatch(arg1, arg2, arg3, arg4, arg5, &arg_18);
}

int32_t __wsopen_dispatch(int32_t arg1, PWSTR arg2, int32_t arg3, void* arg4, int32_t arg5, int32_t arg6)
{
    return sub_10014bb0(arg1, arg2, arg3, arg4, arg5, arg6);
}

int32_t sub_1000b0b0(int32_t arg1, int32_t arg2, int32_t arg3, void* arg4, int16_t* arg5)
{
    __chkstk(0x2258);
    int32_t __saved_ebp;
    void* const var_14 = (__security_cookie ^ &__saved_ebp);
    int32_t var_8 = 0;
    int32_t var_10 = 0;
    
    if (arg5 != 0)
    {
        int16_t var_201c_1 = 0;
        void lpFilename;
        
        if (GetModuleFileNameW(nullptr, &lpFilename, 0x104) == 0)
            sub_1000b4b0(sub_1000fb90(&lpFilename, 0x104, u"<program name unknown>"), u"wcscpy_s(szExeName, 260, L"<prog…", u"__crtMessageWindowW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13c, 0);
        
        void* var_c_3 = &lpFilename;
        void* var_8_3 = var_c_3;
        
        if (sub_100136b0(var_8_3) > 0x40)
        {
            void* var_c_4 = ((var_c_3 + (sub_100136b0(var_c_3) << 1)) - 0x80);
            var_8_3 = nullptr;
            sub_1000b4b0(sub_1000ad50(0x145, ((0x104 - ((0x145 - &lpFilename) >> 1)) << 1), data_10044028, 6), u"memcpy_s(szShortProgName, sizeof…", u"__crtMessageWindowW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x145, var_8_3);
        }
        
        if (arg4 != 0)
        {
            var_8_3 = arg4;
            
            if (sub_100136b0(var_8_3) > 0x40)
                var_8_3 = ((arg4 + (sub_100136b0(arg4) << 1)) - 0x7a);
        }
        
        int32_t eax_15 = *sub_1000eca0();
        *sub_1000eca0() = 0;
        wchar16 const* const var_2230_1;
        
        if (arg1 != 2)
            var_2230_1 = &data_10036a94;
        else
            var_2230_1 = u"\n\nFor information on how your …";
        
        int16_t* var_2234_1;
        
        if (*arg5 == 0)
            var_2234_1 = &data_10036a94;
        else
            var_2234_1 = arg5;
        
        wchar16 const* const var_2238_1;
        
        if ((*arg5 == 0 || arg1 != 2))
            var_2238_1 = &data_10036a94;
        else
            var_2238_1 = u"Expression: ";
        
        void* const var_223c_1;
        
        if (*arg5 == 0)
            var_223c_1 = &data_10036a94;
        else
            var_223c_1 = &data_10036f90;
        
        int32_t var_2240_1;
        
        if (arg3 == 0)
            var_2240_1 = 0x10036a94;
        else
            var_2240_1 = arg3;
        
        wchar16 const* const var_2244_1;
        
        if (arg3 == 0)
            var_2244_1 = &data_10036a94;
        else
            var_2244_1 = u"\nLine: ";
        
        int32_t var_2248_1;
        
        if (arg2 == 0)
            var_2248_1 = 0x10036a94;
        else
            var_2248_1 = arg2;
        
        wchar16 const* const var_224c_1;
        
        if (arg2 == 0)
            var_224c_1 = &data_10036a94;
        else
            var_224c_1 = u"\nFile: ";
        
        void* var_2250_1;
        
        if (var_8_3 == 0)
        {
            void* var_2254_1;
            
            if (arg4 == 0)
                var_2254_1 = &data_10036a94;
            else
                var_2254_1 = arg4;
            
            var_2250_1 = var_2254_1;
        }
        else
            var_2250_1 = var_8_3;
        
        void* const var_2258_1;
        
        if (var_8_3 == 0)
            var_2258_1 = &data_10036a94;
        else
            var_2258_1 = &data_10036ca8;
        
        wchar16 const* const var_225c_1;
        
        if (arg4 == 0)
            var_225c_1 = &data_10036a94;
        else
            var_225c_1 = u"\nModule: ";
        
        wchar16 const* const var_8_6 = var_2230_1;
        wchar16 const* const var_10_4 = var_2238_1;
        var_14 = var_223c_1;
        int32_t var_18_3 = var_2240_1;
        wchar16 const* const var_1c_5 = var_2244_1;
        int32_t var_20_3 = var_2248_1;
        wchar16 const* const var_24_3 = var_224c_1;
        void* var_28_2 = var_2250_1;
        void* const var_2c_1 = var_2258_1;
        wchar16 const* const var_30_1 = var_225c_1;
        int16_t* var_34_1 = var_2234_1;
        int32_t var_38_1 = &data_10036cf0[arg1];
        void var_2014;
        wchar16 const* const var_10_5 = sub_1000fb60(&var_2014, 0x1000, 0xfff, u"Debug %s!\n\nProgram: %s%s%s%s%s…");
        
        if (var_10_5 < 0)
        {
            var_10_5 = u"f:\dd\vctools\crt_bld\self_x86\c…";
            var_14 = u"__crtMessageWindowW";
            sub_1000b4e0(*sub_1000eca0(), 0x16, 0x22, u"(*_errno())", var_14, var_10_5, 0x160, 0);
        }
        
        *sub_1000eca0() = eax_15;
        
        if (var_10_5 < 0)
        {
            var_14 = u"__crtMessageWindowW";
            sub_1000b4b0(sub_1000fb90(&var_2014, 0x1000, u"_CrtDbgReport: String too long o…"), u"wcscpy_s(szOutMessage, 4096, L"_…", var_14, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x163, 0);
        }
        
        if (sub_10015f10(&var_2014, u"Microsoft Visual C++ Debug Libra…", 0x12012) == 3)
        {
            sub_10015b80(0x16);
            sub_100155e0(3);
        }
    }
    
    return sub_1000ac70((var_14 ^ &__saved_ebp));
}

void sub_1000b4b0(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6)
{
    if (arg1 != 0)
    {
        int32_t var_8_1 = arg6;
        int32_t var_c_1 = arg5;
        int32_t var_10_1 = arg4;
        int32_t var_14_1 = arg3;
        int32_t var_18_1 = arg2;
        sub_1000c380();
    }
}

int32_t sub_1000b4e0(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8)
{
    if ((arg1 == 0 || (arg1 != arg2 && arg1 != arg3)))
        return arg1;
    
    int32_t var_8_1 = arg8;
    int32_t var_c_1 = arg7;
    int32_t var_10_1 = arg6;
    int32_t var_14_1 = arg5;
    int32_t var_18_1 = arg4;
    sub_1000c380();
    return arg1;
}

int32_t __stdcall sub_1000b530(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x100419d0;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_2c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_20 = 0;
    arg1 += (arg2 * arg3);
    int32_t var_8_1 = 0;
    int32_t __saved_ebp;
    
    while (true)
    {
        bool cond:0_1 = (arg3 - 1) < 0;
        arg3 -= 1;
        
        if (cond:0_1)
            break;
        
        arg1 -= arg2;
        arg4((__security_cookie_1 ^ &__saved_ebp));
    }
    
    int32_t var_20_1 = 1;
    int32_t var_8_2 = 0xfffffffe;
    int32_t result = $LN10(&__saved_ebp);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

void $LN10(void* arg1 @ ebp)
{
    if (*(arg1 - 0x1c) == 0)
        notify_debugger(*(arg1 + 8), *(arg1 + 0xc), *(arg1 + 0x10), *(arg1 + 0x14));
}

int32_t __stdcall notify_debugger(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x100419f0;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_28 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_2c = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_1c = &var_2c;
    int32_t var_8_1 = 0;
    int32_t result;
    
    while (true)
    {
        result = (arg3 - 1);
        bool cond:0_1 = (arg3 - 1) < 0;
        arg3 = result;
        
        if (cond:0_1)
            break;
        
        arg1 -= arg2;
        arg4();
    }
    
    int32_t var_8_2 = 0xfffffffe;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1000b641(void* arg1 @ ebp)
{
    ArrayUnwindFilter(*(arg1 - 0x14));
    return 0;
}

int32_t ArrayUnwindFilter(int32_t* arg1)
{
    if (**arg1 == 0xe06d7363)
        sub_10016180();
    
    return 0;
}

int32_t sub_1000b6a0(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    void var_2c;
    void* var_c = &var_2c;
    int32_t ecx;
    ecx = arg2 != 0;
    
    if ((ecx == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x1b3, nullptr, u"(format != NULL)") == 1))
        breakpoint();
    
    if (ecx == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(format != NULL)", u"_vscwprintf_helper", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x1b3, 0);
        return 0xffffffff;
    }
    
    *(var_c + 4) = 0x7fffffff;
    *(var_c + 0xc) = 0x42;
    *(var_c + 8) = 0;
    *var_c = 0;
    return arg1(var_c, arg2, arg3, arg4, ecx);
}

int32_t _vprintf(int32_t arg1, int32_t arg2)
{
    return sub_1000b6a0(sub_10016580, arg1, 0, arg2);
}

int32_t sub_1000b780(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6)
{
    void var_2c;
    void* var_c = &var_2c;
    int32_t ecx;
    ecx = arg4 != 0;
    
    if ((ecx == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x82, nullptr, u"(format != NULL)") == 1))
        breakpoint();
    
    if (ecx == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(format != NULL)", u"_vswprintf_helper", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x82, 0);
        return 0xffffffff;
    }
    
    int32_t var_38_1;
    
    if ((arg3 == 0 || arg2 != 0))
        var_38_1 = 1;
    else
        var_38_1 = 0;
    
    if ((var_38_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x85, nullptr, u"(count == 0) || (string != NULL)") == 1))
        breakpoint();
    
    if (var_38_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(count == 0) || (string != NULL)", u"_vswprintf_helper", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x85, 0);
        return 0xffffffff;
    }
    
    *(var_c + 0xc) = 0x42;
    *(var_c + 8) = arg2;
    *var_c = arg2;
    
    if (arg3 <= 0x3fffffff)
        *(var_c + 4) = (arg3 << 1);
    else
        *(var_c + 4) = 0x7fffffff;
    
    int32_t result = arg1(var_c, arg4, arg5, arg6);
    
    if (arg2 == 0)
        return result;
    
    if (result >= 0)
    {
        *(var_c + 4) -= 1;
        uint32_t var_3c_1;
        
        if (*(var_c + 4) < 0)
        {
            void* var_44_2 = var_c;
            var_3c_1 = sub_100162c0(nullptr);
        }
        else
        {
            **var_c = 0;
            var_3c_1 = 0;
            *var_c += 1;
        }
        
        if (var_3c_1 != 0xffffffff)
        {
            *(var_c + 4) -= 1;
            uint32_t var_40_1;
            
            if (*(var_c + 4) < 0)
            {
                void* var_44_3 = var_c;
                var_40_1 = sub_100162c0(nullptr);
            }
            else
            {
                **var_c = 0;
                var_40_1 = 0;
                *var_c += 1;
            }
            
            if (var_40_1 != 0xffffffff)
                return result;
        }
    }
    
    *((arg2 + (arg3 << 1)) - 2) = 0;
    
    if (*(var_c + 4) >= 0)
        return 0xffffffff;
    
    return 0xfffffffe;
}

int32_t sub_1000b9b0(int16_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)
{
    int32_t var_8 = 0xffffffff;
    int32_t eax;
    eax = arg3 != 0;
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x10d, nullptr, u"format != NULL") == 1))
        breakpoint();
    
    if (eax == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"format != NULL", u"_vswprintf_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x10d, 0);
        return 0xffffffff;
    }
    
    int32_t var_18_1;
    
    if ((arg1 == 0 || arg2 <= 0))
        var_18_1 = 0;
    else
        var_18_1 = 1;
    
    if ((var_18_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x10e, nullptr, u"string != NULL && sizeInWords > …") == 1))
        breakpoint();
    
    if (var_18_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"string != NULL && sizeInWords > …", u"_vswprintf_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x10e, 0);
        return 0xffffffff;
    }
    
    int32_t result = sub_1000b780(sub_10017790, arg1, arg2, arg3, arg4, arg5);
    
    if (result < 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            int32_t var_1c_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_1c_1 = (arg2 - 1);
            else
                var_1c_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, (var_1c_1 << 1));
        }
    }
    
    if (result == 0xfffffffe)
    {
        int32_t var_20_1 = 0;
        
        if ((var_20_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x118, nullptr, u"("Buffer too small", 0)") == 1))
            breakpoint();
        
        if (var_20_1 == 0)
        {
            *sub_1000eca0() = 0x22;
            sub_1000c310(u"("Buffer too small", 0)", u"_vswprintf_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x118, 0);
            return 0xffffffff;
        }
    }
    
    if ((result >= 0 && (arg2 != 0xffffffff && (arg2 != 0x7fffffff && (result + 1) < arg2))))
    {
        int32_t var_24_1;
        
        if (data_100441c4 >= (arg2 - (result + 1)))
            var_24_1 = (arg2 - (result + 1));
        else
            var_24_1 = data_100441c4;
        
        sub_1000fae0(&arg1[(result + 1)], 0xfe, (var_24_1 << 1));
    }
    
    return result;
}

int32_t sub_1000bc20(int16_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    return sub_1000b9b0(arg1, arg2, arg3, 0, arg4);
}

int32_t sub_1000bc50(int16_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6)
{
    int32_t var_8 = 0xffffffff;
    int32_t var_c = 0;
    int32_t eax;
    eax = arg4 != 0;
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x139, nullptr, u"format != NULL") == 1))
        breakpoint();
    
    if (eax == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"format != NULL", u"_vsnwprintf_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x139, 0);
        return 0xffffffff;
    }
    
    if ((arg3 == 0 && (arg1 == 0 && arg2 == 0)))
        return 0;
    
    int32_t var_1c_1;
    
    if ((arg1 == 0 || arg2 <= 0))
        var_1c_1 = 0;
    else
        var_1c_1 = 1;
    
    if ((var_1c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13f, nullptr, u"string != NULL && sizeInWords > …") == 1))
        breakpoint();
    
    if (var_1c_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"string != NULL && sizeInWords > …", u"_vsnwprintf_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13f, 0);
        return 0xffffffff;
    }
    
    int32_t result;
    
    if (arg2 <= arg3)
    {
        int32_t edx_10 = *sub_1000eca0();
        result = sub_1000b780(sub_10017790, arg1, arg2, arg4, arg5, arg6);
        arg1[(arg2 - 1)] = 0;
        
        if ((result == 0xfffffffe && arg3 == 0xffffffff))
        {
            if (*sub_1000eca0() == 0x22)
                *sub_1000eca0() = edx_10;
            
            return 0xffffffff;
        }
    }
    else
    {
        int32_t edx_2 = *sub_1000eca0();
        result = sub_1000b780(sub_10017790, arg1, (arg3 + 1), arg4, arg5, arg6);
        
        if (result == 0xfffffffe)
        {
            if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && (arg3 + 1) < arg2)))
            {
                int32_t var_20_1;
                
                if (data_100441c4 >= (arg2 - (arg3 + 1)))
                    var_20_1 = (arg2 - (arg3 + 1));
                else
                    var_20_1 = data_100441c4;
                
                sub_1000fae0(&arg1[(arg3 + 1)], 0xfe, (var_20_1 << 1));
            }
            
            if (*sub_1000eca0() == 0x22)
                *sub_1000eca0() = edx_2;
            
            return 0xffffffff;
        }
    }
    
    if (result >= 0)
    {
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && (result + 1) < arg2)))
        {
            int32_t var_2c_1;
            
            if (data_100441c4 >= (arg2 - (result + 1)))
                var_2c_1 = (arg2 - (result + 1));
            else
                var_2c_1 = data_100441c4;
            
            sub_1000fae0(&arg1[(result + 1)], 0xfe, (var_2c_1 << 1));
        }
        
        if (result >= 0)
            return result;
        
        return 0xffffffff;
    }
    
    *arg1 = 0;
    
    if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
    {
        int32_t var_24_1;
        
        if (data_100441c4 >= (arg2 - 1))
            var_24_1 = (arg2 - 1);
        else
            var_24_1 = data_100441c4;
        
        sub_1000fae0(&arg1[1], 0xfe, (var_24_1 << 1));
    }
    
    if (result == 0xfffffffe)
    {
        int32_t var_28_1 = 0;
        
        if ((var_28_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x166, nullptr, u"("Buffer too small", 0)") == 1))
            breakpoint();
        
        if (var_28_1 == 0)
        {
            *sub_1000eca0() = 0x22;
            sub_1000c310(u"("Buffer too small", 0)", u"_vsnwprintf_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x166, 0);
        }
    }
    
    return 0xffffffff;
}

int32_t __vsnwprintf_s(int16_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)
{
    return sub_1000bc50(arg1, arg2, arg3, arg4, 0, arg5);
}

int32_t* __fastcall Concurrency::details::_MallocaArrayHolder<class Concurrency::event*>::_MallocaArrayHolder<class Concurrency::event*>(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    *arg1 = 0x10037430;
    arg1[1] = 0;
    arg1[2] = 0;
    return arg1;
}

int32_t* __thiscall sub_1000c060(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    sub_1000c1f0(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80(arg1);
    
    return arg1;
}

int32_t* __thiscall sub_1000c090(int32_t* arg1, int32_t* arg2)
{
    *arg1 = 0x10037430;
    
    if (*arg2 == 0)
        arg1[1] = 0;
    else
    {
        void* eax_3 = (_strlen(*arg2) + 1);
        arg1[1] = _malloc(eax_3);
        
        if (arg1[1] != 0)
            sub_10010280(arg1[1], eax_3, *arg2);
    }
    
    arg1[2] = 1;
    return arg1;
}

int32_t* __thiscall sub_1000c120(int32_t* arg1, int32_t* arg2)
{
    int32_t* var_8 = arg1;
    *arg1 = 0x10037430;
    arg1[1] = *arg2;
    arg1[2] = 0;
    return arg1;
}

int32_t* __thiscall sub_1000c150(int32_t* arg1, void* arg2)
{
    *arg1 = 0x10037430;
    arg1[2] = *(arg2 + 8);
    
    if (arg1[2] == 0)
        arg1[1] = *(arg2 + 4);
    else if (*(arg2 + 4) == 0)
        arg1[1] = 0;
    else
    {
        void* eax_4 = (_strlen(*(arg2 + 4)) + 1);
        arg1[1] = _malloc(eax_4);
        
        if (arg1[1] != 0)
            sub_10010280(arg1[1], eax_4, *(arg2 + 4));
    }
    
    return arg1;
}

int32_t* __fastcall sub_1000c1f0(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    *arg1 = 0x10037430;
    
    if (arg1[2] == 0)
        return arg1;
    
    return __mktime32(arg1[1]);
}

char const* const __fastcall sub_1000c220(void* arg1)
{
    void* var_8 = arg1;
    
    if (*(arg1 + 4) == 0)
        return "Unknown exception";
    
    return *(arg1 + 4);
}

int32_t* __fastcall sub_1000c250(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    sub_1000c090(arg1, &arg_4);
    *arg1 = 0x10037450;
    return arg1;
}

int32_t* __thiscall sub_1000c280(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    sub_1000c2e0(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80(arg1);
    
    return arg1;
}

int32_t* __thiscall sub_1000c2b0(int32_t* arg1, void* arg2)
{
    int32_t* var_8 = arg1;
    sub_1000c150(arg1, arg2);
    *arg1 = 0x10037450;
    return arg1;
}

int32_t* __fastcall sub_1000c2e0(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    *arg1 = 0x10037450;
    return sub_1000c1f0(arg1);
}

int32_t __initp_misc_invarg(int32_t arg1)
{
    data_100455f0 = arg1;
    return arg1;
}

int32_t sub_1000c310(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t eax_1 = sub_10018b70(data_100455f0);
    
    if (eax_1 != 0)
        return eax_1(arg1, arg2, arg3, arg4, arg5, eax_1);
    
    int32_t var_c_2 = 2;
    __heap_term();
    int32_t var_c_3 = arg5;
    int32_t var_10_1 = arg4;
    int32_t var_14_1 = arg3;
    int32_t var_18_1 = arg2;
    int32_t var_1c_1 = arg1;
    return sub_1000c380();
}

int32_t sub_1000c380()
{
    int32_t ebp;
    int32_t var_4 = ebp;
    int32_t eax_1 = (__security_cookie ^ &var_4);
    int32_t var_33c = 0;
    int32_t var_338;
    char* eax_2 = sub_1000fae0(&var_338, 0, 0x4c);
    bool p = /* bool p = unimplemented  {add esp, 0xc} */;
    bool a = /* bool a = unimplemented  {add esp, 0xc} */;
    int32_t* ExceptionInfo = &var_33c;
    int32_t var_2e4;
    int32_t* var_8 = &var_2e4;
    int32_t var_10 = 0;
    int32_t var_2e8 = 0;
    char* var_234 = eax_2;
    int32_t* var_238 = &var_33c;
    int32_t* var_23c = &var_2e4;
    int32_t ebx;
    int32_t var_240 = ebx;
    int32_t esi;
    int32_t var_244 = esi;
    int32_t edi;
    int32_t var_248 = edi;
    int16_t ss;
    int16_t var_21c = ss;
    int16_t cs;
    int16_t var_228 = cs;
    int16_t ds;
    int16_t var_24c = ds;
    int16_t es;
    int16_t var_250 = es;
    int16_t fs;
    int16_t var_254 = fs;
    int16_t gs;
    int16_t var_258 = gs;
    int32_t var_348;
    bool d;
    int32_t var_340 = (((((&var_348 + 0xc)) ? 1 : 0) << 0xb) | ((((d) ? 1 : 0) << 0xa) | ((((&var_33c < 0) ? 1 : 0) << 7) | ((((&var_348 == 0xfffffff4) ? 1 : 0) << 6) | ((((a) ? 1 : 0) << 4) | ((((p) ? 1 : 0) << 2) | ((&var_348 >= 0xfffffff4) ? 1 : 0)))))));
    int32_t var_224 = var_340;
    var_2e4 = 0x10001;
    void* const __return_addr_2 = __return_addr;
    int32_t var_230 = var_4;
    var_33c = 0xc0000417;
    var_338 = 1;
    void* const __return_addr_1 = __return_addr;
    BOOL eax_5 = IsDebuggerPresent();
    SetUnhandledExceptionFilter(nullptr);
    
    if ((UnhandledExceptionFilter(&ExceptionInfo) == 0 && eax_5 == 0))
    {
        int32_t var_340_2 = 2;
        __heap_term();
    }
    
    TerminateProcess(GetCurrentProcess(), 0xc0000417);
    return sub_1000ac70((eax_1 ^ &var_4));
}

uint32_t sub_1000c4d0(int32_t* arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041a10;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_4c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_50 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    uint32_t result_1 = 0;
    int32_t eax_2;
    eax_2 = arg1 != 0;
    
    if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x29, nullptr, u"(stream != NULL)") == 1))
        breakpoint();
    
    uint32_t result;
    
    if (eax_2 != 0)
    {
        sub_10019550(arg1);
        int32_t var_8_1 = 0;
        int32_t var_3c_1;
        
        if ((arg1[3] & 0x40) != 0)
            var_3c_1 = 1;
        else
        {
            int32_t eax_7;
            int32_t ecx_2;
            eax_7 = sub_10019e20(arg1);
            int32_t var_34_1;
            
            if ((eax_7 == 0xffffffff || eax_7 == 0xfffffffe))
                var_34_1 = 0x100445b0;
            else
                var_34_1 = (((eax_7 & 0x1f) << 6) + &data_10049260[(eax_7 >> 5)]);
            
            ecx_2 = *(var_34_1 + 0x24);
            ecx_2 <<= 1;
            ecx_2 s>>= 1;
            int32_t eax_8;
            
            if (ecx_2 == 0)
            {
                void* var_38_1;
                
                if ((eax_7 == 0xffffffff || eax_7 == 0xfffffffe))
                    var_38_1 = &data_100445b0;
                else
                    var_38_1 = (((eax_7 & 0x1f) << 6) + &data_10049260[(eax_7 >> 5)]);
                
                eax_8 = *(var_38_1 + 0x24);
                eax_8 = eax_8;
                eax_8 s>>= 7;
            }
            
            if ((ecx_2 == 0 && eax_8 == 0))
                var_3c_1 = 1;
            else
                var_3c_1 = 0;
        }
        
        if ((var_3c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2d, nullptr, u"( (_Stream->_flag & _IOSTRG) || …") == 1))
            breakpoint();
        
        if (var_3c_1 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"( (_Stream->_flag & _IOSTRG) || …", u"fgetc", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2d, 0);
            result_1 = 0xffffffff;
        }
        
        if (result_1 == 0)
        {
            arg1[1] -= 1;
            uint32_t result_2;
            
            if (arg1[1] < 0)
                result_2 = sub_10019690(arg1);
            else
            {
                result_2 = **arg1;
                *arg1 += 1;
            }
            
            result_1 = result_2;
        }
        
        int32_t var_8_2 = 0xfffffffe;
        $LN18(&__saved_ebp);
        result = result_1;
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(stream != NULL)", u"fgetc", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x29, 0);
        result = 0xffffffff;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t $LN18(void* arg1 @ ebp)
{
    return sub_100195f0(*(arg1 + 8));
}

uint32_t sub_1000c720(int32_t* arg1, char** arg2)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041a30;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_4c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_50 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    uint32_t result_1 = 0;
    int32_t eax_2;
    eax_2 = arg2 != 0;
    
    if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2c, nullptr, u"(str != NULL)") == 1))
        breakpoint();
    
    uint32_t result;
    
    if (eax_2 != 0)
    {
        sub_10019550(arg2);
        int32_t var_8_1 = 0;
        int32_t var_3c_1;
        
        if ((arg2[3] & 0x40) != 0)
            var_3c_1 = 1;
        else
        {
            int32_t eax_7;
            int32_t ecx_2;
            eax_7 = sub_10019e20(arg2);
            int32_t var_34_1;
            
            if ((eax_7 == 0xffffffff || eax_7 == 0xfffffffe))
                var_34_1 = 0x100445b0;
            else
                var_34_1 = (((eax_7 & 0x1f) << 6) + &data_10049260[(eax_7 >> 5)]);
            
            ecx_2 = *(var_34_1 + 0x24);
            ecx_2 <<= 1;
            ecx_2 s>>= 1;
            int32_t eax_8;
            
            if (ecx_2 == 0)
            {
                void* var_38_1;
                
                if ((eax_7 == 0xffffffff || eax_7 == 0xfffffffe))
                    var_38_1 = &data_100445b0;
                else
                    var_38_1 = (((eax_7 & 0x1f) << 6) + &data_10049260[(eax_7 >> 5)]);
                
                eax_8 = *(var_38_1 + 0x24);
                eax_8 = eax_8;
                eax_8 s>>= 7;
            }
            
            if ((ecx_2 == 0 && eax_8 == 0))
                var_3c_1 = 1;
            else
                var_3c_1 = 0;
        }
        
        if ((var_3c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x31, nullptr, u"( (_Stream->_flag & _IOSTRG) || …") == 1))
            breakpoint();
        
        if (var_3c_1 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"( (_Stream->_flag & _IOSTRG) || …", u"fputc", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x31, 0);
            result_1 = 0xffffffff;
        }
        
        if (result_1 == 0)
        {
            arg2[1] -= 1;
            uint32_t result_2;
            
            if (arg2[1] < 0)
            {
                char** var_54_3 = arg2;
                result_2 = sub_100162c0(arg1);
            }
            else
            {
                char** ecx_10;
                ecx_10 = arg1;
                **arg2 = ecx_10;
                result_2 = arg1;
                *arg2 = &*arg2[1];
            }
            
            result_1 = result_2;
        }
        
        int32_t var_8_2 = 0xfffffffe;
        $LN24(&__saved_ebp);
        result = result_1;
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(str != NULL)", u"fputc", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2c, 0);
        result = 0xffffffff;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t $LN24(void* arg1 @ ebp)
{
    return sub_100195f0(*(arg1 + 0xc));
}

uint32_t sub_1000c970(int32_t arg1, int32_t* arg2)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041a50;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_34 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t eax_2;
    eax_2 = arg2 != 0;
    
    if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x30, nullptr, u"(stream != NULL)") == 1))
        breakpoint();
    
    uint32_t result;
    
    if (eax_2 != 0)
    {
        sub_10019550(arg2);
        int32_t var_8_1 = 0;
        uint32_t result_1 = sub_1000ca60(arg1, arg2);
        int32_t var_8_2 = 0xfffffffe;
        $LN12(&__saved_ebp);
        result = result_1;
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(stream != NULL)", u"ungetc", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x30, 0);
        result = 0xffffffff;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t $LN12(void* arg1 @ ebp)
{
    return sub_100195f0(*(arg1 + 0xc));
}

uint32_t sub_1000ca60(int32_t arg1, int32_t* arg2)
{
    int32_t var_20;
    
    if ((arg2[3] & 0x40) != 0)
        var_20 = 1;
    else
    {
        int32_t eax_2;
        int32_t ecx_1;
        eax_2 = sub_10019e20(arg2);
        int32_t var_18_1;
        
        if ((eax_2 == 0xffffffff || eax_2 == 0xfffffffe))
            var_18_1 = 0x100445b0;
        else
            var_18_1 = (((eax_2 & 0x1f) << 6) + &data_10049260[(eax_2 >> 5)]);
        
        ecx_1 = *(var_18_1 + 0x24);
        ecx_1 <<= 1;
        ecx_1 s>>= 1;
        int32_t eax_3;
        
        if (ecx_1 == 0)
        {
            void* var_1c_1;
            
            if ((eax_2 == 0xffffffff || eax_2 == 0xfffffffe))
                var_1c_1 = &data_100445b0;
            else
                var_1c_1 = (((eax_2 & 0x1f) << 6) + &data_10049260[(eax_2 >> 5)]);
            
            eax_3 = *(var_1c_1 + 0x24);
            eax_3 = eax_3;
            eax_3 s>>= 7;
        }
        
        if ((ecx_1 == 0 && eax_3 == 0))
            var_20 = 1;
        else
            var_20 = 0;
    }
    
    if ((var_20 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x26, nullptr, u"( (_Stream->_flag & _IOSTRG) || …") == 1))
        breakpoint();
    
    if (var_20 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"( (_Stream->_flag & _IOSTRG) || …", u"_ungetc_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x26, 0);
        return 0xffffffff;
    }
    
    if (arg1 != 0xffffffff)
    {
        if ((arg2[3] & 1) != 0)
        {
        label_1000cbb9:
            
            if (arg2[2] == 0)
                sub_10019ea0(arg2);
            
            if (*arg2 == arg2[2])
            {
                if (arg2[1] != 0)
                    return 0xffffffff;
                
                *arg2 += 1;
            }
            
            if ((arg2[3] & 0x40) == 0)
            {
                *arg2 -= 1;
                int32_t* ecx_19;
                ecx_19 = arg1;
                **arg2 = ecx_19;
            }
            else
            {
                *arg2 -= 1;
                
                if (**arg2 != arg1)
                {
                    *arg2 += 1;
                    return 0xffffffff;
                }
            }
            
            arg2[1] += 1;
            arg2[3] &= 0xffffffef;
            arg2[3] |= 1;
            return arg1;
        }
        
        if (((arg2[3] & 0x80) != 0 && (arg2[3] & 2) == 0))
            goto label_1000cbb9;
    }
    
    return 0xffffffff;
}

int32_t __stdcall ___BuildCatchObject(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041a70;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_34 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_24 = 0;
    int32_t var_8_1 = 0;
    
    for (int32_t i = 0; i < arg3; i += 1)
    {
        arg4(1);
        arg1 += arg2;
    }
    
    int32_t var_24_1 = 1;
    int32_t var_8_2 = 0xfffffffe;
    int32_t result = $LN11(&__saved_ebp);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

void $LN11(void* arg1 @ ebp)
{
    if (*(arg1 - 0x20) == 0)
        notify_debugger(*(arg1 + 8), *(arg1 + 0xc), *(arg1 - 0x1c), *(arg1 + 0x18));
}

int32_t sub_1000cd40(int32_t arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041a90;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_2c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_30 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    sub_10015a10();
    int32_t var_8_1 = 0;
    int32_t result = sub_1000cdc0(arg1);
    int32_t var_8_2 = 0xfffffffe;
    sub_1000cd9b();
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1000cd9b()
{
    return sub_10015a30();
}

int32_t sub_1000cdc0(int32_t arg1)
{
    int32_t eax_1 = sub_10018b70(data_1004a390);
    void* var_14 = sub_10018b70(data_1004a38c);
    
    if ((var_14 < eax_1 || ((var_14 - eax_1) + 4) < 4))
        return 0;
    
    void* eax_6 = sub_100118c0(eax_1, 2);
    
    if (eax_6 < ((var_14 - eax_1) + 4))
    {
        void* const var_1c_1;
        
        if (eax_6 >= 0x800)
            var_1c_1 = 0x800;
        else
            var_1c_1 = eax_6;
        
        void* ecx_3 = (eax_6 + var_1c_1);
        void* var_8_1;
        
        if (ecx_3 >= eax_6)
        {
            int32_t var_20_2 = 0x81;
            var_8_1 = __CrtSetDbgBlockType(eax_1, ecx_3, 2, "f:\dd\vctools\crt_bld\self_x86\c…");
        }
        
        if ((ecx_3 < eax_6 || var_8_1 == 0))
        {
            if ((eax_6 + 0x10) >= eax_6)
            {
                int32_t var_20_3 = 0x88;
                var_8_1 = __CrtSetDbgBlockType(eax_1, (eax_6 + 0x10), 2, "f:\dd\vctools\crt_bld\self_x86\c…");
            }
            
            if (((eax_6 + 0x10) < eax_6 || var_8_1 == 0))
                return 0;
        }
        
        var_14 = (var_8_1 + (((var_14 - eax_1) >> 2) << 2));
        data_1004a390 = sub_10018a80(var_8_1);
    }
    
    *var_14 = sub_10018a80(arg1);
    data_1004a38c = sub_10018a80((var_14 + 4));
    return arg1;
}

int32_t sub_1000cf10(int32_t arg1)
{
    int32_t eax_1 = sub_1000cd40(arg1);
    int32_t eax_2 = -(eax_1);
    return (-((eax_2 - eax_2)) - 1);
}

int32_t sub_1000cf30()
{
    int32_t ecx;
    int32_t var_8 = ecx;
    void* eax = sub_10010b10(0x20, 4, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0xd0);
    data_1004a390 = sub_10018a80(eax);
    data_1004a38c = data_1004a390;
    
    if (eax == 0)
        return 0x18;
    
    *eax = 0;
    return 0;
}

int32_t* sub_1000cf90(int16_t* arg1, int16_t* arg2, int32_t arg3)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041ab0;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_40 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_44 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_20 = 0;
    int32_t var_24 = 0;
    int32_t eax_2;
    eax_2 = arg1 != 0;
    
    if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x36, nullptr, u"(file != NULL)") == 1))
        breakpoint();
    
    int32_t* result;
    
    if (eax_2 != 0)
    {
        int32_t edx_1;
        edx_1 = arg2 != 0;
        
        if ((edx_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x37, nullptr, u"(mode != NULL)") == 1))
            breakpoint();
        
        if (edx_1 != 0)
        {
            uint32_t edx_2 = *arg2;
            int32_t edx_3 = -(edx_2);
            int32_t edx_5 = -((edx_3 - edx_3));
            
            if ((edx_5 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x38, nullptr, u"(*mode != _T('\0'))") == 1))
                breakpoint();
            
            if (edx_5 != 0)
            {
                int32_t* eax_9 = sub_1001a720();
                
                if (eax_9 != 0)
                {
                    int32_t var_8_1 = 0;
                    
                    if (*arg1 != 0)
                    {
                        int32_t* result_1 = sub_10019f60(arg1, arg2, arg3, eax_9);
                        int32_t var_8_2 = 0xfffffffe;
                        $LN28(&__saved_ebp);
                        result = result_1;
                    }
                    else
                    {
                        *sub_1000eca0() = 0x16;
                        __local_unwind4(0x100441a8, &ExceptionList, 0xfffffffe);
                        result = nullptr;
                    }
                }
                else
                {
                    *sub_1000eca0() = 0x18;
                    result = nullptr;
                }
            }
            else
            {
                *sub_1000eca0() = 0x16;
                sub_1000c310(u"(*mode != _T('\0'))", u"_wfsopen", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x38, 0);
                result = nullptr;
            }
        }
        else
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(mode != NULL)", u"_wfsopen", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x37, 0);
            result = nullptr;
        }
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(file != NULL)", u"_wfsopen", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x36, 0);
        result = nullptr;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t $LN28(void* arg1 @ ebp)
{
    return sub_100195f0(*(arg1 - 0x1c));
}

int32_t sub_1000d1a0(int32_t** arg1, int16_t* arg2, int16_t* arg3)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t eax;
    eax = arg1 != 0;
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x9e, nullptr, u"(pfile != NULL)") == 1))
        breakpoint();
    
    if (eax == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(pfile != NULL)", u"_wfopen_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x9e, 0);
        return 0x16;
    }
    
    *arg1 = sub_1000cf90(arg2, arg3, 0x80);
    
    if (*arg1 == 0)
        return *sub_1000eca0();
    
    return 0;
}

int32_t sub_1000d240(int32_t* arg1, int16_t* arg2)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041ad0;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_40 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_44 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t eax_2;
    eax_2 = arg1 != 0;
    
    if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x38, nullptr, u"(str != NULL)") == 1))
        breakpoint();
    
    int32_t result;
    
    if (eax_2 != 0)
    {
        int32_t edx_1;
        edx_1 = arg2 != 0;
        
        if ((edx_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x39, nullptr, u"(format != NULL)") == 1))
            breakpoint();
        
        if (edx_1 != 0)
        {
            sub_10019550(arg1);
            int32_t var_8_1 = 0;
            int32_t eax_8 = sub_1001aae0(arg1);
            void* var_48_3 = &arg_c;
            int32_t result_1 = sub_10016580(arg1, arg2, nullptr);
            sub_1001ac40(eax_8, arg1);
            int32_t var_8_2 = 0xfffffffe;
            sub_1000d39c(&__saved_ebp);
            result = result_1;
        }
        else
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(format != NULL)", u"fwprintf", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x39, 0);
            result = 0xffffffff;
        }
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(str != NULL)", u"fwprintf", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x38, 0);
        result = 0xffffffff;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1000d39c(void* arg1 @ ebp)
{
    return sub_100195f0(*(arg1 - 0x20));
}

int32_t sub_1000d3c0(int32_t arg1, int32_t* arg2, int32_t arg3, int32_t arg4, int32_t arg5)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041af0;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_3c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t eax_2;
    eax_2 = arg2 != 0;
    
    if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3a, nullptr, u"(str != NULL)") == 1))
        breakpoint();
    
    int32_t result;
    
    if (eax_2 != 0)
    {
        int32_t edx_1;
        edx_1 = arg3 != 0;
        
        if ((edx_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3b, nullptr, u"(format != NULL)") == 1))
            breakpoint();
        
        if (edx_1 != 0)
        {
            sub_10019550(arg2);
            int32_t var_8_1 = 0;
            int32_t eax_8 = sub_1001aae0(arg2);
            int32_t __saved_ebp;
            int32_t result_1 = arg1(arg2, arg3, arg4, arg5, (__security_cookie_1 ^ &__saved_ebp));
            sub_1001ac40(eax_8, arg2);
            int32_t var_8_2 = 0xfffffffe;
            sub_1000d516(&__saved_ebp);
            result = result_1;
        }
        else
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(format != NULL)", u"vfwprintf_helper", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3b, 0);
            result = 0xffffffff;
        }
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(str != NULL)", u"vfwprintf_helper", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3a, 0);
        result = 0xffffffff;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1000d516(void* arg1 @ ebp)
{
    return sub_100195f0(*(arg1 - 0x1c));
}

int32_t sub_1000d540(int32_t* arg1, int32_t arg2, int32_t arg3)
{
    return sub_1000d3c0(sub_10016580, arg1, arg2, 0, arg3);
}

int32_t sub_1000d570(int32_t* arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041b10;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_2c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_30 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result;
    
    if (arg1 != 0)
    {
        sub_10019550(arg1);
        int32_t var_8_1 = 0;
        int32_t result_1 = sub_1000d610(arg1);
        int32_t var_8_2 = 0xfffffffe;
        $LN8(&__saved_ebp);
        result = result_1;
    }
    else
        result = sub_1000d750(0);
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t $LN8(void* arg1 @ ebp)
{
    return sub_100195f0(*(arg1 + 8));
}

int32_t sub_1000d610(int32_t* arg1)
{
    if (arg1 == 0)
        return sub_1000d750(0);
    
    if (sub_1000d670(arg1) != 0)
        return 0xffffffff;
    
    if ((arg1[3] & 0x4000) == 0)
        return 0;
    
    enum WIN32_ERROR eax_5 = sub_1001acd0(sub_10019e20(arg1));
    int32_t eax_6 = -(eax_5);
    return (eax_6 - eax_6);
}

int32_t sub_1000d670(int32_t* arg1)
{
    int32_t result = 0;
    
    if (((arg1[3] & 3) == 2 && (arg1[3] & 0x108) != 0))
    {
        uint32_t ecx_4 = (*arg1 - arg1[2]);
        
        if (ecx_4 > 0)
        {
            if (sub_1001aef0(sub_10019e20(arg1), arg1[2], ecx_4) != ecx_4)
            {
                arg1[3] |= 0x20;
                result = 0xffffffff;
            }
            else if ((arg1[3] & 0x80) != 0)
                arg1[3] &= 0xfffffffd;
        }
    }
    
    *arg1 = arg1[2];
    arg1[1] = 0;
    return result;
}

int32_t ___acrt_get_developer_information_policy()
{
    return sub_1000d750(1);
}

int32_t sub_1000d750(int32_t arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041b30;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_34 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_38 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result_2 = 0;
    int32_t result_1 = 0;
    __lock(1);
    int32_t var_8_1 = 0;
    
    for (int32_t i = 0; i < data_1004a380; i += 1)
    {
        if ((*(data_10049360 + (i << 2)) != 0 && (*(*(data_10049360 + (i << 2)) + 0xc) & 0x83) != 0))
        {
            __lock_file2(i, *(data_10049360 + (i << 2)));
            int32_t var_8_2 = 1;
            
            if ((*(*(data_10049360 + (i << 2)) + 0xc) & 0x83) != 0)
            {
                if (arg1 == 1)
                {
                    if (sub_1000d610(*(data_10049360 + (i << 2))) != 0xffffffff)
                        result_2 += 1;
                }
                else if (((arg1 == 0 && (*(*(data_10049360 + (i << 2)) + 0xc) & 2) != 0) && sub_1000d610(*(data_10049360 + (i << 2))) == 0xffffffff))
                    result_1 = 0xffffffff;
            }
            
            int32_t var_8_3 = 0;
            sub_1000d897(&__saved_ebp);
        }
    }
    
    int32_t var_8_4 = 0xfffffffe;
    sub_1000d8c4();
    int32_t result;
    
    if (arg1 != 1)
        result = result_1;
    else
        result = result_2;
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1000d897(void* arg1 @ ebp)
{
    return __unlock_file2(*(arg1 - 0x20), *(data_10049360 + (*(arg1 - 0x20) << 2)));
}

int32_t sub_1000d8c4()
{
    return __unlock(1);
}

int32_t sub_1000d900(int32_t* arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041b58;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_34 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result_1 = 0xffffffff;
    int32_t eax_2;
    eax_2 = arg1 != 0;
    
    if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2f, nullptr, u"(stream != NULL)") == 1))
        breakpoint();
    
    int32_t result;
    
    if (eax_2 != 0)
    {
        if ((arg1[3] & 0x40) == 0)
        {
            sub_10019550(arg1);
            int32_t var_8_1 = 0;
            result_1 = sub_1000da10(arg1);
            int32_t var_8_2 = 0xfffffffe;
            $LN19(&__saved_ebp);
        }
        else
            arg1[3] = 0;
        
        result = result_1;
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(stream != NULL)", u"fclose", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2f, 0);
        result = 0xffffffff;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t $LN19(void* arg1 @ ebp)
{
    return sub_100195f0(*(arg1 + 8));
}

int32_t sub_1000da10(int32_t* arg1)
{
    int32_t result = 0xffffffff;
    int32_t eax;
    eax = arg1 != 0;
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5a, nullptr, u"(str != NULL)") == 1))
        breakpoint();
    
    if (eax == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(str != NULL)", u"_fclose_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5a, 0);
        return 0xffffffff;
    }
    
    if ((arg1[3] & 0x83) != 0)
    {
        result = sub_1000d670(arg1);
        sub_1001bf40(arg1);
        
        if (sub_1001bc60(sub_10019e20(arg1)) < 0)
            result = 0xffffffff;
        else if (arg1[7] != 0)
        {
            sub_10011340(arg1[7], 2);
            arg1[7] = 0;
        }
    }
    
    arg1[3] = 0;
    return result;
}

uint32_t sub_1000db10(void* arg1, int32_t arg2, uint32_t arg3, int32_t* arg4)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041b78;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_34 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    uint32_t result;
    
    if ((arg2 == 0 || arg3 == 0))
        result = 0;
    else
    {
        int32_t eax_2;
        eax_2 = arg4 != 0;
        
        if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x4d, nullptr, u"(stream != NULL)") == 1))
            breakpoint();
        
        if (eax_2 != 0)
        {
            sub_10019550(arg4);
            int32_t var_8_1 = 0;
            uint32_t result_1 = sub_1000dc20(arg1, arg2, arg3, arg1, arg2, arg3, arg4);
            int32_t var_8_2 = 0xfffffffe;
            $LN13(&__saved_ebp);
            result = result_1;
        }
        else
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(stream != NULL)", u"fwrite", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x4d, 0);
            result = 0;
        }
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t $LN13(void* arg1 @ ebp)
{
    return sub_100195f0(*(arg1 + 0x14));
}

uint32_t __convention("regparm") sub_1000dc20(int32_t arg1, int32_t arg2, int32_t arg3, void* arg4, int32_t arg5, uint32_t arg6, int32_t* arg7)
{
    if ((arg5 == 0 || arg6 == 0))
        return 0;
    
    int32_t eax_1;
    eax_1 = arg7 != 0;
    
    if (eax_1 == 0)
    {
        int32_t eax_2;
        eax_2 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x71, nullptr, u"(stream != NULL)");
        
        if (eax_2 == 1)
            breakpoint();
    }
    
    if (eax_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(stream != NULL)", u"_fwrite_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x71, 0);
        return 0;
    }
    
    int32_t edx;
    edx = arg4 != 0;
    
    if (edx == 0)
    {
        int32_t eax_4;
        eax_4 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x72, nullptr, u"(buffer != NULL)");
        
        if (eax_4 == 1)
            breakpoint();
    }
    
    if (edx == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(buffer != NULL)", u"_fwrite_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x72, 0);
        return 0;
    }
    
    int32_t ecx = (arg3 - arg3);
    
    if ((ecx == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x73, nullptr, u"num <= (SIZE_MAX / size)") == 1))
        breakpoint();
    
    if (ecx == 0xffffffff)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"num <= (SIZE_MAX / size)", u"_fwrite_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x73, 0);
        return 0;
    }
    
    void* var_20_1 = arg4;
    uint32_t ecx_3 = (arg5 * arg6);
    uint32_t var_8_1 = ecx_3;
    int32_t var_14_1;
    
    if ((arg7[3] & 0x10c) == 0)
        var_14_1 = 0x1000;
    else
        var_14_1 = arg7[6];
    
    uint32_t eax;
    
    while (true)
    {
        if (var_8_1 == 0)
            return arg6;
        
        int32_t var_40;
        uint32_t var_3c;
        uint32_t var_38;
        int32_t var_24;
        uint32_t var_10;
        uint32_t var_c;
        
        if (((arg7[3] & 0x108) != 0 && arg7[1] != 0))
        {
            if (arg7[1] >= 0)
            {
                uint32_t var_34_1;
                
                if (var_8_1 >= arg7[1])
                    var_34_1 = arg7[1];
                else
                    var_34_1 = var_8_1;
                
                sub_10013c90(*arg7, var_20_1, var_34_1, var_40, var_3c, var_38, var_34_1, (ecx + 1), edx, eax_1, var_24, var_20_1, var_34_1, ecx_3, var_14_1, var_10, var_c, var_8_1);
                var_8_1 -= var_34_1;
                arg7[1] -= var_34_1;
                *arg7 += var_34_1;
                var_20_1 += var_34_1;
                continue;
            }
            
            if ((arg7[1] < 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x84, nullptr, u"("Inconsistent Stream Count. Flu…") == 1))
                breakpoint();
            
            arg7[3] |= 0x20;
            eax = (COMBINE(0, (ecx_3 - var_8_1)) / arg5);
            break;
        }
        
        if (var_8_1 < var_14_1)
        {
            var_24 = *var_20_1;
            int32_t* var_44_4 = arg7;
            
            if (sub_100162c0(var_24) == 0xffffffff)
            {
                eax = (COMBINE(0, (ecx_3 - var_8_1)) / arg5);
                break;
            }
            
            var_20_1 += 1;
            var_8_1 -= 1;
            
            if (arg7[6] <= 0)
                var_40 = 1;
            else
                var_40 = arg7[6];
            
            var_14_1 = var_40;
        }
        else
        {
            if (((arg7[3] & 0x108) != 0 && sub_1000d670(arg7) != 0))
            {
                eax = (COMBINE(0, (ecx_3 - var_8_1)) / arg5);
                break;
            }
            
            if (var_14_1 == 0)
                var_38 = var_8_1;
            else
                var_38 = (var_8_1 - (COMBINE(0, var_8_1) % var_14_1));
            
            var_c = sub_1001aef0(sub_10019e20(arg7), var_20_1, var_38);
            
            if (var_c == 0xffffffff)
            {
                arg7[3] |= 0x20;
                eax = (COMBINE(0, (ecx_3 - var_8_1)) / arg5);
                break;
            }
            
            if (var_c <= var_38)
                var_3c = var_c;
            else
                var_3c = var_38;
            
            var_10 = var_3c;
            var_8_1 -= var_10;
            var_20_1 += var_10;
            
            if (var_c < var_38)
            {
                arg7[3] |= 0x20;
                eax = (COMBINE(0, (ecx_3 - var_8_1)) / arg5);
                break;
            }
        }
    }
    
    return eax;
}

int32_t sub_1000e000(int32_t* arg1, int32_t arg2, enum SET_FILE_POINTER_MOVE_METHOD arg3)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041b98;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_38 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_3c = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t eax_2;
    eax_2 = arg1 != 0;
    
    if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x64, nullptr, u"(stream != NULL)") == 1))
        breakpoint();
    
    int32_t result;
    
    if (eax_2 != 0)
    {
        int32_t var_2c_1;
        
        if (((arg3 == FILE_BEGIN || arg3 == FILE_CURRENT) || arg3 == FILE_END))
            var_2c_1 = 1;
        else
            var_2c_1 = 0;
        
        if ((var_2c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x65, nullptr, u"((whence == SEEK_SET) || (whence…") == 1))
            breakpoint();
        
        if (var_2c_1 != 0)
        {
            sub_10019550(arg1);
            int32_t var_8_1 = 0;
            int32_t result_1 = sub_1000e170(arg1, arg2, arg3);
            int32_t var_8_2 = 0xfffffffe;
            $LN22(&__saved_ebp);
            result = result_1;
        }
        else
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"((whence == SEEK_SET) || (whence…", u"fseek", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x65, 0);
            result = 0xffffffff;
        }
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(stream != NULL)", u"fseek", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x64, 0);
        result = 0xffffffff;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t $LN22(void* arg1 @ ebp)
{
    return sub_100195f0(*(arg1 + 8));
}

int32_t sub_1000e170(int32_t* arg1, int32_t arg2, enum SET_FILE_POINTER_MOVE_METHOD arg3)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if ((arg1[3] & 0x83) == 0)
    {
        *sub_1000eca0() = 0x16;
        return 0xffffffff;
    }
    
    arg1[3] &= 0xffffffef;
    
    if (arg3 == FILE_CURRENT)
    {
        arg2 += sub_1001c2e0(arg1);
        arg3 = FILE_BEGIN;
    }
    
    sub_1000d670(arg1);
    
    if ((arg1[3] & 0x80) != 0)
        arg1[3] &= 0xfffffffc;
    else if (((arg1[3] & 1) != 0 && ((arg1[3] & 8) != 0 && (arg1[3] & 0x400) == 0)))
        arg1[6] = 0x200;
    
    int32_t eax_16 = (sub_1001bfd0(sub_10019e20(arg1), arg2, arg3) + 1);
    int32_t eax_17 = -(eax_16);
    return (-((eax_17 - eax_17)) - 1);
}

int32_t sub_1000e250(void* arg1, int32_t* arg2)
{
    int32_t eax;
    eax = arg1 != 0;
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2d, nullptr, u"(stream != NULL)") == 1))
        breakpoint();
    
    if (eax == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(stream != NULL)", u"fgetpos", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2d, 0);
        return 0xffffffff;
    }
    
    int32_t edx_1;
    edx_1 = arg2 != 0;
    
    if ((edx_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2e, nullptr, u"(pos != NULL)") == 1))
        breakpoint();
    
    if (edx_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(pos != NULL)", u"fgetpos", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2e, 0);
        return 0xffffffff;
    }
    
    int32_t eax_6;
    int32_t edx_2;
    eax_6 = sub_1001c5b0(arg1);
    *arg2 = eax_6;
    arg2[1] = edx_2;
    
    if ((*arg2 & arg2[1]) == 0xffffffff)
        return 0xffffffff;
    
    return 0;
}

int32_t sub_1000e360(int32_t* arg1, int32_t* arg2)
{
    int32_t eax;
    eax = arg1 != 0;
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2a, nullptr, u"(stream != NULL)") == 1))
        breakpoint();
    
    if (eax == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(stream != NULL)", u"fsetpos", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2a, 0);
        return 0xffffffff;
    }
    
    int32_t edx_1;
    edx_1 = arg2 != 0;
    
    if ((edx_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2b, nullptr, u"(pos != NULL)") == 1))
        breakpoint();
    
    if (edx_1 != 0)
        return sub_1001cc00(arg1, *arg2, arg2[1], FILE_BEGIN);
    
    *sub_1000eca0() = 0x16;
    sub_1000c310(u"(pos != NULL)", u"fsetpos", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2b, 0);
    return 0xffffffff;
}

int32_t sub_1000e450(void** arg1, void* arg2, int32_t arg3, int32_t arg4)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041bb8;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_44 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_48 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result_1 = 0;
    int32_t eax_2;
    eax_2 = arg1 != 0;
    
    if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x36, nullptr, u"(str != NULL)") == 1))
        breakpoint();
    
    int32_t result;
    
    if (eax_2 != 0)
    {
        int32_t var_34_1;
        
        if (((arg3 == 4 || arg3 == 0) || arg3 == 0x40))
            var_34_1 = 1;
        else
            var_34_1 = 0;
        
        if ((var_34_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3c, nullptr, u"(type == _IONBF) || (type == _IO…") == 1))
            breakpoint();
        
        if (var_34_1 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(type == _IONBF) || (type == _IO…", u"setvbuf", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3c, 0);
            result = 0xffffffff;
        }
        else if ((arg3 == 0 || arg3 == 0x40))
        {
            int32_t var_38_1;
            
            if ((arg4 < 2 || arg4 > 0x7fffffff))
                var_38_1 = 0;
            else
                var_38_1 = 1;
            
            if ((var_38_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x40, nullptr, u"((2 <= size) && (size <= INT_MAX…") == 1))
                breakpoint();
            
            if (var_38_1 != 0)
                goto label_1000e5fc;
            
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"((2 <= size) && (size <= INT_MAX…", u"setvbuf", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x40, 0);
            result = 0xffffffff;
        }
        else
        {
        label_1000e5fc:
            arg4 &= 0xfffffffe;
            sub_10019550(arg1);
            int32_t var_8_1 = 0;
            sub_1000d670(arg1);
            sub_1001bf40(arg1);
            arg1[3] &= 0xffffc2f3;
            
            if ((arg3 & 4) == 0)
            {
                if (arg2 != 0)
                {
                    arg1[3] |= 0x500;
                    goto label_1000e6d2;
                }
                
                arg2 = __malloc_dbg(arg4, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x78);
                
                if (arg2 != 0)
                {
                    arg1[3] |= 0x408;
                    goto label_1000e6d2;
                }
                
                data_10045b48 += 1;
                result_1 = 0xffffffff;
            }
            else
            {
                arg1[3] |= 4;
                arg2 = &arg1[5];
                arg4 = 2;
            label_1000e6d2:
                arg1[6] = arg4;
                arg1[2] = arg2;
                *arg1 = arg2;
                arg1[1] = 0;
            }
            
            int32_t var_8_2 = 0xfffffffe;
            sub_1000e6fe(&__saved_ebp);
            result = result_1;
        }
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(str != NULL)", u"setvbuf", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x36, 0);
        result = 0xffffffff;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1000e6fe(void* arg1 @ ebp)
{
    return sub_100195f0(*(arg1 - 0x1c));
}

void* sub_1000e720(int32_t arg1)
{
    int32_t i;
    
    do
    {
        void* result = _malloc(arg1);
        
        if (result != 0)
            return result;
        
        i = sub_1001ce10(arg1);
    } while (i != 0);
    
    if ((data_10045600 & 1) == 0)
    {
        data_10045600 |= 1;
        sub_1000e7a0(&data_100455f4);
        sub_1000cf10(___p__environ);
    }
    
    void var_14;
    sub_10006a00(&var_14, &data_100455f4);
    sub_1000ed00(&var_14, &data_10042750);
    /* no return */
}

int32_t* __fastcall sub_1000e7a0(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    int32_t var_c = 1;
    sub_1000c120(arg1, &data_10044030);
    *arg1 = 0x10037f68;
    return arg1;
}

int32_t __stdcall sub_1000e7d0(int32_t arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if (arg1 == 1)
    {
        if (sub_1001d720(1) == 0)
            return 0;
        
        if (sub_10018c70() == 0)
        {
            sub_1001d7a0();
            return 0;
        }
        
        sub_1001d6a0();
        data_1004a3ac = GetCommandLineA();
        data_10045608 = sub_1001d480();
        
        if (sub_100198e0() < 0)
        {
            sub_10018e80();
            sub_1001d7a0();
            return 0;
        }
        
        if (sub_1001cff0() < 0)
        {
        label_1000e85e:
            __ioterm();
            sub_10018e80();
            sub_1001d7a0();
            return 0;
        }
        
        int32_t eax_8;
        int32_t ecx_1;
        int32_t edx_1;
        eax_8 = sub_1001ce50();
        
        if (eax_8 < 0)
            goto label_1000e85e;
        
        if (sub_10015540(eax_8, edx_1, ecx_1, 0) != 0)
            goto label_1000e85e;
        
        int32_t var_c_1 = 1;
        __CrtSetCheckCount();
        data_10045604 += 1;
    }
    else if (arg1 == 0)
    {
        if (data_10045604 <= 0)
            return 0;
        
        data_10045604 -= 1;
        
        if (data_10045b00 == 0)
            __cexit();
        
        if ((sub_10011f60(0xffffffff) & 0x20) != 0)
            sub_10012980();
        
        __ioterm();
        sub_10018e80();
        sub_1001d7a0();
    }
    else if (arg1 == 2)
    {
        sub_10018c20();
        void* eax_14 = sub_10010b10(1, 0x214, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0xce);
        
        if (eax_14 == 0)
            return 0;
        
        if (sub_10018b70(data_10045b40)(data_10044324, eax_14) == 0)
        {
            sub_10011340(eax_14, 2);
            return 0;
        }
        
        sub_10018ee0(eax_14, 0);
        *eax_14 = GetCurrentThreadId();
        *(eax_14 + 4) = 0xffffffff;
    }
    else if (arg1 == 3)
        sub_10019340(nullptr);
    
    return 1;
}

int32_t __stdcall _start(int32_t arg1, int32_t arg2, int32_t arg3)
{
    if (arg2 == 1)
        sub_1001d840();
    
    return sub_1000e9d0(arg1, arg2, arg3);
}

int32_t sub_1000e9d0(int32_t arg1, int32_t arg2, int32_t arg3)
{
    int32_t __saved_ebp_2;
    int32_t __saved_ebp_1 = __saved_ebp_2;
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t ebx;
    int32_t var_30 = ebx;
    int32_t esi;
    int32_t var_34 = esi;
    int32_t edi;
    int32_t var_38 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x10041bd8 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_3c = (__security_cookie_1 ^ &__saved_ebp);
    int32_t* esp_1 = &var_3c;
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_1c = &var_3c;
    int32_t var_20 = 1;
    int32_t result;
    
    if ((arg2 != 0 || data_10045604 != 0))
    {
        int32_t var_8_1 = 0;
        
        if ((arg2 == 1 || arg2 == 2))
        {
            if (var_20 != 0)
            {
                *(esp_1 - 4) = arg3;
                *(esp_1 - 8) = arg2;
                *(esp_1 - 0xc) = arg1;
                var_20 = sub_1000e7d0();
            }
            
            if (var_20 != 0)
                goto label_1000ea8c;
            
            int32_t var_28_1 = 0;
            int32_t var_8_2 = 0xfffffffe;
            result = 0;
        }
        else
        {
        label_1000ea8c:
            *(esp_1 - 4) = arg3;
            *(esp_1 - 8) = arg2;
            *(esp_1 - 0xc) = arg1;
            sub_10001010();
            int32_t result_1 = 1;
            
            if ((arg2 == 0 || arg2 == 3))
            {
                *(esp_1 - 4) = arg3;
                *(esp_1 - 8) = arg2;
                *(esp_1 - 0xc) = arg1;
                
                if (sub_1000e7d0() == 0)
                    result_1 = 0;
            }
            
            int32_t var_8_3 = 0xfffffffe;
            result = result_1;
        }
    }
    else
        result = 0;
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    *esp_1;
    esp_1[1];
    esp_1[2];
    esp_1[3];
    return result;
}

int32_t sub_1000eb35(void* arg1 @ ebp)
{
    *(arg1 - 0x20) = ***(arg1 - 0x14);
    return ___CppXcptFilter(*(arg1 - 0x20), *(arg1 - 0x14));
}

int32_t _swprintf_s(char* arg1, int32_t arg2, int32_t arg3)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    return sub_1000f4a0(arg1, arg2, arg3, 0, &arg_10);
}

int32_t __snwprintf_s(char* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    return sub_1000f710(arg1, arg2, arg3, arg4, 0, &arg_14);
}

void* ___acrt_errno_map_os_error(int32_t arg1)
{
    *sub_1000ecd0() = arg1;
    int32_t eax_1 = __get_errno_from_oserr(arg1);
    void* result = sub_1000eca0();
    *result = eax_1;
    return result;
}

int32_t __get_errno_from_oserr(int32_t arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    for (int32_t i = 0; i < 0x2d; i += 1)
    {
        if (arg1 == *((i << 3) + &data_10044038))
            return *((i << 3) + &data_1004403c);
    }
    
    if ((arg1 >= 0x13 && arg1 <= 0x24))
        return 0xd;
    
    if ((arg1 >= 0xbc && arg1 <= 0xca))
        return 8;
    
    return 0x16;
}

void* sub_1000eca0()
{
    int32_t ecx;
    int32_t var_8 = ecx;
    void* eax = sub_10019040();
    
    if (eax != 0)
        return (eax + 8);
    
    return &data_100441a0;
}

void* sub_1000ecd0()
{
    int32_t ecx;
    int32_t var_8 = ecx;
    void* eax = sub_10019040();
    
    if (eax != 0)
        return (eax + 0xc);
    
    return &data_100441a4;
}

void sub_1000ed00(int32_t arg1, int32_t* arg2) __noreturn
{
    int32_t edi;
    int32_t var_2c = edi;
    uint32_t dwExceptionCode;
    __builtin_memcpy(&dwExceptionCode, &data_10037fa8, 8);
    int32_t var_c = arg1;
    int32_t* var_8 = arg2;
    int32_t lpArguments;
    
    if ((arg2 != 0 && (*arg2 & 8) != 0))
        lpArguments = 0x1994000;
    
    uint32_t dwExceptionFlags;
    uint32_t nNumberOfArguments;
    RaiseException(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, &lpArguments);
    /* no return */
}

int32_t sub_1000ed60(int32_t arg1, PSTR arg2, int32_t arg3, void* arg4, int32_t arg5)
{
    int32_t var_8_1 = 0;
    return ___stdio_common_vfprintf_p(arg1, arg2, arg3, arg4, arg5, &arg_18);
}

int32_t ___stdio_common_vfprintf_p(int32_t arg1, PSTR arg2, int32_t arg3, void* arg4, int32_t arg5, int32_t arg6)
{
    return sub_10014380(arg1, arg2, arg3, arg4, arg5, arg6);
}

int32_t sub_1000edd0(int32_t arg1, int32_t arg2, int32_t arg3, void* arg4, char* arg5)
{
    __chkstk(0x1150);
    int32_t __saved_ebp;
    void* const var_14 = (__security_cookie ^ &__saved_ebp);
    int32_t var_8 = 0;
    int32_t var_10 = 0;
    
    if (arg5 != 0)
    {
        char var_1018_1 = 0;
        void lpFilename;
        
        if (GetModuleFileNameA(nullptr, &lpFilename, 0x104) == 0)
            sub_1000b4b0(sub_10010280(&lpFilename, 0x104, "<program name unknown>"), u"strcpy_s(szExeName, 260, "<progr…", u"__crtMessageWindowA", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13c, 0);
        
        void* var_c_3 = &lpFilename;
        void* var_8_3 = var_c_3;
        
        if (_strlen(var_8_3) > 0x40)
        {
            void* var_c_4 = ((var_c_3 + _strlen(var_c_3)) - 0x40);
            var_8_3 = nullptr;
            sub_1000b4b0(sub_1000ad50(0x145, (0x104 - (0x145 - &lpFilename)), data_100441b0, 3), u"memcpy_s(szShortProgName, sizeof…", u"__crtMessageWindowA", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x145, var_8_3);
        }
        
        if (arg4 != 0)
        {
            var_8_3 = arg4;
            
            if (_strlen(var_8_3) > 0x40)
                var_8_3 = ((arg4 + _strlen(arg4)) - 0x3d);
        }
        
        int32_t ecx_5 = *sub_1000eca0();
        *sub_1000eca0() = 0;
        char const* const var_1128_1;
        
        if (arg1 != 2)
            var_1128_1 = &data_10040802;
        else
            var_1128_1 = "\n\nFor information on how your …";
        
        char* var_112c_1;
        
        if (*arg5 == 0)
            var_112c_1 = &data_10040802;
        else
            var_112c_1 = arg5;
        
        char const* const var_1130_1;
        
        if ((*arg5 == 0 || arg1 != 2))
            var_1130_1 = &data_10040802;
        else
            var_1130_1 = "Expression: ";
        
        void* const var_1134_1;
        
        if (*arg5 == 0)
            var_1134_1 = &data_10040802;
        else
            var_1134_1 = &data_1003815c;
        
        int32_t var_1138_1;
        
        if (arg3 == 0)
            var_1138_1 = 0x10040802;
        else
            var_1138_1 = arg3;
        
        char const* const var_113c_1;
        
        if (arg3 == 0)
            var_113c_1 = &data_10040802;
        else
            var_113c_1 = "\nLine: ";
        
        int32_t var_1140_1;
        
        if (arg2 == 0)
            var_1140_1 = 0x10040802;
        else
            var_1140_1 = arg2;
        
        char const* const var_1144_1;
        
        if (arg2 == 0)
            var_1144_1 = &data_10040802;
        else
            var_1144_1 = "\nFile: ";
        
        void* var_1148_1;
        
        if (var_8_3 == 0)
        {
            void* var_114c_1;
            
            if (arg4 == 0)
                var_114c_1 = &data_10040802;
            else
                var_114c_1 = arg4;
            
            var_1148_1 = var_114c_1;
        }
        else
            var_1148_1 = var_8_3;
        
        void* const var_1150_1;
        
        if (var_8_3 == 0)
            var_1150_1 = &data_10040802;
        else
            var_1150_1 = &data_10037fc8;
        
        char const* const var_1154_1;
        
        if (arg4 == 0)
            var_1154_1 = &data_10040802;
        else
            var_1154_1 = "\nModule: ";
        
        char const* const var_8_6 = var_1128_1;
        char const* const var_10_4 = var_1130_1;
        var_14 = var_1134_1;
        int32_t var_18_3 = var_1138_1;
        char const* const var_1c_5 = var_113c_1;
        int32_t var_20_3 = var_1140_1;
        char const* const var_24_3 = var_1144_1;
        void* var_28_2 = var_1148_1;
        void* const var_2c_1 = var_1150_1;
        char const* const var_30_1 = var_1154_1;
        char* var_34_1 = var_112c_1;
        int32_t var_38_1 = &data_10037ff0[arg1];
        void var_1014;
        wchar16 const* const var_10_5 = __snwprintf_s(&var_1014, 0x1000, 0xfff, "Debug %s!\n\nProgram: %s%s%s%s%s…");
        
        if (var_10_5 < 0)
        {
            var_10_5 = u"f:\dd\vctools\crt_bld\self_x86\c…";
            var_14 = u"__crtMessageWindowA";
            sub_1000b4e0(*sub_1000eca0(), 0x16, 0x22, u"(*_errno())", var_14, var_10_5, 0x160, 0);
        }
        
        *sub_1000eca0() = ecx_5;
        
        if (var_10_5 < 0)
        {
            var_14 = u"__crtMessageWindowA";
            sub_1000b4b0(sub_10010280(&var_1014, 0x1000, "_CrtDbgReport: String too long o…"), u"strcpy_s(szOutMessage, 4096, "_C…", var_14, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x165, 0);
        }
        
        if (sub_1001dba0(&var_1014, "Microsoft Visual C++ Debug Libra…", 0x12012) == 3)
        {
            sub_10015b80(0x16);
            sub_100155e0(3);
        }
    }
    
    return sub_1000ac70((var_14 ^ &__saved_ebp));
}

char* sub_1000f1d0(char* arg1, char* arg2)
{
    char* edi = arg1;
    char* ecx = arg2;
    int32_t edx;
    
    while ((ecx & 3) != 0)
    {
        edx = *ecx;
        ecx = &ecx[1];
        
        if (edx == 0)
            goto label_1000f2c0;
        
        *edi = edx;
        edi = &edi[1];
    }
    
    while (true)
    {
        int32_t eax_1 = *ecx;
        edx = *ecx;
        ecx = &ecx[4];
        
        if ((((eax_1 ^ 0xffffffff) ^ (0x7efefeff + eax_1)) & 0x81010100) != 0)
        {
            if (edx == 0)
                break;
            
            if (*edx[1] == 0)
            {
                *edi = edx;
                return arg1;
            }
            
            if ((edx & 0xff0000) == 0)
            {
                *edi = edx;
                edi[2] = 0;
                return arg1;
            }
            
            if ((edx & 0xff000000) == 0)
            {
                *edi = edx;
                return arg1;
            }
        }
        
        *edi = edx;
        edi = &edi[4];
    }
    
label_1000f2c0:
    *edi = edx;
    return arg1;
}

char* _strcat(char* arg1, char* arg2)
{
    char* ecx = arg1;
    int32_t edi;
    int32_t var_4 = edi;
    void* edi_2;
    
    while ((ecx & 3) != 0)
    {
        char eax = *ecx;
        ecx = &ecx[1];
        
        if (eax == 0)
        {
        label_1000f233:
            edi_2 = &ecx[0xffffffff];
            goto label_1000f245;
        }
    }
    
    while (true)
    {
        int32_t eax_1 = *ecx;
        ecx = &ecx[4];
        
        if ((((eax_1 ^ 0xffffffff) ^ (0x7efefeff + eax_1)) & 0x81010100) != 0)
        {
            int32_t eax_4 = *(ecx - 4);
            
            if (eax_4 == 0)
            {
                edi_2 = &ecx[0xfffffffc];
                break;
            }
            
            if (*eax_4[1] == 0)
            {
                edi_2 = &ecx[0xfffffffd];
                break;
            }
            
            if ((eax_4 & 0xff0000) == 0)
            {
                edi_2 = &ecx[0xfffffffe];
                break;
            }
            
            if ((eax_4 & 0xff000000) == 0)
                goto label_1000f233;
        }
    }
    
label_1000f245:
    char* ecx_1 = arg2;
    int32_t edx;
    
    while ((ecx_1 & 3) != 0)
    {
        edx = *ecx_1;
        ecx_1 = &ecx_1[1];
        
        if (edx == 0)
            goto label_1000f2c0;
        
        *edi_2 = edx;
        edi_2 += 1;
    }
    
    while (true)
    {
        int32_t eax_5 = *ecx_1;
        edx = *ecx_1;
        ecx_1 = &ecx_1[4];
        
        if ((((eax_5 ^ 0xffffffff) ^ (0x7efefeff + eax_5)) & 0x81010100) != 0)
        {
            if (edx == 0)
                break;
            
            if (*edx[1] == 0)
            {
                *edi_2 = edx;
                return arg1;
            }
            
            if ((edx & 0xff0000) == 0)
            {
                *edi_2 = edx;
                *(edi_2 + 2) = 0;
                return arg1;
            }
            
            if ((edx & 0xff000000) == 0)
            {
                *edi_2 = edx;
                return arg1;
            }
        }
        
        *edi_2 = edx;
        edi_2 += 4;
    }
    
label_1000f2c0:
    *edi_2 = edx;
    return arg1;
}

int32_t sub_1000f2d0(int32_t arg1, void* arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6)
{
    void var_2c;
    void* var_c = &var_2c;
    int32_t ecx;
    ecx = arg4 != 0;
    
    if ((ecx == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x70, nullptr, u"(format != NULL)") == 1))
        breakpoint();
    
    if (ecx == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(format != NULL)", u"_vsnprintf_helper", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x70, 0);
        return 0xffffffff;
    }
    
    int32_t var_38_1;
    
    if ((arg3 == 0 || arg2 != 0))
        var_38_1 = 1;
    else
        var_38_1 = 0;
    
    if ((var_38_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x73, nullptr, u"(count == 0) || (string != NULL)") == 1))
        breakpoint();
    
    if (var_38_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(count == 0) || (string != NULL)", u"_vsnprintf_helper", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x73, 0);
        return 0xffffffff;
    }
    
    if (arg3 <= 0x7fffffff)
        *(var_c + 4) = arg3;
    else
        *(var_c + 4) = 0x7fffffff;
    
    *(var_c + 0xc) = 0x42;
    *(var_c + 8) = arg2;
    *var_c = arg2;
    int32_t result = arg1(var_c, arg4, arg5, arg6);
    
    if (arg2 == 0)
        return result;
    
    if (result >= 0)
    {
        *(var_c + 4) -= 1;
        uint32_t var_3c_1;
        
        if (*(var_c + 4) < 0)
        {
            void* var_40_2 = var_c;
            var_3c_1 = sub_100162c0(nullptr);
        }
        else
        {
            **var_c = 0;
            var_3c_1 = 0;
            *var_c += 1;
        }
        
        if (var_3c_1 != 0xffffffff)
            return result;
    }
    
    *((arg2 + arg3) - 1) = 0;
    
    if (*(var_c + 4) >= 0)
        return 0xffffffff;
    
    return 0xfffffffe;
}

int32_t sub_1000f4a0(char* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)
{
    int32_t var_8 = 0xffffffff;
    int32_t eax;
    eax = arg3 != 0;
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xe9, nullptr, u"format != NULL") == 1))
        breakpoint();
    
    if (eax == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"format != NULL", u"_vsprintf_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xe9, 0);
        return 0xffffffff;
    }
    
    int32_t var_18_1;
    
    if ((arg1 == 0 || arg2 <= 0))
        var_18_1 = 0;
    else
        var_18_1 = 1;
    
    if ((var_18_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xea, nullptr, u"string != NULL && sizeInBytes > …") == 1))
        breakpoint();
    
    if (var_18_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"string != NULL && sizeInBytes > …", u"_vsprintf_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xea, 0);
        return 0xffffffff;
    }
    
    int32_t result = sub_1000f2d0(sub_1001ddc0, arg1, arg2, arg3, arg4, arg5);
    
    if (result < 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            int32_t var_1c_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_1c_1 = (arg2 - 1);
            else
                var_1c_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, var_1c_1);
        }
    }
    
    if (result == 0xfffffffe)
    {
        int32_t var_20_1 = 0;
        
        if ((var_20_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xf4, nullptr, u"("Buffer too small", 0)") == 1))
            breakpoint();
        
        if (var_20_1 == 0)
        {
            *sub_1000eca0() = 0x22;
            sub_1000c310(u"("Buffer too small", 0)", u"_vsprintf_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xf4, 0);
            return 0xffffffff;
        }
    }
    
    if ((result >= 0 && (arg2 != 0xffffffff && (arg2 != 0x7fffffff && (result + 1) < arg2))))
    {
        int32_t var_24_1;
        
        if (data_100441c4 >= (arg2 - (result + 1)))
            var_24_1 = (arg2 - (result + 1));
        else
            var_24_1 = data_100441c4;
        
        sub_1000fae0(&arg1[(result + 1)], 0xfe, var_24_1);
    }
    
    return result;
}

int32_t sub_1000f710(char* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6)
{
    int32_t var_8 = 0xffffffff;
    int32_t var_c = 0;
    int32_t eax;
    eax = arg4 != 0;
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x115, nullptr, u"format != NULL") == 1))
        breakpoint();
    
    if (eax == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"format != NULL", u"_vsnprintf_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x115, 0);
        return 0xffffffff;
    }
    
    if ((arg3 == 0 && (arg1 == 0 && arg2 == 0)))
        return 0;
    
    int32_t var_1c_1;
    
    if ((arg1 == 0 || arg2 <= 0))
        var_1c_1 = 0;
    else
        var_1c_1 = 1;
    
    if ((var_1c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x11b, nullptr, u"string != NULL && sizeInBytes > …") == 1))
        breakpoint();
    
    if (var_1c_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"string != NULL && sizeInBytes > …", u"_vsnprintf_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x11b, 0);
        return 0xffffffff;
    }
    
    int32_t result;
    
    if (arg2 <= arg3)
    {
        int32_t edx_9 = *sub_1000eca0();
        result = sub_1000f2d0(sub_1001ddc0, arg1, arg2, arg4, arg5, arg6);
        arg1[(arg2 - 1)] = 0;
        
        if ((result == 0xfffffffe && arg3 == 0xffffffff))
        {
            if (*sub_1000eca0() == 0x22)
                *sub_1000eca0() = edx_9;
            
            return 0xffffffff;
        }
    }
    else
    {
        int32_t edx_2 = *sub_1000eca0();
        result = sub_1000f2d0(sub_1001ddc0, arg1, (arg3 + 1), arg4, arg5, arg6);
        
        if (result == 0xfffffffe)
        {
            if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && (arg3 + 1) < arg2)))
            {
                int32_t var_20_1;
                
                if (data_100441c4 >= (arg2 - (arg3 + 1)))
                    var_20_1 = (arg2 - (arg3 + 1));
                else
                    var_20_1 = data_100441c4;
                
                sub_1000fae0(&arg1[(arg3 + 1)], 0xfe, var_20_1);
            }
            
            if (*sub_1000eca0() == 0x22)
                *sub_1000eca0() = edx_2;
            
            return 0xffffffff;
        }
    }
    
    if (result >= 0)
    {
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && (result + 1) < arg2)))
        {
            int32_t var_2c_1;
            
            if (data_100441c4 >= (arg2 - (result + 1)))
                var_2c_1 = (arg2 - (result + 1));
            else
                var_2c_1 = data_100441c4;
            
            sub_1000fae0(&arg1[(result + 1)], 0xfe, var_2c_1);
        }
        
        if (result >= 0)
            return result;
        
        return 0xffffffff;
    }
    
    *arg1 = 0;
    
    if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
    {
        int32_t var_24_1;
        
        if (data_100441c4 >= (arg2 - 1))
            var_24_1 = (arg2 - 1);
        else
            var_24_1 = data_100441c4;
        
        sub_1000fae0(&arg1[1], 0xfe, var_24_1);
    }
    
    if (result == 0xfffffffe)
    {
        int32_t var_28_1 = 0;
        
        if ((var_28_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x142, nullptr, u"("Buffer too small", 0)") == 1))
            breakpoint();
        
        if (var_28_1 == 0)
        {
            *sub_1000eca0() = 0x22;
            sub_1000c310(u"("Buffer too small", 0)", u"_vsnprintf_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x142, 0);
        }
    }
    
    return 0xffffffff;
}

int32_t __vsnprintf_s(char* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)
{
    return sub_1000f710(arg1, arg2, arg3, arg4, 0, arg5);
}

char* sub_1000fae0(char* arg1, char arg2, int32_t arg3)
{
    int32_t i_3 = arg3;
    
    if (i_3 == 0)
        return arg1;
    
    int32_t eax;
    eax = arg2;
    
    if ((eax == 0 && (i_3 >= 0x100 && data_10049250 != 0)))
        /* tailcall */
        return sub_1001f350(arg1, arg2);
    
    char* edi = arg1;
    
    if (i_3 < 4)
    {
    label_1000fb4d:
        int32_t i;
        
        do
        {
            *edi = eax;
            edi = &edi[1];
            i = i_3;
            i_3 -= 1;
        } while (i != 1);
    }
    else
    {
        int32_t i_2 = (-(arg1) & 3);
        
        if (i_2 != 0)
        {
            i_3 -= i_2;
            int32_t i_1;
            
            do
            {
                *edi = eax;
                edi = &edi[1];
                i_1 = i_2;
                i_2 -= 1;
            } while (i_1 != 1);
        }
        
        eax *= 0x1010101;
        int32_t i_4 = i_3;
        i_3 &= 3;
        uint32_t ecx_5 = (i_4 >> 2);
        
        if (ecx_5 == 0)
            goto label_1000fb4d;
        
        int32_t ecx_6;
        edi = __memfill_u32(edi, eax, ecx_5);
        
        if (i_3 != 0)
            goto label_1000fb4d;
    }
    
    return arg1;
}

int32_t sub_1000fb60(int16_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    return sub_1000bc50(arg1, arg2, arg3, arg4, 0, &arg_14);
}

int32_t sub_1000fb90(int16_t* arg1, void* arg2, int16_t* arg3)
{
    int32_t var_1c;
    
    if ((arg1 == 0 || arg2 <= 0))
        var_1c = 0;
    else
        var_1c = 1;
    
    if ((var_1c == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x12, nullptr, u"((_Dst)) != NULL && ((_SizeInWor…") == 1))
        breakpoint();
    
    if (var_1c == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"((_Dst)) != NULL && ((_SizeInWor…", u"wcscpy_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x12, 0);
        return 0x16;
    }
    
    if (arg3 == 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            void* var_20_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_20_1 = (arg2 - 1);
            else
                var_20_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, (var_20_1 << 1));
        }
        
        int32_t eax_7;
        eax_7 = arg3 != 0;
        
        if ((eax_7 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13, nullptr, u"(((_Src))) != NULL") == 1))
            breakpoint();
        
        if (eax_7 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(((_Src))) != NULL", u"wcscpy_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13, 0);
            return 0x16;
        }
    }
    
    int16_t* var_8_1 = arg1;
    void* var_c_1 = arg2;
    bool cond:0_1;
    
    do
    {
        void* eax_10;
        eax_10 = *arg3;
        *var_8_1 = eax_10;
        uint32_t edx_6 = *var_8_1;
        var_8_1 = &var_8_1[1];
        arg3 = &arg3[1];
        
        if (edx_6 == 0)
            break;
        
        cond:0_1 = var_c_1 == 1;
        var_c_1 -= 1;
    } while (!(cond:0_1));
    
    if (var_c_1 == 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            void* var_24_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_24_1 = (arg2 - 1);
            else
                var_24_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, (var_24_1 << 1));
        }
        
        int32_t var_28_1 = 0;
        
        if ((var_28_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x1e, nullptr, u"(L"Buffer is too small" && 0)") == 1))
            breakpoint();
        
        if (var_28_1 == 0)
        {
            *sub_1000eca0() = 0x22;
            sub_1000c310(u"(L"Buffer is too small" && 0)", u"wcscpy_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x1e, 0);
            return 0x22;
        }
    }
    
    if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && ((arg2 - var_c_1) + 1) < arg2)))
    {
        void* var_2c_1;
        
        if (data_100441c4 >= (arg2 - ((arg2 - var_c_1) + 1)))
            var_2c_1 = (arg2 - ((arg2 - var_c_1) + 1));
        else
            var_2c_1 = data_100441c4;
        
        sub_1000fae0(&arg1[((arg2 - var_c_1) + 1)], 0xfe, (var_2c_1 << 1));
    }
    
    return 0;
}

int32_t sub_1000fe70(int16_t* arg1, void* arg2, int16_t* arg3, int32_t arg4)
{
    if ((arg4 == 0 && (arg1 == 0 && arg2 == 0)))
        return 0;
    
    int32_t var_1c_1;
    
    if ((arg1 == 0 || arg2 <= 0))
        var_1c_1 = 0;
    else
        var_1c_1 = 1;
    
    int32_t edx;
    
    if (var_1c_1 == 0)
    {
        int32_t eax_2;
        eax_2 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x18, nullptr, u"((_Dst)) != NULL && ((_SizeInWor…");
        
        if (eax_2 == 1)
            breakpoint();
    }
    
    if (var_1c_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"((_Dst)) != NULL && ((_SizeInWor…", u"wcsncpy_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x18, 0);
        return 0x16;
    }
    
    if (arg4 == 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            void* var_20_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_20_1 = (arg2 - 1);
            else
                var_20_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, (var_20_1 << 1));
        }
        
        return 0;
    }
    
    if (arg3 == 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            void* var_24_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_24_1 = (arg2 - 1);
            else
                var_24_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, (var_24_1 << 1));
        }
        
        int32_t ecx_8;
        ecx_8 = arg3 != 0;
        
        if (ecx_8 == 0)
        {
            int32_t eax_10;
            eax_10 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x1f, nullptr, u"(((_Src))) != NULL");
            
            if (eax_10 == 1)
                breakpoint();
        }
        
        if (ecx_8 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(((_Src))) != NULL", u"wcsncpy_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x1f, 0);
            return 0x16;
        }
    }
    
    int16_t* var_8_1 = arg1;
    void* var_c_1 = arg2;
    
    if (arg4 != 0xffffffff)
    {
        if ((__CrtGetReportHook() != 0 && arg4 >= arg2))
        {
            int32_t eax_18;
            eax_18 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2b, nullptr, u"Buffer is too small");
            
            if (eax_18 == 1)
                breakpoint();
        }
        
        bool cond:2_1;
        
        do
        {
            edx = *arg3;
            *var_8_1 = edx;
            uint32_t ecx_13 = *var_8_1;
            var_8_1 = &var_8_1[1];
            arg3 = &arg3[1];
            
            if (ecx_13 == 0)
                break;
            
            bool cond:1_1 = var_c_1 == 1;
            var_c_1 -= 1;
            
            if (cond:1_1)
                break;
            
            cond:2_1 = arg4 == 1;
            arg4 -= 1;
        } while (!(cond:2_1));
        
        if (arg4 == 0)
            *var_8_1 = 0;
    }
    else
    {
        bool cond:0_1;
        
        do
        {
            void* ecx_9;
            ecx_9 = *arg3;
            *var_8_1 = ecx_9;
            uint32_t eax_14 = *var_8_1;
            var_8_1 = &var_8_1[1];
            arg3 = &arg3[1];
            
            if (eax_14 == 0)
                break;
            
            cond:0_1 = var_c_1 == 1;
            var_c_1 -= 1;
        } while (!(cond:0_1));
    }
    
    if (var_c_1 == 0)
    {
        if (arg4 == 0xffffffff)
        {
            arg1[(arg2 - 1)] = 0;
            return 0x50;
        }
        
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            void* var_28_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_28_1 = (arg2 - 1);
            else
                var_28_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, (var_28_1 << 1));
        }
        
        int32_t var_2c_1 = 0;
        
        if ((var_2c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3e, nullptr, u"(L"Buffer is too small" && 0)") == 1))
            breakpoint();
        
        if (var_2c_1 == 0)
        {
            *sub_1000eca0() = 0x22;
            sub_1000c310(u"(L"Buffer is too small" && 0)", u"wcsncpy_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3e, 0);
            return 0x22;
        }
    }
    
    if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && ((arg2 - var_c_1) + 1) < arg2)))
    {
        void* var_30_1;
        
        if (data_100441c4 >= (arg2 - ((arg2 - var_c_1) + 1)))
            var_30_1 = (arg2 - ((arg2 - var_c_1) + 1));
        else
            var_30_1 = data_100441c4;
        
        sub_1000fae0(&arg1[((arg2 - var_c_1) + 1)], 0xfe, (var_30_1 << 1));
    }
    
    return 0;
}

int32_t sub_10010280(char* arg1, void* arg2, char* arg3)
{
    int32_t var_1c;
    
    if ((arg1 == 0 || arg2 <= 0))
        var_1c = 0;
    else
        var_1c = 1;
    
    if ((var_1c == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x12, nullptr, u"((_Dst)) != NULL && ((_SizeInByt…") == 1))
        breakpoint();
    
    if (var_1c == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"((_Dst)) != NULL && ((_SizeInByt…", u"strcpy_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x12, 0);
        return 0x16;
    }
    
    if (arg3 == 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            void* var_20_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_20_1 = (arg2 - 1);
            else
                var_20_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, var_20_1);
        }
        
        int32_t edx_4;
        edx_4 = arg3 != 0;
        
        if ((edx_4 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13, nullptr, u"(((_Src))) != NULL") == 1))
            breakpoint();
        
        if (edx_4 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(((_Src))) != NULL", u"strcpy_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13, 0);
            return 0x16;
        }
    }
    
    char* var_8_1 = arg1;
    void* var_c_1 = arg2;
    bool cond:0_1;
    
    do
    {
        void* edx_5;
        edx_5 = *arg3;
        *var_8_1 = edx_5;
        int32_t ecx_6 = *var_8_1;
        var_8_1 = &var_8_1[1];
        arg3 = &arg3[1];
        
        if (ecx_6 == 0)
            break;
        
        cond:0_1 = var_c_1 == 1;
        var_c_1 -= 1;
    } while (!(cond:0_1));
    
    if (var_c_1 == 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            void* var_24_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_24_1 = (arg2 - 1);
            else
                var_24_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, var_24_1);
        }
        
        int32_t var_28_1 = 0;
        
        if ((var_28_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x1e, nullptr, u"(L"Buffer is too small" && 0)") == 1))
            breakpoint();
        
        if (var_28_1 == 0)
        {
            *sub_1000eca0() = 0x22;
            sub_1000c310(u"(L"Buffer is too small" && 0)", u"strcpy_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x1e, 0);
            return 0x22;
        }
    }
    
    if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && ((arg2 - var_c_1) + 1) < arg2)))
    {
        void* var_2c_1;
        
        if (data_100441c4 >= (arg2 - ((arg2 - var_c_1) + 1)))
            var_2c_1 = (arg2 - ((arg2 - var_c_1) + 1));
        else
            var_2c_1 = data_100441c4;
        
        sub_1000fae0(&arg1[((arg2 - var_c_1) + 1)], 0xfe, var_2c_1);
    }
    
    return 0;
}

void* sub_10010560(int32_t arg1, int32_t arg2)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    return sub_10010b10(arg1, arg2, 1, 0, 0);
}

void* __malloc_dbg(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    return sub_100105c0(arg1, data_10045c7c, arg2, arg3, arg4);
}

void* sub_100105c0(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)
{
    int32_t var_8 = 0;
    void* result = __nh_malloc_dbg_impl(arg1, arg2, arg3, arg4, arg5, &var_8);
    
    if (((result == 0 && var_8 != 0) && sub_1000eca0() != 0))
    {
        void* eax_2 = sub_1000eca0();
        *eax_2 = var_8;
    }
    
    return result;
}

void* __nh_malloc_dbg_impl(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t* arg6)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t i;
    
    do
    {
        void* result = sub_10010690(arg1, arg3, arg4, arg5, arg6);
        
        if (result != 0)
            return result;
        
        if (arg2 == 0)
        {
            *arg6 = 0xc;
            return result;
        }
        
        i = sub_1001ce10(arg1);
    } while (i != 0);
    *arg6 = 0xc;
    return nullptr;
}

void* sub_10010690(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t* arg5)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041bf8;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_3c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_20 = 0;
    void* result = nullptr;
    __lock(4);
    int32_t var_8_1 = 0;
    
    if (data_10045638 > 0)
    {
        if (data_10045620 != (data_10045638 - 1))
            data_10045620 += 1;
        else
        {
            if ((sub_10011b00() == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x179, nullptr, u"_CrtCheckMemory()") == 1))
                breakpoint();
            
            data_10045620 = 0;
        }
    }
    
    int32_t eax_6 = data_100441c8;
    
    if ((data_100441cc != 0xffffffff && eax_6 == data_100441cc))
        breakpoint();
    
    int32_t eax_9;
    int32_t __saved_ebp;
    
    if (data_10044320 != 0)
        eax_9 = data_10044320(1, 0, arg1, arg2, eax_6, arg3, arg4, (__security_cookie_1 ^ &__saved_ebp));
    
    if ((data_10044320 == 0 || eax_9 != 0))
    {
        if ((arg2 != 2 && (data_100441c0 & 1) == 0))
            var_20 = 1;
        
        if (arg1 <= 0xffffffbc)
        {
            if ((arg2 != 4 && (arg2 != 1 && (arg2 != 2 && arg2 != 3))))
            {
                char const* const var_44_5 = "Error: memory allocation: bad me…";
                
                if (sub_1000ed60(1, nullptr, 0, nullptr, &data_100363c4) == 1)
                    breakpoint();
            }
            
            void* eax_17 = sub_1001f6c0((arg1 + 0x24));
            
            if (eax_17 != 0)
            {
                data_100441c8 += 1;
                
                if (var_20 == 0)
                {
                    if ((0xffffffff - data_10045618) <= arg1)
                        data_10045618 = 0xffffffff;
                    else
                        data_10045618 += arg1;
                    
                    data_10045630 += arg1;
                    
                    if (data_10045630 > data_10045624)
                        data_10045624 = data_10045630;
                    
                    if (data_10045628 == 0)
                        data_1004561c = eax_17;
                    else
                        *(data_10045628 + 4) = eax_17;
                    
                    *eax_17 = data_10045628;
                    *(eax_17 + 4) = 0;
                    *(eax_17 + 8) = arg3;
                    *(eax_17 + 0xc) = arg4;
                    *(eax_17 + 0x10) = arg1;
                    *(eax_17 + 0x14) = arg2;
                    *(eax_17 + 0x18) = eax_6;
                    data_10045628 = eax_17;
                }
                else
                {
                    *eax_17 = 0;
                    *(eax_17 + 4) = 0;
                    *(eax_17 + 8) = 0;
                    *(eax_17 + 0xc) = 0xfedcbabc;
                    *(eax_17 + 0x10) = arg1;
                    *(eax_17 + 0x14) = 3;
                    *(eax_17 + 0x18) = 0;
                }
                
                sub_1000fae0((eax_17 + 0x1c), data_100441d0, 4);
                sub_1000fae0(((eax_17 + arg1) + 0x20), data_100441d0, 4);
                sub_1000fae0((eax_17 + 0x20), data_100441d3, arg1);
                result = (eax_17 + 0x20);
            }
            else
                *arg5 = 0xc;
        }
        else
        {
            int32_t var_44_4 = arg1;
            
            if (sub_1000ed60(1, nullptr, 0, nullptr, "Invalid allocation size: %Iu byt…") == 1)
                breakpoint();
            
            *arg5 = 0xc;
        }
    }
    else if (arg3 == 0)
    {
        char const* const var_44_3 = "Client hook allocation failure.\n";
        
        if (sub_1000ed60(0, nullptr, 0, nullptr, &data_100363c4) == 1)
            breakpoint();
    }
    else
    {
        int32_t var_44_2 = arg4;
        int32_t var_48_2 = arg3;
        
        if (sub_1000ed60(0, nullptr, 0, nullptr, "Client hook allocation failure a…") == 1)
            breakpoint();
    }
    
    int32_t var_8_2 = 0xfffffffe;
    sub_10010a20();
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10010a20()
{
    return __unlock(4);
}

void* sub_10010a40(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t* arg6)
{
    if (arg1 > 0)
    {
        uint32_t temp0_1 = (COMBINE(0, 0xffffffe0) / arg1);
        uint32_t eax_3 = (temp0_1 - temp0_1);
        
        if ((eax_3 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x248, nullptr, u"(_HEAP_MAXREQ / nNum) >= nSize") == 1))
            breakpoint();
        
        if (eax_3 == 0xffffffff)
        {
            *sub_1000eca0() = 0xc;
            sub_1000c310(u"(_HEAP_MAXREQ / nNum) >= nSize", u"_calloc_dbg_impl", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x248, 0);
            return nullptr;
        }
    }
    
    int32_t edx_4 = (arg2 * arg1);
    void* result = __nh_malloc_dbg_impl(edx_4, data_10045c7c, arg3, arg4, arg5, arg6);
    
    if (result != 0)
        sub_1000fae0(result, 0, edx_4);
    
    return result;
}

void* sub_10010b10(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)
{
    int32_t var_8 = 0;
    void* result = sub_10010a40(arg1, arg2, arg3, arg4, arg5, &var_8);
    
    if (((result == 0 && var_8 != 0) && sub_1000eca0() != 0))
    {
        void* eax_2 = sub_1000eca0();
        *eax_2 = var_8;
    }
    
    return result;
}

void* sub_10010b70(int32_t arg1, int32_t arg2, int32_t arg3)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    return sub_10011240(arg1, arg2, arg3, 1, 0, 0);
}

void* __CrtSetDbgBlockType(int32_t arg1, void* arg2, int32_t arg3, int32_t arg4)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041c18;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_2c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_30 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    __lock(4);
    int32_t var_8_1 = 0;
    void* result = sub_10010c40(arg1, &arg_8, arg2, arg3, arg4, 1);
    int32_t var_8_2 = 0xfffffffe;
    sub_10010c12();
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10010c12()
{
    return __unlock(4);
}

void* sub_10010c40(int32_t arg1, int32_t* arg2, void* arg3, int32_t arg4, int32_t arg5, int32_t arg6)
{
    int32_t var_c = 0;
    void* ecx = *arg2;
    
    if (arg1 == 0)
        return __malloc_dbg(ecx, arg3, arg4, arg5);
    
    if ((arg6 != 0 && ecx == 0))
    {
        sub_10011340(arg1, arg3);
        return nullptr;
    }
    
    if (data_10045638 > 0)
    {
        if (data_10045620 != (data_10045638 - 1))
            data_10045620 += 1;
        else
        {
            if ((sub_10011b00() == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2ca, nullptr, u"_CrtCheckMemory()") == 1))
                breakpoint();
            
            data_10045620 = 0;
        }
    }
    
    int32_t edx_5 = data_100441c8;
    
    if ((data_100441cc != 0xffffffff && edx_5 == data_100441cc))
        breakpoint();
    
    if ((data_10044320 != 0 && data_10044320(2, arg1, ecx, arg3, edx_5, arg4, arg5, edx_5) == 0))
    {
        if (arg4 == 0)
        {
            char const* const var_20_5 = "Client hook re-allocation failur…";
            
            if (sub_1000ed60(0, nullptr, 0, nullptr, &data_100363c4) == 1)
                breakpoint();
        }
        else
        {
            int32_t var_20_4 = arg5;
            int32_t var_24_4 = arg4;
            
            if (sub_1000ed60(0, nullptr, 0, nullptr, "Client hook re-allocation failur…") == 1)
                breakpoint();
        }
        
        return nullptr;
    }
    
    if (ecx > 0xffffffbc)
    {
        if (arg4 == 0)
        {
            void* var_20_7 = ecx;
            
            if (sub_1000ed60(1, nullptr, 0, nullptr, "Invalid allocation size: %Iu byt…") == 1)
                breakpoint();
        }
        else
        {
            int32_t var_20_6 = arg5;
            int32_t var_24_5 = arg4;
            void* var_28_3 = ecx;
            
            if (sub_1000ed60(1, nullptr, 0, nullptr, "Invalid allocation size: %Iu byt…") == 1)
                breakpoint();
        }
        
        *sub_1000eca0() = 0xc;
        return nullptr;
    }
    
    if (((arg3 == 1 || arg3 == 4) || arg3 == 2))
    {
        if (sub_10011ab0(((arg1 & 0xfffffffc) - 4), data_100441d1, 4) != 0)
        {
            int32_t var_20_10 = arg1;
            
            if (sub_1000ed60(1, nullptr, 0, nullptr, "The Block at 0x%p was allocated …") == 1)
                breakpoint();
            
            *sub_1000eca0() = 0x16;
            return nullptr;
        }
    }
    else if (arg4 == 0)
    {
        char const* const var_20_9 = "Error: memory allocation: bad me…";
        
        if (sub_1000ed60(1, nullptr, 0, nullptr, &data_100363c4) == 1)
            breakpoint();
    }
    else
    {
        int32_t var_20_8 = arg5;
        int32_t var_24_6 = arg4;
        
        if (sub_1000ed60(1, nullptr, 0, nullptr, "Error: memory allocation: bad me…") == 1)
            breakpoint();
    }
    
    if ((sub_100120c0(arg1) == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x311, nullptr, u"_CrtIsValidHeapPointer(pUserData…") == 1))
        breakpoint();
    
    if (*(arg1 - 0xc) == 3)
        var_c = 1;
    
    if (var_c == 0)
    {
        if ((*(arg1 - 0xc) == 2 && arg3 == 1))
            arg3 = 2;
        
        if (data_10045618 < *(arg1 - 0x10))
        {
            int32_t var_20_12 = arg1;
            
            if (sub_1000ed60(1, nullptr, 0, nullptr, "Error: possible heap corruption …") == 1)
                breakpoint();
            
            *sub_1000eca0() = 0x16;
            return nullptr;
        }
    }
    else if (((*(arg1 - 0x14) != 0xfedcbabc || *(arg1 - 8) != 0) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x31b, nullptr, u"pOldBlock->nLine == IGNORE_LINE …") == 1))
        breakpoint();
    
    int32_t* var_14_1;
    
    if (arg6 == 0)
    {
        var_14_1 = sub_1001f780((arg1 - 0x20), (ecx + 0x24));
        
        if (var_14_1 == 0)
            return nullptr;
    }
    else
    {
        var_14_1 = sub_1001fa50((arg1 - 0x20), (ecx + 0x24));
        
        if (var_14_1 == 0)
            return nullptr;
    }
    
    data_100441c8 += 1;
    
    if (var_c == 0)
    {
        if (data_10045618 < 0xffffffff)
        {
            data_10045618 -= var_14_1[4];
            
            if ((0xffffffff - data_10045618) <= ecx)
                data_10045618 = 0xffffffff;
            else
                data_10045618 += ecx;
        }
        
        data_10045630 -= var_14_1[4];
        data_10045630 += ecx;
        
        if (data_10045630 > data_10045624)
            data_10045624 = data_10045630;
    }
    
    if (ecx > var_14_1[4])
        sub_1000fae0((&var_14_1[8] + var_14_1[4]), data_100441d3, (ecx - var_14_1[4]));
    
    sub_1000fae0((&var_14_1[8] + ecx), data_100441d0, 4);
    
    if (var_c == 0)
    {
        var_14_1[2] = arg4;
        var_14_1[3] = arg5;
        var_14_1[6] = edx_5;
    }
    
    var_14_1[4] = ecx;
    
    if (((arg6 == 0 && (arg6 != 0 || var_14_1 != (arg1 - 0x20))) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x383, nullptr, u"fRealloc || (!fRealloc && pNewBl…") == 1))
        breakpoint();
    
    if ((var_14_1 == (arg1 - 0x20) || var_c != 0))
        return &var_14_1[8];
    
    if (*var_14_1 == 0)
    {
        if ((data_1004561c != (arg1 - 0x20) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x394, nullptr, u"_pLastBlock == pOldBlock") == 1))
            breakpoint();
        
        data_1004561c = var_14_1[1];
    }
    else
        *(*var_14_1 + 4) = var_14_1[1];
    
    if (var_14_1[1] == 0)
    {
        if ((data_10045628 != (arg1 - 0x20) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x39f, nullptr, u"_pFirstBlock == pOldBlock") == 1))
            breakpoint();
        
        data_10045628 = *var_14_1;
    }
    else
        *var_14_1[1] = *var_14_1;
    
    if (data_10045628 == 0)
        data_1004561c = var_14_1;
    else
        *(data_10045628 + 4) = var_14_1;
    
    *var_14_1 = data_10045628;
    var_14_1[1] = 0;
    data_10045628 = var_14_1;
    return &var_14_1[8];
}

void* sub_10011240(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6)
{
    int32_t var_8 = 0;
    int32_t var_c = 0;
    int32_t var_10 = 0;
    
    if (arg2 > 0)
    {
        uint32_t temp0_1 = (COMBINE(0, 0xffffffe0) / arg2);
        uint32_t eax_3 = (temp0_1 - temp0_1);
        
        if ((eax_3 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x441, nullptr, u"(_HEAP_MAXREQ / count) >= size") == 1))
            breakpoint();
        
        if (eax_3 == 0xffffffff)
        {
            *sub_1000eca0() = 0xc;
            sub_1000c310(u"(_HEAP_MAXREQ / count) >= size", u"_recalloc_dbg", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x441, 0);
            return nullptr;
        }
    }
    
    void* edx_4 = (arg3 * arg2);
    
    if (arg1 != 0)
        var_c = __msize(arg1);
    
    int32_t var_18_2 = arg6;
    void* result = __CrtSetDbgBlockType(arg1, edx_4, arg4, arg5);
    
    if ((result != 0 && var_c < edx_4))
        sub_1000fae0((result + var_c), 0, (edx_4 - var_c));
    
    return result;
}

int32_t sub_10011340(int32_t arg1, void* arg2)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041c38;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_28 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_2c = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_8_1 = 0;
    sub_100113c0(arg2, __lock(4), arg1, arg1, arg2);
    int32_t var_8_2 = 0xfffffffe;
    int32_t result = sub_100113a1();
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_100113a1()
{
    return __unlock(4);
}

void __convention("regparm") sub_100113c0(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)
{
    if (data_10045638 > 0)
    {
        if (data_10045620 != (data_10045638 - 1))
            data_10045620 += 1;
        else
        {
            if ((sub_10011b00() == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x503, nullptr, u"_CrtCheckMemory()") == 1))
                breakpoint();
            
            data_10045620 = 0;
        }
    }
    
    if (arg4 != 0)
    {
        if (arg5 != 1)
        {
        label_1001148b:
            int32_t eax_4;
            
            if (data_10044320 != 0)
                eax_4 = data_10044320(3, arg4, 0, arg5, 0, 0, 0, arg3);
            
            if ((data_10044320 == 0 || eax_4 != 0))
            {
                if ((sub_100120c0(arg4) == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x525, nullptr, u"_CrtIsValidHeapPointer(pUserData…") == 1))
                    breakpoint();
                
                if (((*(arg4 - 0xc) != 4 && (*(arg4 - 0xc) != 1 && (*(arg4 - 0xc) != 2 && *(arg4 - 0xc) != 3))) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x52b, nullptr, u"_BLOCK_TYPE_IS_VALID(pHead->nBlo…") == 1))
                    breakpoint();
                
                if ((data_100441c0 & 4) == 0)
                {
                    if (sub_10011ab0((arg4 - 4), data_100441d0, 4) == 0)
                    {
                        if (*(arg4 - 0x18) == 0)
                        {
                            void* var_c_5 = arg4;
                            int32_t var_10_4 = *(arg4 - 8);
                            int32_t var_14_4 = &data_10038608[*(arg4 - 0xc)];
                            
                            if (sub_1000ed60(1, nullptr, 0, nullptr, "HEAP CORRUPTION DETECTED: before…") == 1)
                                breakpoint();
                        }
                        else
                        {
                            int32_t var_c_4 = *(arg4 - 0x14);
                            int32_t var_10_3 = *(arg4 - 0x18);
                            void* var_14_3 = arg4;
                            int32_t var_18_2 = *(arg4 - 8);
                            int32_t var_1c_1 = &data_10038608[*(arg4 - 0xc)];
                            
                            if (sub_1000ed60(1, nullptr, 0, nullptr, "HEAP CORRUPTION DETECTED: before…") == 1)
                                breakpoint();
                        }
                    }
                    
                    if (sub_10011ab0(&(arg4 - 0x20)[(*(arg4 - 0x10) + 0x20)], data_100441d0, 4) == 0)
                    {
                        if (*(arg4 - 0x18) == 0)
                        {
                            void* var_c_7 = arg4;
                            int32_t var_10_7 = *(arg4 - 8);
                            int32_t var_14_7 = &data_10038608[*(arg4 - 0xc)];
                            
                            if (sub_1000ed60(1, nullptr, 0, nullptr, "HEAP CORRUPTION DETECTED: after …") == 1)
                                breakpoint();
                        }
                        else
                        {
                            int32_t var_c_6 = *(arg4 - 0x14);
                            int32_t var_10_6 = *(arg4 - 0x18);
                            void* var_14_6 = arg4;
                            int32_t var_18_3 = *(arg4 - 8);
                            int32_t var_1c_2 = &data_10038608[*(arg4 - 0xc)];
                            
                            if (sub_1000ed60(1, nullptr, 0, nullptr, "HEAP CORRUPTION DETECTED: after …") == 1)
                                breakpoint();
                        }
                    }
                }
                
                if (*(arg4 - 0xc) != 3)
                {
                    if ((*(arg4 - 0xc) == 2 && arg5 == 1))
                        arg5 = 2;
                    
                    if ((*(arg4 - 0xc) != arg5 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x572, nullptr, u"pHead->nBlockUse == nBlockUse") == 1))
                        breakpoint();
                    
                    data_10045630 -= *(arg4 - 0x10);
                    
                    if ((data_100441c0 & 2) != 0)
                    {
                        *(arg4 - 0xc) = 0;
                        sub_1000fae0(arg4, data_100441d2, *(arg4 - 0x10));
                    }
                    else
                    {
                        if (*(arg4 - 0x20) == 0)
                        {
                            if ((data_1004561c != (arg4 - 0x20) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x581, nullptr, u"_pLastBlock == pHead") == 1))
                                breakpoint();
                            
                            data_1004561c = *(arg4 - 0x1c);
                        }
                        else
                            *(*(arg4 - 0x20) + 4) = *(arg4 - 0x1c);
                        
                        if (*(arg4 - 0x1c) == 0)
                        {
                            if ((data_10045628 != (arg4 - 0x20) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x58b, nullptr, u"_pFirstBlock == pHead") == 1))
                                breakpoint();
                            
                            data_10045628 = *(arg4 - 0x20);
                        }
                        else
                            **(arg4 - 0x1c) = *(arg4 - 0x20);
                        
                        sub_1000fae0((arg4 - 0x20), data_100441d2, (*(arg4 - 0x10) + 0x24));
                        sub_1001fdf0((arg4 - 0x20));
                    }
                }
                else
                {
                    if (((*(arg4 - 0x14) != 0xfedcbabc || *(arg4 - 8) != 0) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x564, nullptr, u"pHead->nLine == IGNORE_LINE && p…") == 1))
                        breakpoint();
                    
                    sub_1000fae0((arg4 - 0x20), data_100441d2, (*(arg4 - 0x10) + 0x24));
                    sub_1001fdf0((arg4 - 0x20));
                }
            }
            else
            {
                char const* const var_c_2 = "Client hook free failure.\n";
                
                if (sub_1000ed60(0, nullptr, 0, nullptr, &data_100363c4) == 1)
                    breakpoint();
            }
        }
        else
        {
            if (sub_10011ab0(((arg4 & 0xfffffffc) - 4), data_100441d1, 4) == 0)
                goto label_1001148b;
            
            int32_t var_c_1 = arg4;
            
            if (sub_1000ed60(1, nullptr, 0, nullptr, "The Block at 0x%p was allocated …") == 1)
                breakpoint();
            
            *sub_1000eca0() = 0x16;
        }
    }
}

int32_t __msize(int32_t arg1)
{
    return sub_100118c0(arg1, 1);
}

int32_t sub_100118c0(int32_t arg1, int32_t arg2)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041c58;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_34 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_38 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t eax_2;
    eax_2 = arg1 != 0;
    
    if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5d3, nullptr, u"pUserData != NULL") == 1))
        breakpoint();
    
    int32_t result;
    
    if (eax_2 != 0)
    {
        if (data_10045638 > 0)
        {
            if (data_10045620 != (data_10045638 - 1))
                data_10045620 += 1;
            else
            {
                if ((sub_10011b00() == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5d9, nullptr, u"_CrtCheckMemory()") == 1))
                    breakpoint();
                
                data_10045620 = 0;
            }
        }
        
        __lock(4);
        int32_t var_8_1 = 0;
        
        if ((sub_100120c0(arg1) == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5e7, nullptr, u"_CrtIsValidHeapPointer(pUserData…") == 1))
            breakpoint();
        
        if (((*(arg1 - 0xc) != 4 && (*(arg1 - 0xc) != 1 && (*(arg1 - 0xc) != 2 && *(arg1 - 0xc) != 3))) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5ed, nullptr, u"_BLOCK_TYPE_IS_VALID(pHead->nBlo…") == 1))
            breakpoint();
        
        if ((*(arg1 - 0xc) == 2 && arg2 == 1))
            arg2 = 2;
        
        int32_t result_1 = *(arg1 - 0x10);
        int32_t var_8_2 = 0xfffffffe;
        sub_10011a86();
        result = result_1;
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"pUserData != NULL", u"_msize_dbg", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5d3, 0);
        result = 0xffffffff;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10011a86()
{
    return __unlock(4);
}

int32_t sub_10011ab0(char* arg1, char arg2, int32_t arg3)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t result = 1;
    
    while (true)
    {
        int32_t eax_1 = arg3;
        arg3 -= 1;
        
        if (eax_1 == 0)
            break;
        
        uint32_t ecx_3 = *arg1;
        arg1 = &arg1[1];
        
        if (ecx_3 != arg2)
            result = 0;
    }
    
    return result;
}

int32_t sub_10011b00()
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_40 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x10041c78 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_44 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result;
    
    if ((data_100441c0 & 1) != 0)
    {
        __lock(4);
        int32_t var_8_1 = 0;
        int32_t eax_4 = sub_1001ff20();
        int32_t result_1;
        
        if ((eax_4 == 0xffffffff || eax_4 == 0xfffffffe))
        {
            result_1 = 1;
            
            for (int32_t* i = data_10045628; i != 0; i = *i)
            {
                int32_t var_2c_1 = 1;
                char const* const var_30_1;
                
                if ((((i[5] == 4 || i[5] == 1) || i[5] == 2) || i[5] == 3))
                    var_30_1 = &data_10038608[i[5]];
                else
                    var_30_1 = "DAMAGED";
                
                if (sub_10011ab0(&i[7], data_100441d0, 4) == 0)
                {
                    if (i[2] == 0)
                    {
                        void* var_48_7 = &i[8];
                        int32_t var_4c_3 = i[6];
                        char const* const var_50_3 = var_30_1;
                        
                        if (sub_1000ed60(0, nullptr, 0, nullptr, "HEAP CORRUPTION DETECTED: before…") == 1)
                            breakpoint();
                    }
                    else
                    {
                        int32_t var_48_6 = i[3];
                        int32_t var_4c_2 = i[2];
                        void* var_50_2 = &i[8];
                        int32_t var_54_1 = i[6];
                        char const* const var_58_1 = var_30_1;
                        
                        if (sub_1000ed60(0, nullptr, 0, nullptr, "HEAP CORRUPTION DETECTED: before…") == 1)
                            breakpoint();
                    }
                    
                    var_2c_1 = 0;
                }
                
                if (sub_10011ab0(((i + i[4]) + 0x20), data_100441d0, 4) == 0)
                {
                    if (i[2] == 0)
                    {
                        void* var_48_9 = &i[8];
                        int32_t var_4c_6 = i[6];
                        char const* const var_50_6 = var_30_1;
                        
                        if (sub_1000ed60(0, nullptr, 0, nullptr, "HEAP CORRUPTION DETECTED: after …") == 1)
                            breakpoint();
                    }
                    else
                    {
                        int32_t var_48_8 = i[3];
                        int32_t var_4c_5 = i[2];
                        void* var_50_5 = &i[8];
                        int32_t var_54_2 = i[6];
                        char const* const var_58_2 = var_30_1;
                        
                        if (sub_1000ed60(0, nullptr, 0, nullptr, "HEAP CORRUPTION DETECTED: after …") == 1)
                            breakpoint();
                    }
                    
                    var_2c_1 = 0;
                }
                
                if ((i[5] == 0 && sub_10011ab0(&i[8], data_100441d2, i[4]) == 0))
                {
                    if (i[2] == 0)
                    {
                        void* var_48_12 = &i[8];
                        
                        if (sub_1000ed60(0, nullptr, 0, nullptr, "HEAP CORRUPTION DETECTED: on top…") == 1)
                            breakpoint();
                    }
                    else
                    {
                        int32_t var_48_11 = i[3];
                        int32_t var_4c_8 = i[2];
                        void* var_50_8 = &i[8];
                        
                        if (sub_1000ed60(0, nullptr, 0, nullptr, "HEAP CORRUPTION DETECTED: on top…") == 1)
                            breakpoint();
                    }
                    
                    var_2c_1 = 0;
                }
                
                if (var_2c_1 == 0)
                {
                    if (i[2] == 0)
                    {
                        int32_t var_48_14 = i[4];
                        void* var_4c_10 = &i[8];
                        char const* const var_50_10 = var_30_1;
                        
                        if (sub_1000ed60(0, nullptr, 0, nullptr, "%hs located at 0x%p is %Iu bytes…") == 1)
                            breakpoint();
                    }
                    else
                    {
                        int32_t var_48_13 = i[3];
                        int32_t var_4c_9 = i[2];
                        int32_t var_50_9 = i[4];
                        void* var_54_3 = &i[8];
                        char const* const var_58_3 = var_30_1;
                        
                        if (sub_1000ed60(0, nullptr, 0, nullptr, "%hs located at 0x%p is %Iu bytes…") == 1)
                            breakpoint();
                    }
                    
                    result_1 = 0;
                }
            }
        }
        else
        {
            if ((eax_4 + 6) > 3)
            {
                char const* const var_48_5 = "_heapchk fails with unknown retu…";
                
                if (sub_1000ed60(0, nullptr, 0, nullptr, &data_100363c4) == 1)
                    breakpoint();
            }
            else
                switch (eax_4)
                {
                    case 0xfffffffa:
                    {
                        char const* const var_48_4 = "_heapchk fails with _HEAPBADPTR.…";
                        
                        if (sub_1000ed60(0, nullptr, 0, nullptr, &data_100363c4) == 1)
                            breakpoint();
                        break;
                    }
                    case 0xfffffffb:
                    {
                        char const* const var_48_3 = "_heapchk fails with _HEAPBADEND.…";
                        
                        if (sub_1000ed60(0, nullptr, 0, nullptr, &data_100363c4) == 1)
                            breakpoint();
                        break;
                    }
                    case 0xfffffffc:
                    {
                        char const* const var_48_2 = "_heapchk fails with _HEAPBADNODE…";
                        
                        if (sub_1000ed60(0, nullptr, 0, nullptr, &data_100363c4) == 1)
                            breakpoint();
                        break;
                    }
                    case 0xfffffffd:
                    {
                        char const* const var_48_1 = "_heapchk fails with _HEAPBADBEGI…";
                        
                        if (sub_1000ed60(0, nullptr, 0, nullptr, &data_100363c4) == 1)
                            breakpoint();
                        break;
                    }
                }
            
            result_1 = 0;
        }
        
        int32_t var_8_2 = 0xfffffffe;
        sub_10011f25();
        result = result_1;
    }
    else
        result = 1;
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10011f25()
{
    return __unlock(4);
}

int32_t sub_10011f60(int32_t arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041c98;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_34 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_38 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_20 = data_100441c0;
    int32_t var_28;
    
    if ((arg1 == 0xffffffff || (arg1 & 0xffffffc8) == 0))
        var_28 = 1;
    else
        var_28 = 0;
    
    if ((var_28 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x778, nullptr, u"(fNewBits==_CRTDBG_REPORT_FLAG) …") == 1))
        breakpoint();
    
    int32_t result;
    
    if (var_28 != 0)
    {
        __lock(4);
        int32_t var_8_1 = 0;
        int32_t result_1 = data_100441c0;
        
        if (arg1 != 0xffffffff)
        {
            if ((arg1 & 4) == 0)
                data_10045638 = (arg1 >> 0x10);
            else
                data_10045638 = 1;
            
            data_10045620 = 0;
            data_100441c0 = arg1;
        }
        
        int32_t var_8_2 = 0xfffffffe;
        sub_10012086();
        result = result_1;
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(fNewBits==_CRTDBG_REPORT_FLAG) …", u"_CrtSetDbgFlag", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x778, 0);
        result = data_100441c0;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10012086()
{
    return __unlock(4);
}

int32_t sub_100120b0(int32_t arg1) __pure
{
    int32_t result;
    result = arg1 != 0;
    return result;
}

BOOL sub_100120c0(int32_t arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if (arg1 == 0)
        return 0;
    
    int32_t var_c_1 = 0;
    int32_t var_10_1 = 0x20;
    
    if (sub_100120b0((arg1 - 0x20)) == 0)
        return 0;
    
    if (data_10049254 != 3)
        return HeapValidate(data_10045c64, HEAP_NONE, (arg1 - 0x20));
    
    void* eax_4 = sub_10020070((arg1 - 0x20));
    
    if (eax_4 == 0)
        return HeapValidate(data_10045c64, HEAP_NONE, (arg1 - 0x20));
    
    return sub_100200d0(eax_4, (arg1 - 0x20));
}

int32_t sub_10012124(int32_t* arg1 @ ebp)
{
    *arg1;
}

int32_t sub_10012160(int32_t* arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_34 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x10041cb8 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_38 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t eax_2;
    eax_2 = arg1 != 0;
    
    if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x8f2, nullptr, u"state != NULL") == 1))
        breakpoint();
    
    int32_t result;
    
    if (eax_2 != 0)
    {
        __lock(4);
        int32_t var_8_1 = 0;
        *arg1 = data_10045628;
        
        for (int32_t i = 0; i < 5; i += 1)
        {
            arg1[(i + 6)] = 0;
            arg1[(i + 1)] = 0;
        }
        
        for (int32_t* i_1 = data_10045628; i_1 != 0; i_1 = *i_1)
        {
            if ((i_1[5] >= 0 && i_1[5] < 5))
            {
                arg1[(i_1[5] + 1)] += 1;
                arg1[(i_1[5] + 6)] += i_1[4];
            }
            else if (i_1[2] == 0)
            {
                int32_t* i_3 = i_1;
                
                if (sub_1000ed60(0, nullptr, 0, nullptr, "Bad memory block found at 0x%p.\n") == 1)
                    breakpoint();
            }
            else
            {
                int32_t var_3c_1 = i_1[3];
                int32_t var_40_1 = i_1[2];
                int32_t* i_2 = i_1;
                
                if (sub_1000ed60(0, nullptr, 0, nullptr, "Bad memory block found at 0x%p.\n…") == 1)
                    breakpoint();
            }
        }
        
        arg1[0xb] = data_10045624;
        arg1[0xc] = data_10045618;
        int32_t var_8_2 = 0xfffffffe;
        result = sub_1001235b();
    }
    else
    {
        *sub_1000eca0() = 0x16;
        result = sub_1000c310(u"state != NULL", u"_CrtMemCheckpoint", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x8f2, 0);
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1001235b()
{
    return __unlock(4);
}

void* __CrtMemDumpAllObjectsSince(int32_t* arg1)
{
    void var_18;
    _LocaleUpdate::_LocaleUpdate(&var_18, nullptr);
    sub_100124d0(arg1, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_18));
    return _LocaleUpdate::~_LocaleUpdate(&var_18);
}

void** __thiscall _LocaleUpdate::_LocaleUpdate(void** arg1, void** arg2)
{
    void** var_8 = arg1;
    arg1[3] = 0;
    
    if (arg2 != 0)
    {
        int32_t ecx_13 = arg2[1];
        *arg1 = *arg2;
        arg1[1] = ecx_13;
    }
    else
    {
        arg1[2] = __getptd();
        *arg1 = *(arg1[2] + 0x6c);
        arg1[1] = *(arg1[2] + 0x68);
        
        if ((*arg1 != data_10044c18 && (*(arg1[2] + 0x70) & data_10044b34) == 0))
            *arg1 = sub_10022be0();
        
        if ((arg1[1] != data_10044a38 && (*(arg1[2] + 0x70) & data_10044b34) == 0))
            arg1[1] = sub_100219d0();
        
        if ((*(arg1[2] + 0x70) & 2) == 0)
        {
            *(arg1[2] + 0x70) |= 2;
            arg1[3] = 1;
        }
    }
    
    return arg1;
}

void* __fastcall _LocaleUpdate::~_LocaleUpdate(void* arg1)
{
    void* var_8 = arg1;
    void* result = arg1;
    
    if (*(result + 0xc) != 0)
    {
        result = *(arg1 + 8);
        *(result + 0x70) = (*(*(arg1 + 8) + 0x70) & 0xfffffffd);
    }
    
    return result;
}

int32_t sub_100124d0(int32_t* arg1, void** arg2)
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x10041cd8 ^ __security_cookie_1);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_24 = 0;
    __lock(4);
    int32_t var_8_1 = 0;
    char const* const var_38 = "Dumping objects ->\n";
    
    if (sub_1000ed60(0, nullptr, 0, nullptr, &data_100363c4) == 1)
        breakpoint();
    
    if (arg1 != 0)
        var_24 = *arg1;
    
    for (int32_t* i = data_10045628; i != 0; i = *i)
    {
        if (i == var_24)
            break;
        
        if ((i[5] != 3 && (i[5] != 0 && (i[5] != 2 || (data_100441c0 & 0x10) != 0))))
        {
            if (i[2] != 0)
            {
                int32_t var_38_1 = 0;
                int32_t var_3c_1 = 1;
                int32_t eax_9 = sub_100120b0(i[2]);
                BOOL eax_11;
                
                if (eax_9 != 0)
                    eax_11 = IsBadReadPtr(i[2], 1);
                
                if ((eax_9 != 0 && eax_11 == 0))
                {
                    int32_t var_38_3 = i[3];
                    int32_t var_3c_3 = i[2];
                    
                    if (sub_1000ed60(0, nullptr, 0, nullptr, "%hs(%d) : ") == 1)
                        breakpoint();
                }
                else
                {
                    int32_t var_38_2 = i[3];
                    
                    if (sub_1000ed60(0, nullptr, 0, nullptr, "#File Error#(%d) : ") == 1)
                        breakpoint();
                }
            }
            
            int32_t var_38_4 = i[6];
            
            if (sub_1000ed60(0, nullptr, 0, nullptr, "{%ld} ") == 1)
                breakpoint();
            
            if (i[5] == 4)
            {
                int32_t var_38_5 = i[4];
                uint32_t var_3c_4 = (i[5] >> 0x10);
                void* var_40_2 = &i[8];
                
                if (sub_1000ed60(0, nullptr, 0, nullptr, "client block at 0x%p, subtype %x…") == 1)
                    breakpoint();
                
                BOOL eax_22;
                
                if (data_1004562c != 0)
                    eax_22 = IsBadReadPtr(&i[8], 1);
                
                int32_t __saved_ebp;
                
                if ((data_1004562c == 0 || eax_22 != 0))
                    sub_100127e0(arg2, i);
                else
                    data_1004562c(&i[8], i[4], (__security_cookie_1 ^ &__saved_ebp));
            }
            else if (i[5] == 1)
            {
                int32_t var_38_8 = i[4];
                void* var_3c_8 = &i[8];
                
                if (sub_1000ed60(0, nullptr, 0, nullptr, "normal block at 0x%p, %Iu bytes …") == 1)
                    breakpoint();
                
                sub_100127e0(arg2, i);
            }
            else if (i[5] == 2)
            {
                int32_t var_38_10 = i[4];
                uint32_t var_3c_10 = (i[5] >> 0x10);
                void* var_40_3 = &i[8];
                
                if (sub_1000ed60(0, nullptr, 0, nullptr, "crt block at 0x%p, subtype %x, %…") == 1)
                    breakpoint();
                
                sub_100127e0(arg2, i);
            }
        }
    }
    
    int32_t var_8_2 = 0xfffffffe;
    sub_1001279a();
    char const* const var_38_12 = "Object dump complete.\n";
    int32_t result = sub_1000ed60(0, nullptr, 0, nullptr, &data_100363c4);
    
    if (result == 1)
        breakpoint();
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1001279a()
{
    return __unlock(4);
}

int32_t sub_100127e0(void** arg1, void* arg2)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    void var_64;
    _LocaleUpdate::_LocaleUpdate(&var_64, arg1);
    int32_t var_8 = 0;
    void var_54;
    
    while (true)
    {
        int32_t var_70_1;
        
        if (*(arg2 + 0x10) >= 0x10)
            var_70_1 = 0x10;
        else
            var_70_1 = *(arg2 + 0x10);
        
        if (var_8 >= var_70_1)
            break;
        
        int32_t ecx_1;
        ecx_1 = *((arg2 + var_8) + 0x20);
        char var_65_1 = ecx_1;
        int32_t eax_6 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_64);
        void* edx_3;
        
        if (eax_6 != 0)
            edx_3 = *_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_64);
        
        int32_t var_74_1;
        
        if ((eax_6 == 0 || *(edx_3 + 0xac) <= 1))
            var_74_1 = sub_10024350(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_64), var_65_1, 0x157);
        else
            var_74_1 = sub_10024400(var_65_1, 0x157, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_64));
        
        char var_78_1;
        
        if (var_74_1 == 0)
            var_78_1 = 0x20;
        else
            var_78_1 = var_65_1;
        
        *(&var_54 + var_8) = var_78_1;
        int32_t edx_5 = *sub_1000eca0();
        *sub_1000eca0() = 0;
        uint32_t var_7c_2 = var_65_1;
        
        if (_swprintf_s(((&__saved_ebp + (var_8 * 3)) - 0x3c), (0x31 - (var_8 * 3)), "%.2X ") < 0)
            sub_1000b4e0(*sub_1000eca0(), 0x16, 0x22, u"(*_errno())", u"_printMemBlockData", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x963, 0);
        
        *sub_1000eca0() = edx_5;
        var_8 += 1;
    }
    
    *(&var_54 + var_8) = 0;
    void var_40;
    void* var_7c_3 = &var_40;
    void* var_80_2 = &var_54;
    
    if (sub_1000ed60(0, nullptr, 0, nullptr, " Data: <%s> %s\n") == 1)
        breakpoint();
    
    _LocaleUpdate::~_LocaleUpdate(&var_64);
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t sub_10012980()
{
    void var_38;
    sub_10012160(&var_38);
    int32_t var_30;
    int32_t var_2c;
    int32_t var_24;
    
    if ((var_24 == 0 && (var_30 == 0 && ((data_100441c0 & 0x10) == 0 || var_2c == 0))))
        return 0;
    
    char const* const var_3c_1 = "Detected memory leaks!\n";
    
    if (sub_1000ed60(0, nullptr, 0, nullptr, &data_100363c4) == 1)
        breakpoint();
    
    __CrtMemDumpAllObjectsSince(nullptr);
    return 1;
}

int32_t __CrtSetCheckCount()
{
    int32_t ecx;
    int32_t var_8 = ecx;
    return data_10045634;
}

int32_t __CrtGetReportHook()
{
    return data_10045634;
}

int32_t sub_10012a20(char* arg1, char* arg2, int32_t arg3)
{
    if (arg3 > 4)
        return _unaligned_memcmp(arg1, arg2, arg3);
    
    switch (arg3)
    {
        case 0:
        {
            return 0;
            break;
        }
        case 1:
        {
            return _cmpBYTE(arg1, arg2);
            break;
        }
        case 2:
        {
            int32_t eax_19 = _cmpBYTE(arg1, arg2);
            
            if (eax_19 == 0)
                return _cmpBYTE(&arg1[1], &arg2[1]);
            
            return eax_19;
            break;
        }
        case 3:
        {
            int32_t eax_11 = _cmpBYTE(arg1, arg2);
            
            if (eax_11 != 0)
                return eax_11;
            
            int32_t eax_14 = _cmpBYTE(&arg1[1], &arg2[1]);
            
            if (eax_14 == 0)
                return _cmpBYTE(&arg1[2], &arg2[2]);
            
            return eax_14;
            break;
        }
        case 4:
        {
            int32_t eax_2 = _cmpBYTE(arg1, arg2);
            
            if (eax_2 != 0)
                return eax_2;
            
            int32_t eax_4 = _cmpBYTE(&arg1[1], &arg2[1]);
            
            if (eax_4 != 0)
                return eax_4;
            
            int32_t eax_6 = _cmpBYTE(&arg1[2], &arg2[2]);
            
            if (eax_6 == 0)
                return _cmpBYTE(&arg1[3], &arg2[3]);
            
            return eax_6;
            break;
        }
    }
}

int32_t _cmpBYTE(char* arg1, char* arg2)
{
    return sub_10012c10((*arg1 - *arg2));
}

int32_t sub_10012c10(int32_t arg1) __pure
{
    if (arg1 == 0)
        return arg1;
    
    int32_t eax_1;
    eax_1 = arg1 > 0;
    return ((eax_1 * 2) - 1);
}

int32_t _unaligned_memcmp(void* arg1, int32_t* arg2, int32_t arg3)
{
    for (; arg3 >= 0x20; arg3 -= 0x20)
    {
        int32_t eax_2 = sub_100133c0(arg1, arg2);
        
        if (eax_2 != 0)
            return eax_2;
        
        int32_t eax_6 = sub_100133c0((arg1 + 4), &arg2[1]);
        
        if (eax_6 != 0)
            return eax_6;
        
        int32_t eax_7 = sub_100133c0((arg1 + 8), &arg2[2]);
        
        if (eax_7 != 0)
            return eax_7;
        
        int32_t eax_10 = sub_100133c0((arg1 + 0xc), &arg2[3]);
        
        if (eax_10 != 0)
            return eax_10;
        
        int32_t eax_13 = sub_100133c0((arg1 + 0x10), &arg2[4]);
        
        if (eax_13 != 0)
            return eax_13;
        
        int32_t eax_14 = sub_100133c0((arg1 + 0x14), &arg2[5]);
        
        if (eax_14 != 0)
            return eax_14;
        
        int32_t eax_17 = sub_100133c0((arg1 + 0x18), &arg2[6]);
        
        if (eax_17 != 0)
            return eax_17;
        
        int32_t eax_20 = sub_100133c0((arg1 + 0x1c), &arg2[7]);
        
        if (eax_20 != 0)
            return eax_20;
        
        arg1 += 0x20;
        arg2 = &arg2[8];
    }
    
    void* ecx_13 = (arg1 + arg3);
    arg2 += arg3;
    
    if (arg3 > 0x1f)
        return 0;
    
    switch (arg3)
    {
        case 0:
        {
            return 0;
            break;
        }
        case 1:
        {
            return _cmpBYTE((ecx_13 - 1), (arg2 - 1));
            break;
        }
        case 2:
        {
            return sub_10013340((ecx_13 - 2), (arg2 - 2));
            break;
        }
        case 3:
        {
        label_1001324c:
            int32_t eax_94 = _cmpBYTE((ecx_13 - 3), (arg2 - 3));
            
            if (eax_94 != 0)
                return eax_94;
            
            int32_t eax_97 = _cmpBYTE((ecx_13 - 2), (arg2 - 2));
            
            if (eax_97 == 0)
                return _cmpBYTE((ecx_13 - 1), (arg2 - 1));
            
            return eax_97;
            break;
        }
        case 4:
        {
        label_10012eb8:
            int32_t eax_40 = sub_100133c0((ecx_13 - 4), (arg2 - 4));
            
            if (eax_40 != 0)
                return eax_40;
            
            return 0;
            break;
        }
        case 5:
        {
        label_10012fd0:
            int32_t eax_55 = sub_100133c0((ecx_13 - 5), (arg2 - 5));
            
            if (eax_55 != 0)
                return eax_55;
            
            return _cmpBYTE((ecx_13 - 1), (arg2 - 1));
            break;
        }
        case 6:
        {
        label_100130fc:
            int32_t eax_74 = sub_100133c0((ecx_13 - 6), (arg2 - 6));
            
            if (eax_74 != 0)
                return eax_74;
            
            return sub_10013340((ecx_13 - 2), (arg2 - 2));
            break;
        }
        case 7:
        {
        label_10013228:
            int32_t eax_91 = sub_100133c0((ecx_13 - 7), (arg2 - 7));
            
            if (eax_91 != 0)
                return eax_91;
            
            goto label_1001324c;
        }
        case 8:
        {
        label_10012e91:
            int32_t eax_37 = sub_100133c0((ecx_13 - 8), (arg2 - 8));
            
            if (eax_37 != 0)
                return eax_37;
            
            goto label_10012eb8;
        }
        case 9:
        {
        label_10012fa9:
            int32_t eax_54 = sub_100133c0((ecx_13 - 9), (arg2 - 9));
            
            if (eax_54 != 0)
                return eax_54;
            
            goto label_10012fd0;
        }
        case 0xa:
        {
        label_100130d5:
            int32_t eax_71 = sub_100133c0((ecx_13 - 0xa), (arg2 - 0xa));
            
            if (eax_71 != 0)
                return eax_71;
            
            goto label_100130fc;
        }
        case 0xb:
        {
        label_10013201:
            int32_t eax_88 = sub_100133c0((ecx_13 - 0xb), (arg2 - 0xb));
            
            if (eax_88 != 0)
                return eax_88;
            
            goto label_10013228;
        }
        case 0xc:
        {
        label_10012e6a:
            int32_t eax_34 = sub_100133c0((ecx_13 - 0xc), (arg2 - 0xc));
            
            if (eax_34 != 0)
                return eax_34;
            
            goto label_10012e91;
        }
        case 0xd:
        {
        label_10012f82:
            int32_t eax_51 = sub_100133c0((ecx_13 - 0xd), (arg2 - 0xd));
            
            if (eax_51 != 0)
                return eax_51;
            
            goto label_10012fa9;
        }
        case 0xe:
        {
        label_100130ae:
            int32_t eax_68 = sub_100133c0((ecx_13 - 0xe), (arg2 - 0xe));
            
            if (eax_68 != 0)
                return eax_68;
            
            goto label_100130d5;
        }
        case 0xf:
        {
        label_100131da:
            int32_t eax_87 = sub_100133c0((ecx_13 - 0xf), (arg2 - 0xf));
            
            if (eax_87 != 0)
                return eax_87;
            
            goto label_10013201;
        }
        case 0x10:
        {
        label_10012e43:
            int32_t eax_33 = sub_100133c0((ecx_13 - 0x10), (arg2 - 0x10));
            
            if (eax_33 != 0)
                return eax_33;
            
            goto label_10012e6a;
        }
        case 0x11:
        {
        label_10012f5b:
            int32_t eax_48 = sub_100133c0((ecx_13 - 0x11), (arg2 - 0x11));
            
            if (eax_48 != 0)
                return eax_48;
            
            goto label_10012f82;
        }
        case 0x12:
        {
        label_10013087:
            int32_t eax_67 = sub_100133c0((ecx_13 - 0x12), (arg2 - 0x12));
            
            if (eax_67 != 0)
                return eax_67;
            
            goto label_100130ae;
        }
        case 0x13:
        {
        label_100131b3:
            int32_t eax_84 = sub_100133c0((ecx_13 - 0x13), (arg2 - 0x13));
            
            if (eax_84 != 0)
                return eax_84;
            
            goto label_100131da;
        }
        case 0x14:
        {
        label_10012e1c:
            int32_t eax_30 = sub_100133c0((ecx_13 - 0x14), (arg2 - 0x14));
            
            if (eax_30 != 0)
                return eax_30;
            
            goto label_10012e43;
        }
        case 0x15:
        {
        label_10012f34:
            int32_t eax_47 = sub_100133c0((ecx_13 - 0x15), (arg2 - 0x15));
            
            if (eax_47 != 0)
                return eax_47;
            
            goto label_10012f5b;
        }
        case 0x16:
        {
        label_10013060:
            int32_t eax_64 = sub_100133c0((ecx_13 - 0x16), (arg2 - 0x16));
            
            if (eax_64 != 0)
                return eax_64;
            
            goto label_10013087;
        }
        case 0x17:
        {
        label_1001318c:
            int32_t eax_81 = sub_100133c0((ecx_13 - 0x17), (arg2 - 0x17));
            
            if (eax_81 != 0)
                return eax_81;
            
            goto label_100131b3;
        }
        case 0x18:
        {
        label_10012df5:
            int32_t eax_27 = sub_100133c0((ecx_13 - 0x18), (arg2 - 0x18));
            
            if (eax_27 != 0)
                return eax_27;
            
            goto label_10012e1c;
        }
        case 0x19:
        {
        label_10012f0d:
            int32_t eax_44 = sub_100133c0((ecx_13 - 0x19), (arg2 - 0x19));
            
            if (eax_44 != 0)
                return eax_44;
            
            goto label_10012f34;
        }
        case 0x1a:
        {
        label_10013039:
            int32_t eax_61 = sub_100133c0((ecx_13 - 0x1a), (arg2 - 0x1a));
            
            if (eax_61 != 0)
                return eax_61;
            
            goto label_10013060;
        }
        case 0x1b:
        {
        label_10013165:
            int32_t eax_80 = sub_100133c0((ecx_13 - 0x1b), (arg2 - 0x1b));
            
            if (eax_80 != 0)
                return eax_80;
            
            goto label_1001318c;
        }
        case 0x1c:
        {
            int32_t eax_26 = sub_100133c0((ecx_13 - 0x1c), (arg2 - 0x1c));
            
            if (eax_26 != 0)
                return eax_26;
            
            goto label_10012df5;
        }
        case 0x1d:
        {
            int32_t eax_41 = sub_100133c0((ecx_13 - 0x1d), (arg2 - 0x1d));
            
            if (eax_41 != 0)
                return eax_41;
            
            goto label_10012f0d;
        }
        case 0x1e:
        {
            int32_t eax_60 = sub_100133c0((ecx_13 - 0x1e), (arg2 - 0x1e));
            
            if (eax_60 != 0)
                return eax_60;
            
            goto label_10013039;
        }
        case 0x1f:
        {
            int32_t eax_77 = sub_100133c0((ecx_13 - 0x1f), (arg2 - 0x1f));
            
            if (eax_77 != 0)
                return eax_77;
            
            goto label_10013165;
        }
    }
}

int32_t sub_10013340(char* arg1, int16_t* arg2)
{
    if (*arg1 == *arg2)
        return 0;
    
    int32_t result = _cmpBYTE(arg1, arg2);
    
    if (result == 0)
        return _cmpBYTE(&arg1[1], (arg2 + 1));
    
    return result;
}

int32_t sub_100133c0(char* arg1, int32_t* arg2)
{
    if (*arg1 == *arg2)
        return 0;
    
    int32_t eax_3 = _cmpBYTE(arg1, arg2);
    
    if (eax_3 != 0)
        return eax_3;
    
    int32_t eax_5 = _cmpBYTE(&arg1[1], (arg2 + 1));
    
    if (eax_5 != 0)
        return eax_5;
    
    int32_t eax_7 = _cmpBYTE(&arg1[2], (arg2 + 2));
    
    if (eax_7 == 0)
        return _cmpBYTE(&arg1[3], (arg2 + 3));
    
    return eax_7;
}

int32_t sub_10013490(int32_t* arg1, int32_t arg2, int32_t arg3)
{
    char var_25 = 0;
    int32_t result = 1;
    int32_t* eax_3 = (*(arg2 + 8) ^ __security_cookie);
    sub_10013650(eax_3, (arg2 + 0x10));
    
    if ((arg1[1] & 0x66) == 0)
    {
        int32_t* var_c = arg1;
        int32_t var_8_1 = arg3;
        *(arg2 - 4) = &var_c;
        int32_t i_1;
        
        for (int32_t i = *(arg2 + 0xc); i != 0xfffffffe; i = i_1)
        {
            int32_t ecx_8 = eax_3[((i * 3) + 5)];
            i_1 = eax_3[((i * 3) + 4)];
            
            if (ecx_8 != 0)
            {
                int32_t eax_10 = @_EH4_CallFilterFunc@8();
                var_25 = 1;
                
                if (eax_10 < 0)
                {
                    result = 0;
                    break;
                }
                
                if (eax_10 > 0)
                {
                    if ((*arg1 == 0xe06d7363 && sub_10024600(0x1003fe5c) != 0))
                    {
                        int32_t var_38_1 = 1;
                        sub_10031730(arg1);
                    }
                    
                    sub_1001aaa2(arg2);
                    
                    if (*(arg2 + 0xc) != i)
                        sub_1001aabc(arg2, i, (arg2 + 0x10), 0x100441a8);
                    
                    *(arg2 + 0xc) = i_1;
                    sub_10013650(eax_3, (arg2 + 0x10));
                    @_EH4_TransferToHandler@8(eax_3[((i * 3) + 6)], (arg2 + 0x10), ecx_8, eax_3, i);
                }
            }
        }
    }
    else if (*(arg2 + 0xc) != 0xfffffffe)
    {
        sub_1001aabc(arg2, 0xfffffffe, (arg2 + 0x10), 0x100441a8);
        var_25 = 1;
    }
    
    if (var_25 != 0)
        sub_10013650(eax_3, (arg2 + 0x10));
    
    return result;
}

int32_t sub_10013650(int32_t* arg1, int32_t* arg2)
{
    if (*arg1 != 0xfffffffe)
        sub_1000ac70(((arg2 + arg1[1]) ^ *(arg2 + *arg1)));
    
    return sub_1000ac70(((arg2 + arg1[3]) ^ *(arg2 + arg1[2])));
}

int32_t sub_100136b0(int16_t* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int16_t* var_8_1 = arg1;
    uint32_t i;
    
    do
    {
        i = *var_8_1;
        var_8_1 = &var_8_1[1];
    } while (i != 0);
    return (((var_8_1 - arg1) >> 1) - 1);
}

int32_t sub_100136e0()
{
    int32_t var_8 = 0;
    
    for (int32_t i = 0; i < 0x24; i += 1)
    {
        if (*((i << 3) + &data_100441dc) == 1)
        {
            *((i << 3) + &data_100441d8) = ((var_8 * 0x18) + 0x10045640);
            var_8 += 1;
            
            if (`eh vector constructor iterator'(*((i << 3) + &data_100441d8), 0xfa0) == 0)
            {
                *((i << 3) + &data_100441d8) = 0;
                return 0;
            }
        }
    }
    
    return 1;
}

void __mtdeletelocks()
{
    for (int32_t i = 0; i < 0x24; i += 1)
    {
        if ((*((i << 3) + &data_100441d8) != 0 && *((i << 3) + &data_100441dc) != 1))
        {
            CRITICAL_SECTION* lpCriticalSection = *((i << 3) + &data_100441d8);
            DeleteCriticalSection(lpCriticalSection);
            sub_10011340(lpCriticalSection, 2);
            *((i << 3) + &data_100441d8) = 0;
        }
    }
    
    for (int32_t i_1 = 0; i_1 < 0x24; i_1 += 1)
    {
        if ((*((i_1 << 3) + &data_100441d8) != 0 && *((i_1 << 3) + &data_100441dc) == 1))
            DeleteCriticalSection(*((i_1 << 3) + &data_100441d8));
    }
}

int32_t sub_10013830(int32_t arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041cf8;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_34 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result_1 = 1;
    
    if (data_10045c64 == 0)
    {
        __FF_MSGBANNER();
        sub_10024990(0x1e);
        sub_100159f0(0xff);
        /* no return */
    }
    
    int32_t result;
    
    if (*((arg1 << 3) + &data_100441d8) == 0)
    {
        void* eax_3 = __malloc_dbg(0x18, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x117);
        
        if (eax_3 != 0)
        {
            __lock(0xa);
            int32_t var_8_1 = 0;
            
            if (*((arg1 << 3) + &data_100441d8) != 0)
                sub_10011340(eax_3, 2);
            else if (`eh vector constructor iterator'(eax_3, 0xfa0) != 0)
                *((arg1 << 3) + &data_100441d8) = eax_3;
            else
            {
                sub_10011340(eax_3, 2);
                *sub_1000eca0() = 0xc;
                result_1 = 0;
            }
            
            int32_t var_8_2 = 0xfffffffe;
            sub_10013956();
            result = result_1;
        }
        else
        {
            *sub_1000eca0() = 0xc;
            result = 0;
        }
    }
    else
        result = 1;
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10013956()
{
    return __unlock(0xa);
}

int32_t __lock(int32_t arg1)
{
    if ((*((arg1 << 3) + &data_100441d8) == 0 && sub_10013830(arg1) == 0))
        sub_10015620(0x11);
    
    return EnterCriticalSection(*((arg1 << 3) + &data_100441d8));
}

int32_t __unlock(int32_t arg1)
{
    return LeaveCriticalSection(*((arg1 << 3) + &data_100441d8));
}

BOOL __convention("regparm") sub_100139e0(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4 @ ebp, int32_t arg5 @ esi, int32_t arg6 @ edi)
{
    bool p = /* bool p = unimplemented  {sub esp, 0x328} */;
    bool a = /* bool a = unimplemented  {sub esp, 0x328} */;
    data_100458b0 = arg1;
    data_100458ac = arg3;
    data_100458a8 = arg2;
    int32_t ebx;
    data_100458a4 = ebx;
    data_100458a0 = arg5;
    data_1004589c = arg6;
    int16_t ss;
    data_100458c8 = ss;
    int16_t cs;
    data_100458bc = cs;
    int16_t ds;
    data_10045898 = ds;
    int16_t es;
    data_10045894 = es;
    int16_t fs;
    data_10045890 = fs;
    int16_t gs;
    data_1004588c = gs;
    int32_t var_32c;
    int32_t var_4;
    bool d;
    int32_t var_330 = (((((&var_4 - 0x328)) ? 1 : 0) << 0xb) | ((((d) ? 1 : 0) << 0xa) | ((((&var_32c < 0) ? 1 : 0) << 7) | ((((&var_4 == 0x328) ? 1 : 0) << 6) | ((((a) ? 1 : 0) << 4) | ((((p) ? 1 : 0) << 2) | ((&var_4 < 0x328) ? 1 : 0)))))));
    data_100458c0 = var_330;
    data_100458b4 = arg4;
    data_100458b8 = __return_addr;
    data_100458c4 = &arg_4;
    data_10045800 = 0x10001;
    data_100457b4 = data_100458b8;
    data_100457a8 = 0xc0000409;
    data_100457ac = 1;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_328 = data_100441ac;
    data_100457f8 = IsDebuggerPresent();
    int32_t var_330_1 = 1;
    __heap_term();
    SetUnhandledExceptionFilter(nullptr);
    UnhandledExceptionFilter(&data_10039574);
    
    if (data_100457f8 == 0)
    {
        int32_t var_330_2 = 1;
        __heap_term();
    }
    
    return TerminateProcess(GetCurrentProcess(), 0xc0000409);
}

int32_t sub_10013af0(void* arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x10041d18 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_34 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    __lock(0xe);
    int32_t var_8_1 = 0;
    
    if (*(arg1 + 4) != 0)
    {
        int32_t* i = data_10045ad0;
        int32_t* i_1 = &data_10045acc;
        
        for (; i != 0; i = i_1)
        {
            if (*i == *(arg1 + 4))
            {
                i_1[1] = i[1];
                __mktime32(i);
                break;
            }
            
            i_1 = i;
            
            if ((i[1] == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x58, nullptr, u"pNode->next != NULL") == 1))
                breakpoint();
        }
        
        __mktime32(*(arg1 + 4));
        *(arg1 + 4) = 0;
    }
    
    int32_t var_8_2 = 0xfffffffe;
    int32_t result = sub_10013bdb();
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10013bdb()
{
    return __unlock(0xe);
}

int32_t sub_10013c00(int32_t* arg1, char* arg2)
{
    int32_t* edx = arg1;
    char* ecx = arg2;
    uint32_t eax;
    
    if ((edx & 3) != 0)
    {
        if ((edx & 1) == 0)
        {
        label_10013c6c:
            eax = *edx;
            edx += 2;
            char temp1_1 = *ecx;
            
            if (eax != temp1_1)
                return (((eax - eax) << 1) + 1);
            
            eax = eax;
            
            if (eax == 0)
                return 0;
            
            char temp4_1 = ecx[1];
            
            if (*eax[1] != temp4_1)
                return (((eax - eax) << 1) + 1);
            
            *eax[1] = *eax[1];
            
            if (*eax[1] == 0)
                return 0;
            
            ecx = &ecx[2];
        }
        else
        {
            eax = *edx;
            edx += 1;
            char temp2_1 = *ecx;
            
            if (eax != temp2_1)
                return (((eax - eax) << 1) + 1);
            
            ecx = &ecx[1];
            eax = eax;
            
            if (eax == 0)
                return 0;
            
            if ((edx & 2) != 0)
                goto label_10013c6c;
        }
    }
    
    while (true)
    {
        eax = *edx;
        char temp0_1 = *ecx;
        
        if (eax != temp0_1)
            return (((eax - eax) << 1) + 1);
        
        eax = eax;
        
        if (eax == 0)
            return 0;
        
        char temp3_1 = ecx[1];
        
        if (*eax[1] != temp3_1)
            return (((eax - eax) << 1) + 1);
        
        *eax[1] = *eax[1];
        
        if (*eax[1] == 0)
            return 0;
        
        eax u>>= 0x10;
        char temp5_1 = ecx[2];
        
        if (eax != temp5_1)
            return (((eax - eax) << 1) + 1);
        
        eax = eax;
        
        if (eax == 0)
            return 0;
        
        char temp6_1 = ecx[3];
        
        if (*eax[1] != temp6_1)
            return (((eax - eax) << 1) + 1);
        
        ecx = &ecx[4];
        edx = &edx[1];
        *eax[1] = *eax[1];
        
        if (*eax[1] == 0)
            return 0;
    }
}

int128_t* sub_10013c90(int128_t* arg1, int128_t* arg2, void* arg3)
{
    char* esi = arg2;
    char* edi = arg1;
    uint32_t eax_1;
    
    if ((edi > esi && edi < (arg3 + esi)))
    {
        void* esi_2 = ((arg3 + esi) - 4);
        void* edi_2 = ((arg3 + edi) - 4);
        uint32_t n_1;
        
        if ((edi_2 & 3) == 0)
        {
            n_1 = (arg3 >> 2);
            
            if (n_1 < 8)
                /* jump -> &jump_table_10013f50[-(n_1)] */
            
            edi_2 = __builtin_memcpy((edi_2 - (n_1 << 2)), (esi_2 - (n_1 << 2)), n_1);
            
            switch ((arg3 & 3))
            {
                case nullptr:
                {
                    return arg1;
                    break;
                }
                case 1:
                {
                    goto label_10013fb8;
                }
                case 2:
                {
                    goto label_10013fc8;
                }
                case 3:
                {
                    goto label_10013fdc;
                }
            }
        }
        else if (arg3 < 4)
            switch (arg3)
            {
                case nullptr:
                {
                    return arg1;
                    break;
                }
                case 1:
                {
                label_10013fb8:
                    eax_1 = *(esi_2 + 3);
                    *(edi_2 + 3) = eax_1;
                    return arg1;
                    break;
                }
                case 2:
                {
                label_10013fc8:
                    eax_1 = *(esi_2 + 3);
                    *(edi_2 + 3) = eax_1;
                    eax_1 = *(esi_2 + 2);
                    *(edi_2 + 2) = eax_1;
                    return arg1;
                    break;
                }
                case 3:
                {
                label_10013fdc:
                    eax_1 = *(esi_2 + 3);
                    *(edi_2 + 3) = eax_1;
                    eax_1 = *(esi_2 + 2);
                    *(edi_2 + 2) = eax_1;
                    eax_1 = *(esi_2 + 1);
                    *(edi_2 + 1) = eax_1;
                    return arg1;
                    break;
                }
            }
        else
        {
            eax_1 = (edi_2 & 3);
            void* ecx_5 = (arg3 - eax_1);
            
            switch (jump_table_10013ea4[eax_1])
            {
                case 0x10013eb4:
                {
                    eax_1 = *(esi_2 + 3);
                    *(edi_2 + 3) = eax_1;
                    n_1 = (ecx_5 >> 2);
                    
                    if (n_1 < 8)
                        /* jump -> &jump_table_10013f50[-(n_1)] */
                    
                    edi_2 = __builtin_memcpy(((edi_2 - 1) - (n_1 << 2)), ((esi_2 - 1) - (n_1 << 2)), n_1);
                    
                    switch ((3 & ecx_5))
                    {
                        case nullptr:
                        {
                            return arg1;
                            break;
                        }
                        case 1:
                        {
                            goto label_10013fb8;
                        }
                        case 2:
                        {
                            goto label_10013fc8;
                        }
                        case 3:
                        {
                            goto label_10013fdc;
                        }
                    }
                    break;
                }
                case 0x10013ed8:
                {
                    eax_1 = *(esi_2 + 3);
                    *(edi_2 + 3) = eax_1;
                    eax_1 = *(esi_2 + 2);
                    n_1 = (ecx_5 >> 2);
                    *(edi_2 + 2) = eax_1;
                    
                    if (n_1 < 8)
                        /* jump -> &jump_table_10013f50[-(n_1)] */
                    
                    edi_2 = __builtin_memcpy(((edi_2 - 2) - (n_1 << 2)), ((esi_2 - 2) - (n_1 << 2)), n_1);
                    
                    switch ((3 & ecx_5))
                    {
                        case nullptr:
                        {
                            return arg1;
                            break;
                        }
                        case 1:
                        {
                            goto label_10013fb8;
                        }
                        case 2:
                        {
                            goto label_10013fc8;
                        }
                        case 3:
                        {
                            goto label_10013fdc;
                        }
                    }
                    break;
                }
                case 0x10013f00:
                {
                    eax_1 = *(esi_2 + 3);
                    *(edi_2 + 3) = eax_1;
                    eax_1 = *(esi_2 + 2);
                    *(edi_2 + 2) = eax_1;
                    eax_1 = *(esi_2 + 1);
                    n_1 = (ecx_5 >> 2);
                    *(edi_2 + 1) = eax_1;
                    
                    if (n_1 < 8)
                        /* jump -> &jump_table_10013f50[-(n_1)] */
                    
                    edi_2 = __builtin_memcpy(((edi_2 - 3) - (n_1 << 2)), ((esi_2 - 3) - (n_1 << 2)), n_1);
                    
                    switch ((3 & ecx_5))
                    {
                        case nullptr:
                        {
                            return arg1;
                            break;
                        }
                        case 1:
                        {
                            goto label_10013fb8;
                        }
                        case 2:
                        {
                            goto label_10013fc8;
                        }
                        case 3:
                        {
                            goto label_10013fdc;
                        }
                    }
                    break;
                }
            }
        }
    }
    
    if (((arg3 >= 0x100 && data_10049250 != 0) && (edi & 0xf) == (esi & 0xf)))
        /* tailcall */
        return sub_10024c30(arg1, arg2, arg3);
    
    uint32_t n;
    void* edx_2;
    
    if ((edi & 3) != 0)
    {
        if (arg3 < 4)
            /* jump -> *(((arg3 - 4) << 2) + &data_10013e14) */
        
        eax_1 = (edi & 3);
        void* ecx_3 = ((arg3 - 4) + eax_1);
        
        switch (jump_table_10013d18[eax_1])
        {
            case 0x10013d28:
            {
                edx_2 = (3 & ecx_3);
                eax_1 = *esi;
                *edi = eax_1;
                eax_1 = esi[1];
                edi[1] = eax_1;
                eax_1 = esi[2];
                n = (ecx_3 >> 2);
                edi[2] = eax_1;
                esi = &esi[3];
                edi = &edi[3];
                
                if (n >= 8)
                {
                    edi = __builtin_memcpy(edi, esi, n);
                    
                    switch (edx_2)
                    {
                        case nullptr:
                        {
                            return arg1;
                            break;
                        }
                        case 1:
                        {
                            goto label_10013e1c;
                        }
                        case 2:
                        {
                            goto label_10013e28;
                        }
                        case 3:
                        {
                            goto label_10013e3c;
                        }
                    }
                }
                break;
            }
            case 0x10013d54:
            {
                edx_2 = (3 & ecx_3);
                eax_1 = *esi;
                *edi = eax_1;
                eax_1 = esi[1];
                n = (ecx_3 >> 2);
                edi[1] = eax_1;
                esi = &esi[2];
                edi = &edi[2];
                
                if (n >= 8)
                {
                    edi = __builtin_memcpy(edi, esi, n);
                    
                    switch (edx_2)
                    {
                        case nullptr:
                        {
                            return arg1;
                            break;
                        }
                        case 1:
                        {
                            goto label_10013e1c;
                        }
                        case 2:
                        {
                            goto label_10013e28;
                        }
                        case 3:
                        {
                            goto label_10013e3c;
                        }
                    }
                }
                break;
            }
            case 0x10013d78:
            {
                edx_2 = (3 & ecx_3);
                eax_1 = *esi;
                *edi = eax_1;
                esi = &esi[1];
                n = (ecx_3 >> 2);
                edi = &edi[1];
                
                if (n >= 8)
                {
                    edi = __builtin_memcpy(edi, esi, n);
                    
                    switch (edx_2)
                    {
                        case nullptr:
                        {
                            return arg1;
                            break;
                        }
                        case 1:
                        {
                            goto label_10013e1c;
                        }
                        case 2:
                        {
                            goto label_10013e28;
                        }
                        case 3:
                        {
                            goto label_10013e3c;
                        }
                    }
                }
                break;
            }
        }
    }
    else
    {
        n = (arg3 >> 2);
        edx_2 = (arg3 & 3);
        
        if (n >= 8)
        {
            edi = __builtin_memcpy(edi, esi, n);
            
            switch (edx_2)
            {
                case nullptr:
                {
                    return arg1;
                    break;
                }
                case 1:
                {
                    goto label_10013e1c;
                }
                case 2:
                {
                    goto label_10013e28;
                }
                case 3:
                {
                    goto label_10013e3c;
                }
            }
        }
    }
    
    switch (n)
    {
        case 0:
        {
            goto label_10013dfb;
        }
        case 1:
        {
            goto label_10013dec;
        }
        case 2:
        {
            goto label_10013de4;
        }
        case 3:
        {
            goto label_10013ddc;
        }
        case 4:
        {
            goto label_10013dd4;
        }
        case 5:
        {
            goto label_10013dcc;
        }
        case 6:
        {
            goto label_10013dc4;
        }
        case 7:
        {
            *((edi + (n << 2)) - 0x1c) = *((esi + (n << 2)) - 0x1c);
        label_10013dc4:
            *((edi + (n << 2)) - 0x18) = *((esi + (n << 2)) - 0x18);
        label_10013dcc:
            *((edi + (n << 2)) - 0x14) = *((esi + (n << 2)) - 0x14);
        label_10013dd4:
            *((edi + (n << 2)) - 0x10) = *((esi + (n << 2)) - 0x10);
        label_10013ddc:
            *((edi + (n << 2)) - 0xc) = *((esi + (n << 2)) - 0xc);
        label_10013de4:
            *((edi + (n << 2)) - 8) = *((esi + (n << 2)) - 8);
        label_10013dec:
            *((edi + (n << 2)) - 4) = *((esi + (n << 2)) - 4);
            eax_1 = (n << 2);
            esi = &esi[eax_1];
            edi = &edi[eax_1];
        label_10013dfb:
            
            switch (edx_2)
            {
                case nullptr:
                {
                    return arg1;
                    break;
                }
                case 1:
                {
                label_10013e1c:
                    eax_1 = *esi;
                    *edi = eax_1;
                    return arg1;
                    break;
                }
                case 2:
                {
                label_10013e28:
                    eax_1 = *esi;
                    *edi = eax_1;
                    eax_1 = esi[1];
                    edi[1] = eax_1;
                    return arg1;
                    break;
                }
                case 3:
                {
                label_10013e3c:
                    eax_1 = *esi;
                    *edi = eax_1;
                    eax_1 = esi[1];
                    edi[1] = eax_1;
                    eax_1 = esi[2];
                    edi[2] = eax_1;
                    return arg1;
                    break;
                }
            }
            break;
        }
    }
}

int32_t __convention("regparm") sub_10013f34(int32_t* arg1, int32_t arg2, int32_t arg3, void* arg4 @ ebp, void* arg5 @ esi, int32_t arg6 @ edi)
{
    int32_t eflags;
    int32_t eflags_1;
    char temp0;
    temp0 = __aas(arg1, *arg1[1], eflags);
    arg1 = temp0;
    char temp1;
    *arg1[1] = temp1;
    *arg1 += arg2;
    void* const* esp = &__return_addr;
    int32_t eflags_2;
    char temp0_1;
    temp0_1 = __aas(arg1, *arg1[1], eflags_1);
    arg1 = temp0_1;
    *arg1[1] = temp1;
    *arg1 += arg2;
    int32_t eflags_3;
    char temp0_2;
    temp0_2 = __aas(arg1, *arg1[1], eflags_2);
    arg1 = temp0_2;
    *arg1[1] = temp1;
    *arg1 += arg2;
    uint8_t* edi;
    uint8_t temp0_3;
    temp0_3 = __insb(arg6, arg2, eflags_3);
    *edi = temp0_3;
    int32_t eflags_4;
    char temp0_4;
    temp0_4 = __aas(arg1, *arg1[1], eflags_3);
    arg1 = temp0_4;
    *arg1[1] = temp1;
    char temp1_1 = *arg1;
    *arg1 += arg2;
    
    if (temp1_1 == -(arg2))
    {
        esp += 1;
        *(arg3 * 5);
    label_10013f8a:
        *((arg3 << 2) + 0x8d04) = *(esp + 1);
        esp += 5;
        *arg1 += arg1;
    }
    else
    {
        int32_t temp2_1 = *arg1;
        *arg1 += arg2;
        
        if (temp2_1 < -(arg2))
            goto label_10013f8a;
        
        *arg1 += arg2;
        *edi;
        *arg1 += arg2;
        uint8_t* temp0_5 = edi;
        edi = arg1;
        int32_t eflags_5;
        char temp0_6;
        temp0_6 = __aas(temp0_5, *temp0_5[1], eflags_4);
        uint8_t* eax;
        eax = temp0_6;
        *eax[1] = temp1_1;
        *eax += arg2;
        *((edi + (arg3 << 2)) + 0x1c) = *((arg5 + (arg3 << 2)) + 0x1c);
        *((edi + (arg3 << 2)) + 0x18) = *((arg5 + (arg3 << 2)) + 0x18);
        *((edi + (arg3 << 2)) + 0x14) = *((arg5 + (arg3 << 2)) + 0x14);
        *((edi + (arg3 << 2)) + 0x10) = *((arg5 + (arg3 << 2)) + 0x10);
        *((edi + (arg3 << 2)) + 0xc) = *((arg5 + (arg3 << 2)) + 0xc);
        *((edi + (arg3 << 2)) + 8) = *((arg5 + (arg3 << 2)) + 8);
        *((edi + (arg3 << 2)) + 4) = *((arg5 + (arg3 << 2)) + 4);
        arg1 = (arg3 << 2);
    }
    
    void* esi = (arg5 + arg1);
    void* edi_1 = (edi + arg1);
    
    switch (arg2)
    {
        case 0:
        {
            *esp;
            esp[1];
            *arg4;
            return *(arg4 + 8);
            break;
        }
        case 1:
        {
            arg1 = *(esi + 3);
            *(edi_1 + 3) = arg1;
            *esp;
            esp[1];
            *arg4;
            return *(arg4 + 8);
            break;
        }
        case 2:
        {
            arg1 = *(esi + 3);
            *(edi_1 + 3) = arg1;
            arg1 = *(esi + 2);
            *(edi_1 + 2) = arg1;
            *esp;
            esp[1];
            *arg4;
            return *(arg4 + 8);
            break;
        }
        case 3:
        {
            arg1 = *(esi + 3);
            *(edi_1 + 3) = arg1;
            arg1 = *(esi + 2);
            *(edi_1 + 2) = arg1;
            arg1 = *(esi + 1);
            *(edi_1 + 1) = arg1;
            *esp;
            esp[1];
            *arg4;
            return *(arg4 + 8);
            break;
        }
    }
}

int128_t* sub_10014000(int128_t* arg1, int128_t* arg2, void* arg3)
{
    char* esi = arg2;
    char* edi = arg1;
    uint32_t eax_1;
    
    if ((edi > esi && edi < (arg3 + esi)))
    {
        void* esi_2 = ((arg3 + esi) - 4);
        void* edi_2 = ((arg3 + edi) - 4);
        uint32_t n_1;
        
        if ((edi_2 & 3) == 0)
        {
            n_1 = (arg3 >> 2);
            
            if (n_1 < 8)
                /* jump -> &jump_table_100142c0[-(n_1)] */
            
            edi_2 = __builtin_memcpy((edi_2 - (n_1 << 2)), (esi_2 - (n_1 << 2)), n_1);
            
            switch ((arg3 & 3))
            {
                case nullptr:
                {
                    return arg1;
                    break;
                }
                case 1:
                {
                    goto label_10014328;
                }
                case 2:
                {
                    goto label_10014338;
                }
                case 3:
                {
                    goto label_1001434c;
                }
            }
        }
        else if (arg3 < 4)
            switch (arg3)
            {
                case nullptr:
                {
                    return arg1;
                    break;
                }
                case 1:
                {
                label_10014328:
                    eax_1 = *(esi_2 + 3);
                    *(edi_2 + 3) = eax_1;
                    return arg1;
                    break;
                }
                case 2:
                {
                label_10014338:
                    eax_1 = *(esi_2 + 3);
                    *(edi_2 + 3) = eax_1;
                    eax_1 = *(esi_2 + 2);
                    *(edi_2 + 2) = eax_1;
                    return arg1;
                    break;
                }
                case 3:
                {
                label_1001434c:
                    eax_1 = *(esi_2 + 3);
                    *(edi_2 + 3) = eax_1;
                    eax_1 = *(esi_2 + 2);
                    *(edi_2 + 2) = eax_1;
                    eax_1 = *(esi_2 + 1);
                    *(edi_2 + 1) = eax_1;
                    return arg1;
                    break;
                }
            }
        else
        {
            eax_1 = (edi_2 & 3);
            void* ecx_5 = (arg3 - eax_1);
            
            switch (jump_table_10014214[eax_1])
            {
                case 0x10014224:
                {
                    eax_1 = *(esi_2 + 3);
                    *(edi_2 + 3) = eax_1;
                    n_1 = (ecx_5 >> 2);
                    
                    if (n_1 < 8)
                        /* jump -> &jump_table_100142c0[-(n_1)] */
                    
                    edi_2 = __builtin_memcpy(((edi_2 - 1) - (n_1 << 2)), ((esi_2 - 1) - (n_1 << 2)), n_1);
                    
                    switch ((3 & ecx_5))
                    {
                        case nullptr:
                        {
                            return arg1;
                            break;
                        }
                        case 1:
                        {
                            goto label_10014328;
                        }
                        case 2:
                        {
                            goto label_10014338;
                        }
                        case 3:
                        {
                            goto label_1001434c;
                        }
                    }
                    break;
                }
                case 0x10014248:
                {
                    eax_1 = *(esi_2 + 3);
                    *(edi_2 + 3) = eax_1;
                    eax_1 = *(esi_2 + 2);
                    n_1 = (ecx_5 >> 2);
                    *(edi_2 + 2) = eax_1;
                    
                    if (n_1 < 8)
                        /* jump -> &jump_table_100142c0[-(n_1)] */
                    
                    edi_2 = __builtin_memcpy(((edi_2 - 2) - (n_1 << 2)), ((esi_2 - 2) - (n_1 << 2)), n_1);
                    
                    switch ((3 & ecx_5))
                    {
                        case nullptr:
                        {
                            return arg1;
                            break;
                        }
                        case 1:
                        {
                            goto label_10014328;
                        }
                        case 2:
                        {
                            goto label_10014338;
                        }
                        case 3:
                        {
                            goto label_1001434c;
                        }
                    }
                    break;
                }
                case 0x10014270:
                {
                    eax_1 = *(esi_2 + 3);
                    *(edi_2 + 3) = eax_1;
                    eax_1 = *(esi_2 + 2);
                    *(edi_2 + 2) = eax_1;
                    eax_1 = *(esi_2 + 1);
                    n_1 = (ecx_5 >> 2);
                    *(edi_2 + 1) = eax_1;
                    
                    if (n_1 < 8)
                        /* jump -> &jump_table_100142c0[-(n_1)] */
                    
                    edi_2 = __builtin_memcpy(((edi_2 - 3) - (n_1 << 2)), ((esi_2 - 3) - (n_1 << 2)), n_1);
                    
                    switch ((3 & ecx_5))
                    {
                        case nullptr:
                        {
                            return arg1;
                            break;
                        }
                        case 1:
                        {
                            goto label_10014328;
                        }
                        case 2:
                        {
                            goto label_10014338;
                        }
                        case 3:
                        {
                            goto label_1001434c;
                        }
                    }
                    break;
                }
            }
        }
    }
    
    if (((arg3 >= 0x100 && data_10049250 != 0) && (edi & 0xf) == (esi & 0xf)))
        /* tailcall */
        return sub_10024c30(arg1, arg2, arg3);
    
    uint32_t n;
    void* edx_2;
    
    if ((edi & 3) != 0)
    {
        if (arg3 < 4)
            /* jump -> *(((arg3 - 4) << 2) + &data_10014184) */
        
        eax_1 = (edi & 3);
        void* ecx_3 = ((arg3 - 4) + eax_1);
        
        switch (jump_table_10014088[eax_1])
        {
            case 0x10014098:
            {
                edx_2 = (3 & ecx_3);
                eax_1 = *esi;
                *edi = eax_1;
                eax_1 = esi[1];
                edi[1] = eax_1;
                eax_1 = esi[2];
                n = (ecx_3 >> 2);
                edi[2] = eax_1;
                esi = &esi[3];
                edi = &edi[3];
                
                if (n >= 8)
                {
                    edi = __builtin_memcpy(edi, esi, n);
                    
                    switch (edx_2)
                    {
                        case nullptr:
                        {
                            return arg1;
                            break;
                        }
                        case 1:
                        {
                            goto label_1001418c;
                        }
                        case 2:
                        {
                            goto label_10014198;
                        }
                        case 3:
                        {
                            goto label_100141ac;
                        }
                    }
                }
                break;
            }
            case 0x100140c4:
            {
                edx_2 = (3 & ecx_3);
                eax_1 = *esi;
                *edi = eax_1;
                eax_1 = esi[1];
                n = (ecx_3 >> 2);
                edi[1] = eax_1;
                esi = &esi[2];
                edi = &edi[2];
                
                if (n >= 8)
                {
                    edi = __builtin_memcpy(edi, esi, n);
                    
                    switch (edx_2)
                    {
                        case nullptr:
                        {
                            return arg1;
                            break;
                        }
                        case 1:
                        {
                            goto label_1001418c;
                        }
                        case 2:
                        {
                            goto label_10014198;
                        }
                        case 3:
                        {
                            goto label_100141ac;
                        }
                    }
                }
                break;
            }
            case 0x100140e8:
            {
                edx_2 = (3 & ecx_3);
                eax_1 = *esi;
                *edi = eax_1;
                esi = &esi[1];
                n = (ecx_3 >> 2);
                edi = &edi[1];
                
                if (n >= 8)
                {
                    edi = __builtin_memcpy(edi, esi, n);
                    
                    switch (edx_2)
                    {
                        case nullptr:
                        {
                            return arg1;
                            break;
                        }
                        case 1:
                        {
                            goto label_1001418c;
                        }
                        case 2:
                        {
                            goto label_10014198;
                        }
                        case 3:
                        {
                            goto label_100141ac;
                        }
                    }
                }
                break;
            }
        }
    }
    else
    {
        n = (arg3 >> 2);
        edx_2 = (arg3 & 3);
        
        if (n >= 8)
        {
            edi = __builtin_memcpy(edi, esi, n);
            
            switch (edx_2)
            {
                case nullptr:
                {
                    return arg1;
                    break;
                }
                case 1:
                {
                    goto label_1001418c;
                }
                case 2:
                {
                    goto label_10014198;
                }
                case 3:
                {
                    goto label_100141ac;
                }
            }
        }
    }
    
    switch (n)
    {
        case 0:
        {
            goto label_1001416b;
        }
        case 1:
        {
            goto label_1001415c;
        }
        case 2:
        {
            goto label_10014154;
        }
        case 3:
        {
            goto label_1001414c;
        }
        case 4:
        {
            goto label_10014144;
        }
        case 5:
        {
            goto label_1001413c;
        }
        case 6:
        {
            goto label_10014134;
        }
        case 7:
        {
            *((edi + (n << 2)) - 0x1c) = *((esi + (n << 2)) - 0x1c);
        label_10014134:
            *((edi + (n << 2)) - 0x18) = *((esi + (n << 2)) - 0x18);
        label_1001413c:
            *((edi + (n << 2)) - 0x14) = *((esi + (n << 2)) - 0x14);
        label_10014144:
            *((edi + (n << 2)) - 0x10) = *((esi + (n << 2)) - 0x10);
        label_1001414c:
            *((edi + (n << 2)) - 0xc) = *((esi + (n << 2)) - 0xc);
        label_10014154:
            *((edi + (n << 2)) - 8) = *((esi + (n << 2)) - 8);
        label_1001415c:
            *((edi + (n << 2)) - 4) = *((esi + (n << 2)) - 4);
            eax_1 = (n << 2);
            esi = &esi[eax_1];
            edi = &edi[eax_1];
        label_1001416b:
            
            switch (edx_2)
            {
                case nullptr:
                {
                    return arg1;
                    break;
                }
                case 1:
                {
                label_1001418c:
                    eax_1 = *esi;
                    *edi = eax_1;
                    return arg1;
                    break;
                }
                case 2:
                {
                label_10014198:
                    eax_1 = *esi;
                    *edi = eax_1;
                    eax_1 = esi[1];
                    edi[1] = eax_1;
                    return arg1;
                    break;
                }
                case 3:
                {
                label_100141ac:
                    eax_1 = *esi;
                    *edi = eax_1;
                    eax_1 = esi[1];
                    edi[1] = eax_1;
                    eax_1 = esi[2];
                    edi[2] = eax_1;
                    return arg1;
                    break;
                }
            }
            break;
        }
    }
}

int32_t __convention("regparm") sub_100142c4(int32_t arg1, int32_t arg2, int32_t arg3, void* arg4 @ ebp, void* arg5 @ esi, void* arg6 @ edi, int32_t arg7)
{
    *((arg6 + (arg3 << 2)) + 0x1c) = *((arg5 + (arg3 << 2)) + 0x1c);
    *((arg6 + (arg3 << 2)) + 0x18) = *((arg5 + (arg3 << 2)) + 0x18);
    *((arg6 + (arg3 << 2)) + 0x14) = *((arg5 + (arg3 << 2)) + 0x14);
    *((arg6 + (arg3 << 2)) + 0x10) = *((arg5 + (arg3 << 2)) + 0x10);
    *((arg6 + (arg3 << 2)) + 0xc) = *((arg5 + (arg3 << 2)) + 0xc);
    *((arg6 + (arg3 << 2)) + 8) = *((arg5 + (arg3 << 2)) + 8);
    *((arg6 + (arg3 << 2)) + 4) = *((arg5 + (arg3 << 2)) + 4);
    int32_t eax_6 = (arg3 << 2);
    void* esi = (arg5 + eax_6);
    void* edi = (arg6 + eax_6);
    
    switch (arg2)
    {
        case 0:
        {
            *arg4;
            return *(arg4 + 8);
            break;
        }
        case 1:
        {
            eax_6 = *(esi + 3);
            *(edi + 3) = eax_6;
            *arg4;
            return *(arg4 + 8);
            break;
        }
        case 2:
        {
            eax_6 = *(esi + 3);
            *(edi + 3) = eax_6;
            eax_6 = *(esi + 2);
            *(edi + 2) = eax_6;
            *arg4;
            return *(arg4 + 8);
            break;
        }
        case 3:
        {
            eax_6 = *(esi + 3);
            *(edi + 3) = eax_6;
            eax_6 = *(esi + 2);
            *(edi + 2) = eax_6;
            eax_6 = *(esi + 1);
            *(edi + 1) = eax_6;
            *arg4;
            return *(arg4 + 8);
            break;
        }
    }
}

int32_t __getpid()
{
    return DebugBreak();
}

int32_t sub_10014380(int32_t arg1, PSTR arg2, int32_t arg3, void* arg4, int32_t arg5, int32_t arg6)
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    __chkstk(0x5050);
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x10041d38 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie_1 ^ &__saved_ebp);
    int32_t var_20 = eax_1;
    int32_t edi;
    int32_t var_28 = edi;
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_2028 = 0;
    int32_t var_3030 = 0;
    char lpOutputString_1 = 0;
    void var_4033;
    sub_1000fae0(&var_4033, 0, 0xfff);
    char var_302c = 0;
    void var_302b;
    sub_1000fae0(&var_302b, 0, 0xfff);
    int16_t var_2024 = 0;
    void var_2022;
    sub_1000fae0(&var_2022, 0, 0x1ffe);
    char var_5034 = 0;
    void var_5033;
    sub_1000fae0(&var_5033, 0, 0xfff);
    
    if ((arg1 >= 0 && arg1 < 3))
    {
        int32_t var_8_1 = 0;
        
        if (arg1 != 2)
        {
        label_10014528:
            
            if (arg5 != 0)
            {
                int32_t var_5038_1 = 0;
                int32_t ecx_2 = *sub_1000eca0();
                *sub_1000eca0() = 0;
                int32_t eax_9 = __vsnprintf_s(&var_5034, 0x1000, 0xfeb, arg5, arg6);
                
                if (eax_9 < 0)
                    sub_1000b4e0(*sub_1000eca0(), 0x16, 0x22, u"(*_errno())", u"_VCrtDbgReportA", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x12d, 0);
                
                *sub_1000eca0() = ecx_2;
                
                if (eax_9 < 0)
                    sub_1000b4b0(sub_10010280(&var_5034, 0x1000, "_CrtDbgReport: String too long o…"), u"strcpy_s(szUserMessage, 4096, "_…", u"_VCrtDbgReportA", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x130, 0);
            }
            
            if (arg1 == 2)
            {
                char const* const var_506c_1;
                
                if (arg5 == 0)
                    var_506c_1 = "Assertion failed!";
                else
                    var_506c_1 = "Assertion failed: ";
                
                sub_1000b4b0(sub_10010280(&lpOutputString_1, 0x1000, var_506c_1), u"strcpy_s(szLineMessage, 4096, sz…", u"_VCrtDbgReportA", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x135, 0);
            }
            
            sub_1000b4b0(sub_100254b0(&lpOutputString_1, 0x1000, &var_5034), u"strcat_s(szLineMessage, 4096, sz…", u"_VCrtDbgReportA", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x137, 0);
            
            if (arg1 == 2)
            {
                if ((*((arg1 << 2) + &data_10044304) & 1) != 0)
                    sub_1000b4b0(sub_100254b0(&lpOutputString_1, 0x1000, &data_10039910), u"strcat_s(szLineMessage, 4096, "\…", u"_VCrtDbgReportA", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13c, 0);
                
                sub_1000b4b0(sub_100254b0(&lpOutputString_1, 0x1000, &data_10039b30), u"strcat_s(szLineMessage, 4096, "\…", u"_VCrtDbgReportA", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13d, 0);
            }
            
            if (arg2 == 0)
                sub_1000b4b0(sub_10010280(&var_302c, 0x1000, &lpOutputString_1), u"strcpy_s(szOutMessage, 4096, szL…", u"_VCrtDbgReportA", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x14b, 0);
            else
            {
                int32_t var_5040_1 = 0;
                int32_t edx_6 = *sub_1000eca0();
                *sub_1000eca0() = 0;
                char* var_30_18 = &lpOutputString_1;
                int32_t var_34_12 = arg3;
                PSTR var_38_12 = arg2;
                int32_t eax_20 = __snwprintf_s(&var_302c, 0x1000, 0xfff, "%s(%d) : %s");
                
                if (eax_20 < 0)
                    sub_1000b4e0(*sub_1000eca0(), 0x16, 0x22, u"(*_errno())", u"_VCrtDbgReportA", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x144, 0);
                
                *sub_1000eca0() = edx_6;
                
                if (eax_20 < 0)
                    sub_1000b4b0(sub_10010280(&var_302c, 0x1000, "_CrtDbgReport: String too long o…"), u"strcpy_s(szOutMessage, 4096, "_C…", u"_VCrtDbgReportA", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x147, 0);
            }
            
            int32_t var_5048 = 0;
            int32_t var_504c_1 = 0;
            int32_t eax_25 = __Wcsftime(&var_5048, &var_2024, 0x1000, &var_302c, 0xffffffff);
            sub_1000b4e0(eax_25, 0x16, 0x22, u"e = mbstowcs_s(&ret, szOutMessag…", u"_VCrtDbgReportA", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x150, 0);
            
            if (eax_25 != 0)
                sub_1000b4b0(sub_1000fb90(&var_2024, 0x1000, u"_CrtDbgReport: String too long o…"), u"wcscpy_s(szOutMessage2, 4096, L"…", u"_VCrtDbgReportA", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x152, 0);
            
            if ((data_1004a3a8 != 0 || data_1004a3a4 != 0))
            {
                int32_t var_5054_1 = 0;
                int32_t var_5050_1 = 0;
                __lock(0xf);
                int32_t var_8_2 = 1;
                
                for (void* i = data_1004a3a8; i != 0; i = *(i + 4))
                {
                    int32_t var_5058 = 0;
                    
                    if (*(i + 0xc)(arg1, &var_302c, &var_5058, eax_1) != 0)
                    {
                        var_3030 = 1;
                        var_2028 = var_5058;
                        break;
                    }
                }
                
                if (var_3030 == 0)
                {
                    for (void* i_1 = data_1004a3a4; i_1 != 0; i_1 = *(i_1 + 4))
                    {
                        int32_t var_505c = 0;
                        
                        if (*(i_1 + 0xc)(arg1, &var_2024, &var_505c, eax_1) != 0)
                        {
                            var_3030 = 1;
                            var_2028 = var_505c;
                            break;
                        }
                    }
                }
                
                int32_t var_8_3 = 0;
                sub_10014a05();
            }
            
            if (var_3030 == 0)
            {
                if (data_1004a3a0 != 0)
                {
                    int32_t var_5060 = 0;
                    
                    if (data_1004a3a0(arg1, &var_302c, &var_5060, eax_1) != 0)
                    {
                        var_3030 = 1;
                        var_2028 = var_5060;
                    }
                }
                
                if (var_3030 == 0)
                {
                    if (((*((arg1 << 2) + &data_10044304) & 1) != 0 && *((arg1 << 2) + &data_10044310) != 0xffffffff))
                    {
                        OVERLAPPED* lpOverlapped = nullptr;
                        void var_5064;
                        void* lpNumberOfBytesWritten = &var_5064;
                        void* nNumberOfBytesToWrite = _strlen(&var_302c);
                        WriteFile(*((arg1 << 2) + &data_10044310), &var_302c, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
                    }
                    
                    if ((*((arg1 << 2) + &data_10044304) & 2) != 0)
                        OutputDebugStringA(&var_302c);
                    
                    if ((*((arg1 << 2) + &data_10044304) & 4) != 0)
                    {
                        lpOutputString_1 = 0;
                        
                        if (arg3 != 0)
                            sub_1000b4b0(sub_10025890(arg3, &lpOutputString_1, 0x1000, 0xa), u"_itoa_s(nLine, szLineMessage, 40…", u"_VCrtDbgReportA", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x1a2, 0);
                        
                        int32_t edx_19 = -(arg3);
                        var_2028 = sub_1000edd0(arg1, arg2, ((edx_19 - edx_19) & &lpOutputString_1), arg4, &var_5034);
                    }
                }
            }
        }
        else
        {
            if (InterlockedIncrement(0x10044300) <= 0)
                goto label_10014528;
            
            sub_1000b4b0(sub_10025890(arg3, &lpOutputString_1, 0x1000, 0xa), u"_itoa_s(nLine, szLineMessage, 40…", u"_VCrtDbgReportA", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x119, 0);
            OutputDebugStringA("Second Chance Assertion Failed: …");
            PSTR lpOutputString;
            
            if (arg2 == 0)
                lpOutputString = "<file unknown>";
            else
                lpOutputString = arg2;
            
            OutputDebugStringA(lpOutputString);
            OutputDebugStringA(", Line ");
            OutputDebugStringA(&lpOutputString_1);
            OutputDebugStringA(&data_10039b30);
            __getpid();
            var_2028 = 0xffffffff;
        }
        
        int32_t var_8_4 = 0xfffffffe;
        $LN52(&__saved_ebp);
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    int32_t ebx;
    return sub_1000ac70((ebx ^ &__saved_ebp));
}

int32_t sub_10014a05()
{
    return __unlock(0xf);
}

void $LN52(void* arg1 @ ebp)
{
    if (*(arg1 + 8) == 2)
        InterlockedDecrement(0x10044300);
}

int32_t sub_10014bb0(int32_t arg1, PWSTR arg2, int32_t arg3, void* arg4, int32_t arg5, int32_t arg6)
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    __chkstk(0x805c);
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x10041d60 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie_1 ^ &__saved_ebp);
    int32_t var_20 = eax_1;
    int32_t edi;
    int32_t var_28 = edi;
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_1028 = 0;
    int32_t var_3030 = 0;
    int16_t lpOutputString_1 = 0;
    void var_5032;
    sub_1000fae0(&var_5032, 0, 0x1ffe);
    int16_t var_302c = 0;
    void var_302a;
    sub_1000fae0(&var_302a, 0, 0x1ffe);
    char var_1024 = 0;
    void var_1023;
    sub_1000fae0(&var_1023, 0, 0xfff);
    int16_t var_7034 = 0;
    void var_7032;
    sub_1000fae0(&var_7032, 0, 0x1ffe);
    
    if ((arg1 >= 0 && arg1 < 3))
    {
        int32_t var_8_1 = 0;
        
        if (arg1 != 2)
        {
        label_10014d5c:
            
            if (arg5 != 0)
            {
                int32_t eax_7 = *sub_1000eca0();
                *sub_1000eca0() = 0;
                int32_t eax_9 = __vsnwprintf_s(&var_7034, 0x1000, 0xfeb, arg5, arg6);
                
                if (eax_9 < 0)
                    sub_1000b4e0(*sub_1000eca0(), 0x16, 0x22, u"(*_errno())", u"_VCrtDbgReportW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x206, 0);
                
                *sub_1000eca0() = eax_7;
                
                if (eax_9 < 0)
                    sub_1000b4b0(sub_1000fb90(&var_7034, 0x1000, u"_CrtDbgReport: String too long o…"), u"wcscpy_s(szUserMessage, 4096, L"…", u"_VCrtDbgReportW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x209, 0);
            }
            
            if (arg1 == 2)
            {
                wchar16 const* const var_8074_1;
                
                if (arg5 == 0)
                    var_8074_1 = u"Assertion failed!";
                else
                    var_8074_1 = u"Assertion failed: ";
                
                sub_1000b4b0(sub_1000fb90(&lpOutputString_1, 0x1000, var_8074_1), u"wcscpy_s(szLineMessage, 4096, sz…", u"_VCrtDbgReportW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x20e, 0);
            }
            
            sub_1000b4b0(sub_100264b0(&lpOutputString_1, 0x1000, &var_7034), u"wcscat_s(szLineMessage, 4096, sz…", u"_VCrtDbgReportW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x210, 0);
            
            if (arg1 == 2)
            {
                if ((*((arg1 << 2) + &data_10044304) & 1) != 0)
                    sub_1000b4b0(sub_100264b0(&lpOutputString_1, 0x1000, &data_10039ec4), u"wcscat_s(szLineMessage, 4096, L"…", u"_VCrtDbgReportW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x215, 0);
                
                sub_1000b4b0(sub_100264b0(&lpOutputString_1, 0x1000, &data_10040868), u"wcscat_s(szLineMessage, 4096, L"…", u"_VCrtDbgReportW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x217, 0);
            }
            
            if (arg2 == 0)
                sub_1000b4b0(sub_1000fb90(&var_302c, 0x1000, &lpOutputString_1), u"wcscpy_s(szOutMessage, 4096, szL…", u"_VCrtDbgReportW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x225, 0);
            else
            {
                int32_t var_7040_1 = 0;
                int32_t eax_20 = *sub_1000eca0();
                *sub_1000eca0() = 0;
                int16_t* var_30_18 = &lpOutputString_1;
                int32_t var_34_12 = arg3;
                PWSTR var_38_12 = arg2;
                int32_t eax_23 = sub_1000fb60(&var_302c, 0x1000, 0x1000, u"%s(%d) : %s");
                
                if (eax_23 < 0)
                    sub_1000b4e0(*sub_1000eca0(), 0x16, 0x22, u"(*_errno())", u"_VCrtDbgReportW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x21f, 0);
                
                *sub_1000eca0() = eax_20;
                
                if (eax_23 < 0)
                    sub_1000b4b0(sub_1000fb90(&var_302c, 0x1000, u"_CrtDbgReport: String too long o…"), u"wcscpy_s(szOutMessage, 4096, L"_…", u"_VCrtDbgReportW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x221, 0);
            }
            
            int32_t var_7048_1 = 0;
            
            if (sub_1000b4e0(_wcstombs_s(nullptr, &var_1024, 0x1000, &var_302c, 0xffffffff), 0x16, 0x22, u"wcstombs_s(((void *)0), szOutMes…", u"_VCrtDbgReportW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x22b, 0) != 0)
                sub_1000b4b0(sub_10010280(&var_1024, 0x1000, "_CrtDbgReport: String too long o…"), u"strcpy_s(szOutMessage2, 4096, "_…", u"_VCrtDbgReportW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x22d, 0);
            
            if ((data_1004a3a8 != 0 || data_1004a3a4 != 0))
            {
                int32_t var_7050_1 = 0;
                int32_t var_704c_1 = 0;
                __lock(0xf);
                int32_t var_8_2 = 1;
                
                for (void* i = data_1004a3a8; i != 0; i = *(i + 4))
                {
                    int32_t var_7054 = 0;
                    
                    if (*(i + 0xc)(arg1, &var_1024, &var_7054, eax_1) != 0)
                    {
                        var_1028 = var_7054;
                        var_3030 = 1;
                        break;
                    }
                }
                
                if (var_3030 == 0)
                {
                    for (void* i_1 = data_1004a3a4; i_1 != 0; i_1 = *(i_1 + 4))
                    {
                        int32_t var_7058 = 0;
                        
                        if (*(i_1 + 0xc)(arg1, &var_302c, &var_7058, eax_1) != 0)
                        {
                            var_1028 = var_7058;
                            var_3030 = 1;
                            break;
                        }
                    }
                }
                
                int32_t var_8_3 = 0;
                sub_1001521a();
            }
            
            if (var_3030 == 0)
            {
                if (data_1004a3a0 != 0)
                {
                    int32_t var_705c = 0;
                    
                    if (data_1004a3a0(arg1, &var_1024, &var_705c, eax_1) != 0)
                    {
                        var_1028 = var_705c;
                        var_3030 = 1;
                    }
                }
                
                if (var_3030 == 0)
                {
                    if (((*((arg1 << 2) + &data_10044304) & 1) != 0 && *((arg1 << 2) + &data_10044310) != 0xffffffff))
                    {
                        void lpNumberOfBytesWritten;
                        
                        if (GetFileType(*((arg1 << 2) + &data_10044310)) == FILE_TYPE_CHAR)
                        {
                            int32_t lpReserved = 0;
                            void* lpNumberOfCharsWritten = &lpNumberOfBytesWritten;
                            uint32_t nNumberOfCharsToWrite = sub_100136b0(&var_302c);
                            
                            if ((WriteConsoleW(*((arg1 << 2) + &data_10044310), &var_302c, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved) == 0 && GetLastError() == ERROR_INVALID_HANDLE))
                                goto label_10015317;
                        }
                        else
                        {
                        label_10015317:
                            uint32_t nNumberOfBytesToWrite = 0;
                            void lpBuffer;
                            int32_t eax_45 = sub_1000b4e0(_wcstombs_s(&nNumberOfBytesToWrite, &lpBuffer, 0x1000, &var_302c, 0xffffffff), 0x16, 0x22, u"wcstombs_s(&ret, szaOutMessage, …", u"_VCrtDbgReportW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x27e, 0);
                            
                            if ((eax_45 == 0 || eax_45 == 0x50))
                            {
                                if (nNumberOfBytesToWrite > 0)
                                    nNumberOfBytesToWrite -= 1;
                                
                                WriteFile(*((arg1 << 2) + &data_10044310), &lpBuffer, nNumberOfBytesToWrite, &lpNumberOfBytesWritten, nullptr);
                            }
                            else
                            {
                                OVERLAPPED* lpOverlapped = nullptr;
                                void* lpNumberOfBytesWritten_1 = &lpNumberOfBytesWritten;
                                int32_t nNumberOfBytesToWrite_1 = (sub_100136b0(&var_302c) << 1);
                                WriteFile(*((arg1 << 2) + &data_10044310), &var_302c, nNumberOfBytesToWrite_1, lpNumberOfBytesWritten_1, lpOverlapped);
                            }
                        }
                    }
                    
                    if ((*((arg1 << 2) + &data_10044304) & 2) != 0)
                        OutputDebugStringW(&var_302c);
                    
                    if ((*((arg1 << 2) + &data_10044304) & 4) != 0)
                    {
                        lpOutputString_1 = 0;
                        
                        if (arg3 != 0)
                            sub_1000b4b0(sub_100268a0(arg3, &lpOutputString_1, 0x1000, 0xa), u"_itow_s(nLine, szLineMessage, 40…", u"_VCrtDbgReportW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x29c, 0);
                        
                        int32_t ecx_24 = -(arg3);
                        var_1028 = sub_1000b0b0(arg1, arg2, ((ecx_24 - ecx_24) & &lpOutputString_1), arg4, &var_7034);
                    }
                }
            }
        }
        else
        {
            if (InterlockedIncrement(0x10044300) <= 0)
                goto label_10014d5c;
            
            sub_1000b4b0(sub_100268a0(arg3, &lpOutputString_1, 0x1000, 0xa), u"_itow_s(nLine, szLineMessage, 40…", u"_VCrtDbgReportW", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x1f0, 0);
            OutputDebugStringW(u"Second Chance Assertion Failed: …");
            PWSTR lpOutputString;
            
            if (arg2 == 0)
                lpOutputString = u"<file unknown>";
            else
                lpOutputString = arg2;
            
            OutputDebugStringW(lpOutputString);
            OutputDebugStringW(u", Line ");
            OutputDebugStringW(&lpOutputString_1);
            OutputDebugStringW(&data_10040868);
            __getpid();
            var_1028 = 0xffffffff;
        }
        
        int32_t var_8_4 = 0xfffffffe;
        $LN61(&__saved_ebp);
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    int32_t ebx;
    return sub_1000ac70((ebx ^ &__saved_ebp));
}

int32_t sub_1001521a()
{
    return __unlock(0xf);
}

void $LN61(void* arg1 @ ebp)
{
    if (*(arg1 + 8) == 2)
        InterlockedDecrement(0x10044300);
}

HMODULE sub_100154e0(PWSTR arg1)
{
    uint32_t dwMilliseconds = 0x3e8;
    HMODULE i = nullptr;
    
    while (i == 0)
    {
        Sleep(dwMilliseconds);
        i = GetModuleHandleW(arg1);
        dwMilliseconds += 0x3e8;
        
        if (dwMilliseconds > 0xea60)
            break;
    }
    
    return i;
}

int32_t __convention("regparm") sub_10015540(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    if ((data_1004a398 != 0 && sub_10024600(0x1004a398) != 0))
        data_1004a398(arg4, arg3);
    
    sub_10026c80();
    int32_t result = __initterm_e(&data_10036260, 0x10036274);
    
    if (result != 0)
        return result;
    
    sub_1000cf10(sub_1001d6d0);
    __initterm(&data_100361b0, 0x1003625c);
    
    if ((data_1004a39c != 0 && sub_10024600(0x1004a39c) != 0))
        data_1004a39c(0, 2, 0);
    
    return 0;
}

int32_t sub_100155e0(uint32_t arg1)
{
    return sub_100157b0(arg1, 1, 0);
}

int32_t __cexit()
{
    return sub_100157b0(0, 0, 1);
}

int32_t sub_10015620(int32_t arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    __FF_MSGBANNER();
    sub_10024990(arg1);
    int32_t eax_1 = sub_10018b70(data_1004431c);
    return eax_1(0xff, eax_1);
}

int32_t sub_10015660()
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    for (int32_t* i = data_10045aec; i != 0; i = &i[1])
    {
        if (*i == 0)
            break;
        
        sub_10011340(*i, 2);
    }
    
    sub_10011340(data_10045aec, 2);
    data_10045aec = 0;
    int32_t* i_1;
    
    for (i_1 = data_10045ae4; i_1 != 0; i_1 = &i_1[1])
    {
        if (*i_1 == 0)
            break;
        
        sub_10011340(*i_1, 2);
    }
    
    sub_10011340(data_10045ae4, 2);
    data_10045ae4 = 0;
    sub_10011340(data_10045ae0, 2);
    sub_10011340(data_10045adc, 2);
    sub_10011340(sub_10018b70(data_1004a390), 2);
    data_10045ae0 = 0;
    data_10045adc = 0;
    data_1004a390 = __Getmonths();
    
    if ((InterlockedDecrement(data_10044a38, i_1) == 0 && data_10044a38 != 0x10044610))
    {
        sub_10011340(data_10044a38, 2);
        data_10044a38 = &data_10044610;
    }
    
    return InterlockedIncrement(data_10044a38);
}

int32_t sub_100157b0(uint32_t arg1, int32_t arg2, char arg3)
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_44 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x10041d88 ^ __security_cookie_1);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    sub_10015a10();
    int32_t var_8_1 = 0;
    int32_t __saved_ebp;
    
    if (data_10045b04 != 1)
    {
        data_10045b00 = 1;
        data_10045afc = arg3;
        
        if (arg2 == 0)
        {
            int32_t var_20_1 = sub_10018b70(data_1004a390);
            
            if (var_20_1 != 0)
            {
                int32_t* var_2c_1 = sub_10018b70(data_1004a38c);
                int32_t var_28_1 = 0;
                int32_t var_30_1 = var_20_1;
                int32_t* var_24_1 = var_2c_1;
                
                while (true)
                {
                    int32_t var_34_1 = 0;
                    int32_t var_38_1 = 0;
                    int32_t i;
                    
                    do
                    {
                        var_2c_1 -= 4;
                        
                        if (var_2c_1 < var_20_1)
                            break;
                        
                        i = __Getmonths();
                    } while (*var_2c_1 == i);
                    
                    if (var_2c_1 < var_20_1)
                        break;
                    
                    int32_t eax_9 = sub_10018b70(*var_2c_1);
                    *var_2c_1 = __Getmonths();
                    eax_9((__security_cookie_1 ^ &__saved_ebp));
                    int32_t eax_11 = sub_10018b70(data_1004a390);
                    int32_t* eax_13 = sub_10018b70(data_1004a38c);
                    
                    if ((var_30_1 == eax_11 && var_24_1 == eax_13))
                        continue;
                    
                    var_30_1 = eax_11;
                    var_20_1 = var_30_1;
                    var_24_1 = eax_13;
                    var_2c_1 = var_24_1;
                }
            }
            
            __initterm(&data_10036278, 0x10036288);
        }
        
        __initterm(&data_1003628c, 0x10036290);
        
        if ((data_10045b08 == 0 && (sub_10011f60(0xffffffff) & 0x20) != 0))
        {
            data_10045b08 = 1;
            sub_10015660();
            sub_10012980();
        }
    }
    
    int32_t var_8_2 = 0xfffffffe;
    int32_t result = sub_10015968(&__saved_ebp);
    
    if (arg3 != 0)
    {
        fsbase->NtTib.ExceptionList = ExceptionList;
        return result;
    }
    
    data_10045b04 = 1;
    sub_10015a30();
    sub_100159f0(arg1);
    /* no return */
}

void sub_10015968(void* arg1 @ ebp)
{
    if (*(arg1 + 0x10) != 0)
        sub_10015a30();
}

HMODULE sub_100159b0(int32_t arg1)
{
    HMODULE hModule = GetModuleHandleW(u"mscoree.dll");
    
    if (hModule != 0)
    {
        hModule = GetProcAddress(hModule, "CorExitProcess");
        
        if (hModule != 0)
            return hModule(arg1);
    }
    
    return hModule;
}

void sub_100159f0(uint32_t arg1) __noreturn
{
    sub_100159b0(arg1);
    ExitProcess(arg1);
    /* no return */
}

int32_t sub_10015a10()
{
    return __lock(8);
}

int32_t sub_10015a30()
{
    return __unlock(8);
}

void* sub_10015a50()
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t eax = __Getmonths();
    __initp_misc_purevirt(eax);
    ___set_app_type(eax);
    __initp_misc_invarg(eax);
    __set_wpgmptr(eax);
    __initp_misc_rand_s(eax);
    __initp_misc_winsig(eax);
    int32_t var_c_6 = eax;
    int32_t var_c_7 = eax;
    sub_10016160();
    void* result = sub_10018a80(sub_100155e0);
    data_1004431c = result;
    return result;
}

int32_t* __initterm(int32_t* arg1, int32_t arg2)
{
    for (; arg1 < arg2; arg1 = &arg1[1])
    {
        if (*arg1 != 0)
            *arg1();
    }
    
    return arg1;
}

int32_t __initterm_e(int32_t* arg1, int32_t arg2)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t result = 0;
    
    for (; arg1 < arg2; arg1 = &arg1[1])
    {
        if (result != 0)
            break;
        
        if (*arg1 != 0)
            result = *arg1(result);
    }
    
    return result;
}

int32_t __initp_misc_winsig(int32_t arg1)
{
    data_10045b0c = arg1;
    data_10045b10 = arg1;
    data_10045b14 = arg1;
    data_10045b18 = arg1;
    return arg1;
}

int32_t sub_10015b80(int32_t arg1)
{
    int32_t __saved_ebp_2;
    int32_t __saved_ebp_1 = __saved_ebp_2;
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041da8;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t ebx;
    int32_t var_48 = ebx;
    int32_t esi;
    int32_t var_4c = esi;
    int32_t edi;
    int32_t var_50 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_54 = (__security_cookie_1 ^ &__saved_ebp);
    int32_t* esp_1 = &var_54;
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_2c = 0;
    void* var_24 = nullptr;
    int32_t result;
    void* var_34;
    void* var_20;
    int32_t var_20_1;
    void* var_58;
    
    if ((arg1 - 2) > 0x14)
    {
    label_10015ca9:
        int32_t var_44_1 = 0;
        
        if (var_44_1 == 0)
        {
            var_58 = u"("Invalid signal or error", 0)";
            int32_t var_5c_2 = 0;
            int32_t var_60_1 = 0x1f4;
            wchar16 const* const var_64_1 = u"f:\dd\vctools\crt_bld\self_x86\c…";
            int32_t var_68_1 = 2;
            
            if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x1f4, nullptr, var_58) == 1)
                breakpoint();
        }
        
        if (var_44_1 != 0)
            goto label_10015d17;
        
        *sub_1000eca0() = 0x16;
        var_58 = nullptr;
        int32_t var_5c_3 = 0x1f4;
        wchar16 const* const var_60_2 = u"f:\dd\vctools\crt_bld\self_x86\c…";
        wchar16 const* const var_64_2 = u"raise";
        wchar16 const* const var_68_2 = u"("Invalid signal or error", 0)";
        sub_1000c310(u"("Invalid signal or error", 0)", u"raise", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x1f4, var_58);
        esp_1 = &var_54;
        result = 0xffffffff;
    }
    else
        switch (arg1)
        {
            case 2:
            {
                var_34 = &data_10045b0c;
                var_20 = data_10045b0c;
                var_2c = 1;
            label_10015d17:
                var_58 = var_20;
                esp_1 = &var_54;
                var_20_1 = sub_10018b70(var_58);
            label_10015d23:
                
                if (var_20_1 != 1)
                {
                    if (var_20_1 == 0)
                    {
                        var_58 = 3;
                        esp_1 = &var_58;
                        sub_100155e0(var_58);
                    }
                    
                    if (var_2c != 0)
                    {
                        *(esp_1 - 4) = 0;
                        __lock();
                    }
                    
                    int32_t var_8_1 = 0;
                    int32_t var_38;
                    int32_t var_28;
                    
                    if (((arg1 == 8 || arg1 == 0xb) || arg1 == 4))
                    {
                        var_28 = *(var_24 + 0x60);
                        *(var_24 + 0x60) = 0;
                        
                        if (arg1 == 8)
                        {
                            var_38 = *(var_24 + 0x64);
                            *(var_24 + 0x64) = 0x8c;
                        }
                    }
                    
                    if (arg1 != 8)
                        *var_34 = __Getmonths();
                    else
                    {
                        for (int32_t i = data_100445f4; i < (data_100445f4 + data_100445f8); i += 1)
                            *((*(var_24 + 0x5c) + (i * 0xc)) + 8) = 0;
                    }
                    
                    int32_t var_8_2 = 0xfffffffe;
                    sub_10015dec(&__saved_ebp);
                    
                    if (arg1 != 8)
                    {
                        *(esp_1 - 4) = arg1;
                        var_20_1();
                    }
                    else
                    {
                        *(esp_1 - 4) = *(var_24 + 0x64);
                        *(esp_1 - 8) = 8;
                        var_20_1();
                    }
                    
                    if (((arg1 == 8 || arg1 == 0xb) || arg1 == 4))
                    {
                        *(var_24 + 0x60) = var_28;
                        
                        if (arg1 == 8)
                            *(var_24 + 0x64) = var_38;
                    }
                    
                    result = 0;
                }
                else
                    result = 0;
                break;
            }
            case 3:
            case 5:
            case 7:
            case 9:
            case 0xa:
            case 0xc:
            case 0xd:
            case 0xe:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            {
                goto label_10015ca9;
            }
            case 4:
            case 8:
            case 0xb:
            {
                var_24 = sub_10019040();
                
                if (var_24 != 0)
                {
                    var_58 = *(var_24 + 0x5c);
                    esp_1 = &var_54;
                    var_34 = (_siglookup(arg1, var_58) + 8);
                    var_20_1 = *var_34;
                    goto label_10015d23;
                }
                
                result = 0xffffffff;
                break;
            }
            case 6:
            case 0x16:
            {
                var_34 = &data_10045b14;
                var_20 = data_10045b14;
                var_2c = 1;
                goto label_10015d17;
            }
            case 0xf:
            {
                var_34 = &data_10045b18;
                var_20 = data_10045b18;
                var_2c = 1;
                goto label_10015d17;
            }
            case 0x15:
            {
                var_34 = &data_10045b10;
                var_20 = data_10045b10;
                var_2c = 1;
                goto label_10015d17;
            }
        }
    fsbase->NtTib.ExceptionList = ExceptionList;
    *esp_1;
    esp_1[1];
    esp_1[2];
    esp_1[3];
    return result;
}

void sub_10015dec(void* arg1 @ ebp)
{
    if (*(arg1 - 0x28) != 0)
        __unlock(0);
}

void* _siglookup(int32_t arg1, void* arg2)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    void* result = arg2;
    
    while (*(result + 4) != arg1)
    {
        result += 0xc;
        
        if (result >= ((data_10044600 * 0xc) + arg2))
            break;
    }
    
    if ((result < ((data_10044600 * 0xc) + arg2) && *(result + 4) == arg1))
        return result;
    
    return nullptr;
}

int32_t sub_10015ef0()
{
    return sub_10018b70(data_10045b14);
}

int32_t sub_10015f10(int32_t arg1, int32_t arg2, int32_t arg3)
{
    int32_t var_20 = 0;
    int32_t eax = __Getmonths();
    int32_t var_1c = 0;
    int32_t var_28 = 0;
    int32_t var_18 = 0;
    
    if (data_10045b20 == 0)
    {
        HMODULE hModule = LoadLibraryW(u"USER32.DLL");
        
        if (hModule == 0)
            return 0;
        
        int32_t eax_3 = GetProcAddress(hModule, "MessageBoxW");
        
        if (eax_3 == 0)
            return 0;
        
        data_10045b20 = sub_10018a80(eax_3);
        data_10045b24 = sub_10018a80(GetProcAddress(hModule, "GetActiveWindow"));
        data_10045b28 = sub_10018a80(GetProcAddress(hModule, "GetLastActivePopup"));
        data_10045b30 = sub_10018a80(GetProcAddress(hModule, "GetUserObjectInformationW"));
        
        if (data_10045b30 != 0)
            data_10045b2c = sub_10018a80(GetProcAddress(hModule, "GetProcessWindowStation"));
    }
    
    if ((data_10045b2c != eax && data_10045b30 != eax))
    {
        int32_t eax_16 = sub_10018b70(data_10045b2c);
        int32_t eax_17 = sub_10018b70(data_10045b30);
        
        if ((eax_16 != 0 && eax_17 != 0))
        {
            int32_t eax_18 = eax_16();
            int32_t eax_19;
            void var_24;
            void var_14;
            
            if (eax_18 != 0)
                eax_19 = eax_17(eax_18, 1, &var_14, 0xc, &var_24);
            int32_t var_c;
            
            if (((eax_18 == 0 || eax_19 == 0) || (var_c & 1) == 0))
                var_28 = 1;
        }
    }
    
    if (var_28 == 0)
    {
        if (data_10045b24 != eax)
        {
            int32_t eax_22 = sub_10018b70(data_10045b24);
            
            if (eax_22 != 0)
                var_1c = eax_22();
        }
        
        if ((var_1c != 0 && data_10045b28 != eax))
        {
            int32_t eax_25 = sub_10018b70(data_10045b28);
            
            if (eax_25 != 0)
                var_1c = eax_25(var_1c);
        }
    }
    else
        arg3 |= 0x200000;
    
    int32_t eax_28 = sub_10018b70(data_10045b20);
    
    if (eax_28 == 0)
        return 0;
    
    return eax_28(var_1c, arg1, arg2, arg3);
}

void* const __convention("regparm") __chkstk(int32_t arg1)
{
    void* ecx_1 = ((&__return_addr - arg1) & !((arg1 - arg1)));
    int32_t __saved_ecx;
    void* eax_2 = (&__saved_ecx & 0xfffff000);
    
    while (ecx_1 < eax_2)
    {
        eax_2 -= 0x1000;
        *eax_2;
    }
    
    void* const result = __return_addr;
    *ecx_1 = result;
    return result;
}

int32_t sub_10016160()
{
    int32_t result = sub_10018a80(sub_10016180);
    data_10045b34 = result;
    return result;
}

int32_t sub_10016180()
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041dc8;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_2c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_30 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_1c = &var_30;
    int32_t eax_3 = *(__getptd() + 0x78);
    
    if (eax_3 != 0)
    {
        int32_t var_8_1 = 0;
        eax_3();
        int32_t var_8_2 = 0xfffffffe;
    }
    
    int32_t result = sub_10026f90();
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_100161d9() __pure
{
    return 1;
}

int32_t sub_10016200()
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t eax_1 = *(__getptd() + 0x7c);
    
    if (eax_1 != 0)
        eax_1(eax_1);
    
    return sub_10016180();
}

int32_t sub_10016230()
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041de8;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_2c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_30 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_1c = &var_30;
    int32_t eax_3 = sub_10018b70(data_10045b34);
    
    if (eax_3 != 0)
    {
        int32_t var_8_1 = 0;
        eax_3();
        int32_t var_8_2 = 0xfffffffe;
    }
    
    int32_t result = sub_10016180();
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1001628f() __pure
{
    return 1;
}

uint32_t sub_100162c0(int32_t* arg1)
{
    if ((arg1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x64, nullptr, u"str != NULL") == 1))
        breakpoint();
    
    PWSTR eax_2 = sub_10019e20(arg1);
    
    if ((arg1[3] & 0x82) == 0)
    {
        *sub_1000eca0() = 9;
        arg1[3] |= 0x20;
        return 0xffffffff;
    }
    
    if ((arg1[3] & 0x40) != 0)
    {
        *sub_1000eca0() = 0x22;
        arg1[3] |= 0x20;
        return 0xffffffff;
    }
    
    if ((arg1[3] & 1) != 0)
    {
        arg1[1] = 0;
        
        if ((arg1[3] & 0x10) == 0)
        {
            arg1[3] |= 0x20;
            return 0xffffffff;
        }
        
        *arg1 = arg1[2];
        arg1[3] &= 0xfffffffe;
    }
    
    arg1[3] |= 2;
    arg1[3] &= 0xffffffef;
    arg1[1] = 0;
    void* var_10_1 = nullptr;
    
    if ((arg1[3] & 0x10c) == 0)
    {
        if ((arg1 == 0x10044350 || arg1 == 0x10044370))
        {
            if (sub_10027410(eax_2) == 0)
                sub_10019ea0(arg1);
        }
        else
            sub_10019ea0(arg1);
    }
    
    uint32_t var_8_1;
    
    if ((arg1[3] & 0x108) == 0)
    {
        var_8_1 = 1;
        var_10_1 = sub_1001aef0(eax_2, &arg_4, 1);
    }
    else
    {
        arg1[2];
        
        if (((*arg1 - arg1[2]) < 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xa0, nullptr, u"("inconsistent IOB fields", stre…") == 1))
            breakpoint();
        
        var_8_1 = (*arg1 - arg1[2]);
        *arg1 = (arg1[2] + 1);
        arg1[1] = (arg1[6] - 1);
        
        if (var_8_1 <= 0)
        {
            void* var_18_1;
            
            if ((eax_2 == 0xffffffff || eax_2 == 0xfffffffe))
                var_18_1 = &data_100445b0;
            else
                var_18_1 = (((eax_2 & 0x1f) << 6) + &data_10049260[(eax_2 >> 5)]);
            
            if ((*(var_18_1 + 4) & 0x20) != 0)
            {
                uint32_t eax_31;
                int32_t edx_27;
                eax_31 = sub_100270d0(eax_2, 0, 0, FILE_END);
                
                if ((eax_31 & edx_27) == 0xffffffff)
                {
                    arg1[3] |= 0x20;
                    return 0xffffffff;
                }
            }
        }
        else
            var_10_1 = sub_1001aef0(eax_2, arg1[2], var_8_1);
        
        void* eax_30;
        eax_30 = arg_4;
        *arg1[2] = eax_30;
    }
    
    if (var_10_1 == var_8_1)
        return arg_4;
    
    arg1[3] |= 0x20;
    return 0xffffffff;
}

int32_t sub_10016580(int16_t** arg1, int16_t* arg2, void** arg3)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    int32_t var_464 = 0;
    int32_t var_14 = 0;
    int32_t var_1c = 0;
    int32_t var_34 = 0;
    int32_t* var_20 = nullptr;
    int32_t var_2c = 0;
    int32_t var_10 = 0;
    void var_44;
    _LocaleUpdate::_LocaleUpdate(&var_44, arg3);
    int32_t var_24 = 0;
    int32_t ecx_1;
    ecx_1 = arg1 != 0;
    
    if ((ecx_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x402, nullptr, u"(stream != NULL)") == 1))
        breakpoint();
    
    if (ecx_1 != 0)
    {
        int32_t eax_6;
        eax_6 = arg2 != 0;
        
        if ((eax_6 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x407, nullptr, u"(format != NULL)") == 1))
            breakpoint();
        
        if (eax_6 != 0)
        {
            int32_t var_450 = 0;
            int32_t i = 0;
            int32_t var_460_1 = 0;
            void* var_24_1 = nullptr;
            int32_t var_48_1 = 0;
            
            while (true)
            {
                eax_6 = *arg2;
                int16_t var_458_1 = eax_6;
                arg2 = &arg2[1];
                
                if ((var_458_1 != 0 && var_450 >= 0))
                {
                    int32_t var_4d0_1;
                    
                    if ((var_458_1 < 0x20 || var_458_1 > 0x78))
                        var_4d0_1 = 0;
                    else
                        var_4d0_1 = (*(var_458_1 + 0x1003b2e0) & 0xf);
                    
                    var_460_1 = (*((var_460_1 + (var_4d0_1 << 3)) + 0x1003b300) >> 4);
                    int32_t var_4dc;
                    int32_t var_4d8;
                    int32_t var_30;
                    
                    if (var_460_1 > 7)
                        continue;
                    else
                        switch (var_460_1)
                        {
                            case 0:
                            {
                            label_100167d1:
                                var_10 = 1;
                                _write_char(var_458_1, arg1, &var_450);
                                continue;
                            }
                            case 1:
                            {
                                var_30 = 0;
                                var_2c = 0;
                                var_1c = 0;
                                var_20 = nullptr;
                                var_14 = 0;
                                var_34 = 0xffffffff;
                                var_10 = 0;
                                continue;
                            }
                            case 2:
                            {
                                var_4d8 = (var_458_1 - 0x20);
                                
                                if (var_4d8 > 0x10)
                                    continue;
                                else
                                    switch (var_4d8)
                                    {
                                        case 0:
                                        {
                                            var_14 |= 2;
                                            continue;
                                        }
                                        case 1:
                                        case 2:
                                        case 4:
                                        case 5:
                                        case 6:
                                        case 7:
                                        case 8:
                                        case 9:
                                        case 0xa:
                                        case 0xc:
                                        case 0xe:
                                        case 0xf:
                                        {
                                            continue;
                                        }
                                        case 3:
                                        {
                                            var_14 |= 0x80;
                                            continue;
                                        }
                                        case 0xb:
                                        {
                                            var_14 |= 1;
                                            continue;
                                        }
                                        case 0xd:
                                        {
                                            var_14 |= 4;
                                            continue;
                                        }
                                        case 0x10:
                                        {
                                            var_14 |= 8;
                                            continue;
                                        }
                                    }
                                break;
                            }
                            case 3:
                            {
                                if (var_458_1 != 0x2a)
                                {
                                    var_1c = (((var_1c * 0xa) + var_458_1) - 0x30);
                                    continue;
                                }
                                else
                                {
                                    var_1c = _get_int_arg(&arg_10);
                                    
                                    if (var_1c >= 0)
                                        continue;
                                    else
                                    {
                                        var_14 |= 4;
                                        var_1c = -(var_1c);
                                        continue;
                                    }
                                }
                                break;
                            }
                            case 4:
                            {
                                var_34 = 0;
                                continue;
                            }
                            case 5:
                            {
                                if (var_458_1 != 0x2a)
                                {
                                    var_34 = (((var_34 * 0xa) + var_458_1) - 0x30);
                                    continue;
                                }
                                else
                                {
                                    var_34 = _get_int_arg(&arg_10);
                                    
                                    if (var_34 >= 0)
                                        continue;
                                    else
                                    {
                                        var_34 = 0xffffffff;
                                        continue;
                                    }
                                }
                                break;
                            }
                            case 6:
                            {
                                var_4dc = (var_458_1 - 0x49);
                                
                                if (var_4dc > 0x2e)
                                    continue;
                                else
                                    switch (var_4dc)
                                    {
                                        case 0:
                                        {
                                            if ((*arg2 == 0x36 && *(arg2 + 2) == 0x34))
                                            {
                                                arg2 = &arg2[2];
                                                var_14 |= 0x8000;
                                                continue;
                                            }
                                            
                                            if ((*arg2 == 0x33 && *(arg2 + 2) == 0x32))
                                            {
                                                arg2 = &arg2[2];
                                                var_14 &= 0xffff7fff;
                                                continue;
                                            }
                                            
                                            if (*arg2 == 0x64)
                                                continue;
                                            else if (*arg2 == 0x69)
                                                continue;
                                            else if (*arg2 == 0x6f)
                                                continue;
                                            else if (*arg2 == 0x75)
                                                continue;
                                            else if (*arg2 == 0x78)
                                                continue;
                                            else if (*arg2 != 0x58)
                                                var_460_1 = 0;
                                            else
                                                continue;
                                            break;
                                        }
                                        case 1:
                                        case 2:
                                        case 3:
                                        case 4:
                                        case 5:
                                        case 6:
                                        case 7:
                                        case 8:
                                        case 9:
                                        case 0xa:
                                        case 0xb:
                                        case 0xc:
                                        case 0xd:
                                        case 0xe:
                                        case 0xf:
                                        case 0x10:
                                        case 0x11:
                                        case 0x12:
                                        case 0x13:
                                        case 0x14:
                                        case 0x15:
                                        case 0x16:
                                        case 0x17:
                                        case 0x18:
                                        case 0x19:
                                        case 0x1a:
                                        case 0x1b:
                                        case 0x1c:
                                        case 0x1d:
                                        case 0x1e:
                                        case 0x20:
                                        case 0x21:
                                        case 0x22:
                                        case 0x24:
                                        case 0x25:
                                        case 0x26:
                                        case 0x27:
                                        case 0x28:
                                        case 0x29:
                                        case 0x2a:
                                        case 0x2b:
                                        case 0x2c:
                                        case 0x2d:
                                        {
                                            continue;
                                        }
                                        case 0x1f:
                                        {
                                            var_14 |= 0x20;
                                            continue;
                                        }
                                        case 0x23:
                                        {
                                            if (*arg2 != 0x6c)
                                            {
                                                var_14 |= 0x10;
                                                continue;
                                            }
                                            else
                                            {
                                                arg2 = &arg2[1];
                                                var_14 |= 0x1000;
                                                continue;
                                            }
                                            break;
                                        }
                                        case 0x2e:
                                        {
                                            var_14 |= 0x800;
                                            continue;
                                        }
                                    }
                                
                                goto label_100167d1;
                            }
                            case 7:
                            {
                                void* ecx_34 = (var_458_1 - 0x41);
                                int32_t var_4e8;
                                int32_t var_4e4;
                                int16_t var_45c;
                                int16_t var_44c;
                                int16_t var_18;
                                int32_t var_c_1;
                                void* var_8;
                                
                                switch (ecx_34)
                                {
                                    case nullptr:
                                    case 4:
                                    case 6:
                                    {
                                        var_30 = 1;
                                        var_458_1 += 0x20;
                                    label_10016e50:
                                        var_14 |= 0x40;
                                        var_8 = &var_44c;
                                        int32_t var_48_2 = 0x200;
                                        
                                        if (var_34 < 0)
                                            var_34 = 6;
                                        else if ((var_34 == 0 && var_458_1 == 0x67))
                                            var_34 = 1;
                                        else if (var_34 > 0x200)
                                            var_34 = 0x200;
                                        
                                        if (var_34 > 0xa3)
                                        {
                                            var_24_1 = __malloc_dbg((var_34 + 0x15d), 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x6da);
                                            
                                            if (var_24_1 == 0)
                                                var_34 = 0xa3;
                                            else
                                            {
                                                var_8 = var_24_1;
                                                var_48_2 = (var_34 + 0x15d);
                                            }
                                        }
                                        
                                        arg_10 += 8;
                                        void* edx_62 = arg_10;
                                        int32_t ecx_68 = *(edx_62 - 4);
                                        int32_t var_494 = *(edx_62 - 8);
                                        int32_t var_490_1 = ecx_68;
                                        sub_10018b70(data_10044cf8)(&var_494, var_8, var_48_2, var_458_1, var_34, var_30, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44), var_4e8, var_4e4, ecx_34, var_4dc, var_4d8, var_460_1, var_4d0_1);
                                        
                                        if (((var_14 & 0x80) != 0 && var_34 == 0))
                                            sub_10018b70(data_10044d04)(var_8, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44));
                                        
                                        if ((var_458_1 == 0x67 && (var_14 & 0x80) == 0))
                                            sub_10018b70(data_10044d00)(var_8, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44));
                                        
                                        if (*var_8 == 0x2d)
                                        {
                                            var_14 |= 0x100;
                                            var_8 += 1;
                                        }
                                        
                                        i = _strlen(var_8);
                                        break;
                                    }
                                    case 2:
                                    {
                                        if ((var_14 & 0x830) == 0)
                                            var_14 |= 0x20;
                                        
                                        goto label_10016ac9;
                                    }
                                    case 0x12:
                                    {
                                        if ((var_14 & 0x830) == 0)
                                            var_14 |= 0x20;
                                        
                                        goto label_10016c12;
                                    }
                                    case 0x17:
                                    {
                                        goto label_10016ffe;
                                    }
                                    case 0x19:
                                    {
                                        int16_t* eax_22 = _get_int_arg(&arg_10);
                                        
                                        if ((eax_22 == 0 || *(eax_22 + 4) == 0))
                                        {
                                            var_8 = data_10044604;
                                            i = _strlen(var_8);
                                        }
                                        else if ((var_14 & 0x800) == 0)
                                        {
                                            var_10 = 0;
                                            var_8 = *(eax_22 + 4);
                                            i = *eax_22;
                                        }
                                        else
                                        {
                                            var_8 = *(eax_22 + 4);
                                            int32_t eax_26;
                                            int32_t edx_42;
                                            edx_42 = HIGHD(*eax_22);
                                            eax_26 = LOWD(*eax_22);
                                            i = ((eax_26 - edx_42) >> 1);
                                            var_10 = 1;
                                        }
                                        break;
                                    }
                                    case 0x20:
                                    case 0x24:
                                    case 0x25:
                                    case 0x26:
                                    {
                                        goto label_10016e50;
                                    }
                                    case 0x22:
                                    {
                                    label_10016ac9:
                                        var_10 = 1;
                                        var_45c = _get_int_arg(&arg_10);
                                        
                                        if ((var_14 & 0x20) == 0)
                                        {
                                            int32_t ecx_38;
                                            ecx_38 = var_45c;
                                            var_44c = ecx_38;
                                        }
                                        else
                                        {
                                            char var_470 = var_45c;
                                            char var_46f_1 = 0;
                                            void** eax_19 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44);
                                            
                                            if (sub_10027580(&var_44c, &var_470, *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44) + 0xac), eax_19) < 0)
                                                var_2c = 1;
                                        }
                                        
                                        var_8 = &var_44c;
                                        i = 1;
                                        break;
                                    }
                                    case 0x23:
                                    case 0x28:
                                    {
                                        var_14 |= 0x40;
                                        var_c_1 = 0xa;
                                    label_1001706b:
                                        int32_t var_4a4_1;
                                        int32_t var_4a0_1;
                                        
                                        if ((var_14 & 0x8000) != 0)
                                        {
                                            int32_t eax_68;
                                            int32_t edx_72;
                                            eax_68 = _get_int64_arg(&arg_10);
                                            var_4a4_1 = eax_68;
                                            var_4a0_1 = edx_72;
                                        }
                                        else if ((var_14 & 0x1000) != 0)
                                        {
                                            int32_t eax_69;
                                            int32_t edx_75;
                                            eax_69 = _get_int64_arg(&arg_10);
                                            var_4a4_1 = eax_69;
                                            var_4a0_1 = edx_75;
                                        }
                                        else if ((var_14 & 0x20) == 0)
                                        {
                                            if ((var_14 & 0x40) == 0)
                                            {
                                                var_4a4_1 = _get_int_arg(&arg_10);
                                                var_4a0_1 = 0;
                                            }
                                            else
                                            {
                                                int32_t eax_77;
                                                int32_t edx_82;
                                                edx_82 = HIGHD(_get_int_arg(&arg_10));
                                                eax_77 = LOWD(_get_int_arg(&arg_10));
                                                var_4a4_1 = eax_77;
                                                var_4a0_1 = edx_82;
                                            }
                                        }
                                        else if ((var_14 & 0x40) == 0)
                                        {
                                            int32_t eax_75;
                                            int32_t edx_79;
                                            edx_79 = HIGHD(_get_int_arg(&arg_10));
                                            eax_75 = LOWD(_get_int_arg(&arg_10));
                                            var_4a4_1 = eax_75;
                                            var_4a0_1 = edx_79;
                                        }
                                        else
                                        {
                                            int32_t eax_72;
                                            int32_t edx_78;
                                            edx_78 = HIGHD(_get_int_arg(&arg_10));
                                            eax_72 = LOWD(_get_int_arg(&arg_10));
                                            var_4a4_1 = eax_72;
                                            var_4a0_1 = edx_78;
                                        }
                                        
                                        int32_t var_4ac_1;
                                        int32_t var_4a8_1;
                                        
                                        if ((((var_14 & 0x40) == 0 || var_4a0_1 > 0) || (var_4a0_1 >= 0 && var_4a4_1 >= 0)))
                                        {
                                            var_4ac_1 = var_4a4_1;
                                            var_4a8_1 = var_4a0_1;
                                        }
                                        else
                                        {
                                            var_4ac_1 = -(var_4a4_1);
                                            var_4a8_1 = -((var_4a0_1 + 0));
                                            var_14 |= 0x100;
                                        }
                                        
                                        if (((var_14 & 0x8000) == 0 && (var_14 & 0x1000) == 0))
                                            var_4a8_1 = 0;
                                        
                                        if (var_34 >= 0)
                                        {
                                            var_14 &= 0xfffffff7;
                                            
                                            if (var_34 > 0x200)
                                                var_34 = 0x200;
                                        }
                                        else
                                            var_34 = 1;
                                        
                                        if ((var_4ac_1 | var_4a8_1) == 0)
                                            var_20 = nullptr;
                                        
                                        void var_24d;
                                        void* var_8_1 = &var_24d;
                                        
                                        while (true)
                                        {
                                            int32_t ecx_92 = var_34;
                                            var_34 -= 1;
                                            
                                            if ((ecx_92 <= 0 && (var_4ac_1 | var_4a8_1) == 0))
                                                break;
                                            
                                            int32_t eax_88;
                                            uint32_t edx_92;
                                            edx_92 = HIGHD(var_c_1);
                                            eax_88 = LOWD(var_c_1);
                                            int32_t var_498_1 = (__aullrem(var_4ac_1, var_4a8_1, eax_88, edx_92) + 0x30);
                                            int32_t eax_92;
                                            uint32_t edx_94;
                                            edx_94 = HIGHD(var_c_1);
                                            eax_92 = LOWD(var_c_1);
                                            uint32_t eax_94;
                                            int32_t edx_95;
                                            eax_94 = __aulldiv(var_4ac_1, var_4a8_1, eax_92, edx_94);
                                            var_4ac_1 = eax_94;
                                            var_4a8_1 = edx_95;
                                            
                                            if (var_498_1 > 0x39)
                                                var_498_1 += var_464;
                                            
                                            *var_8_1 = var_498_1;
                                            var_8_1 -= 1;
                                        }
                                        
                                        i = (&var_24d - var_8_1);
                                        var_8 = (var_8_1 + 1);
                                        
                                        if (((var_14 & 0x200) != 0 && (i == 0 || *var_8 != 0x30)))
                                        {
                                            var_8 -= 1;
                                            *var_8 = 0x30;
                                            i += 1;
                                        }
                                        break;
                                    }
                                    case 0x2d:
                                    {
                                        int32_t* eax_38 = _get_int_arg(&arg_10);
                                        
                                        if (sub_100274f0() != 0)
                                        {
                                            if ((var_14 & 0x20) == 0)
                                                *eax_38 = var_450;
                                            else
                                            {
                                                eax_6 = var_450;
                                                *eax_38 = eax_6;
                                            }
                                            
                                            var_2c = 1;
                                        }
                                        else
                                        {
                                            var_4e8 = 0;
                                            
                                            if ((var_4e8 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x695, nullptr, u"("'n' format specifier disabled"…") == 1))
                                                breakpoint();
                                            
                                            if (var_4e8 == 0)
                                            {
                                                *sub_1000eca0() = 0x16;
                                                sub_1000c310(u"("'n' format specifier disabled"…", u"_woutput_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x695, 0);
                                                _LocaleUpdate::~_LocaleUpdate(&var_44);
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                    case 0x2e:
                                    {
                                        var_c_1 = 8;
                                        
                                        if ((var_14 & 0x80) != 0)
                                            var_14 |= 0x200;
                                        
                                        goto label_1001706b;
                                    }
                                    case 0x2f:
                                    {
                                        var_34 = 8;
                                    label_10016ffe:
                                        var_464 = 7;
                                    label_10017014:
                                        var_c_1 = 0x10;
                                        
                                        if ((var_14 & 0x80) != 0)
                                        {
                                            var_18 = 0x30;
                                            int16_t var_16_1 = (var_464 + 0x51);
                                            var_20 = 2;
                                        }
                                        
                                        goto label_1001706b;
                                    }
                                    case 0x32:
                                    {
                                    label_10016c12:
                                        
                                        if (var_34 != 0xffffffff)
                                            var_4e4 = var_34;
                                        else
                                            var_4e4 = 0x7fffffff;
                                        
                                        int32_t var_47c_1 = var_4e4;
                                        var_8 = _get_int_arg(&arg_10);
                                        
                                        if ((var_14 & 0x20) == 0)
                                        {
                                            if (var_8 == 0)
                                                var_8 = data_10044608;
                                            
                                            var_10 = 1;
                                            void* var_480_1 = var_8;
                                            
                                            while (true)
                                            {
                                                eax_6 = var_47c_1;
                                                var_47c_1 -= 1;
                                                
                                                if (eax_6 == 0)
                                                    break;
                                                
                                                if (*var_480_1 == 0)
                                                    break;
                                                
                                                var_480_1 += 2;
                                            }
                                            
                                            i = ((var_480_1 - var_8) >> 1);
                                        }
                                        else
                                        {
                                            if (var_8 == 0)
                                                var_8 = data_10044604;
                                            
                                            void* var_478_1 = var_8;
                                            
                                            for (i = 0; i < var_47c_1; i += 1)
                                            {
                                                if (*var_478_1 == 0)
                                                    break;
                                                
                                                void** eax_33 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44);
                                                
                                                if (sub_10027510(*var_478_1, eax_33) != 0)
                                                    var_478_1 += 1;
                                                
                                                var_478_1 += 1;
                                            }
                                        }
                                        break;
                                    }
                                    case 0x34:
                                    {
                                        var_c_1 = 0xa;
                                        goto label_1001706b;
                                    }
                                    case 0x37:
                                    {
                                        var_464 = 0x27;
                                        goto label_10017014;
                                    }
                                }
                                
                                if (var_2c == 0)
                                {
                                    if ((var_14 & 0x40) != 0)
                                    {
                                        if ((var_14 & 0x100) != 0)
                                        {
                                            var_18 = 0x2d;
                                            var_20 = 1;
                                        }
                                        else if ((var_14 & 1) != 0)
                                        {
                                            var_18 = 0x2b;
                                            var_20 = 1;
                                        }
                                        else if ((var_14 & 2) != 0)
                                        {
                                            var_18 = 0x20;
                                            var_20 = 1;
                                        }
                                    }
                                    
                                    int32_t* var_4b0_1 = ((var_1c - i) - var_20);
                                    
                                    if ((var_14 & 0xc) == 0)
                                        sub_10017680(0x20, var_4b0_1, arg1, &var_450);
                                    
                                    sub_100176c0(&var_18, var_20, arg1, &var_450);
                                    
                                    if (((var_14 & 8) != 0 && (var_14 & 4) == 0))
                                        sub_10017680(0x30, var_4b0_1, arg1, &var_450);
                                    
                                    if ((var_10 != 0 || i <= 0))
                                        sub_100176c0(var_8, i, arg1, &var_450);
                                    else
                                    {
                                        void* var_4b4_1 = var_8;
                                        int32_t i_1 = i;
                                        
                                        while (true)
                                        {
                                            int32_t i_2 = i_1;
                                            i_1 -= 1;
                                            
                                            if (i_2 <= 0)
                                                break;
                                            
                                            void** eax_106 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44);
                                            eax_6 = sub_10027580(&var_45c, var_4b4_1, *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44) + 0xac), eax_106);
                                            
                                            if (eax_6 <= 0)
                                            {
                                                var_450 = 0xffffffff;
                                                break;
                                            }
                                            
                                            _write_char(var_45c, arg1, &var_450);
                                            var_4b4_1 += eax_6;
                                        }
                                    }
                                    
                                    if ((var_450 >= 0 && (var_14 & 4) != 0))
                                        sub_10017680(0x20, var_4b0_1, arg1, &var_450);
                                }
                                
                                if (var_24_1 == 0)
                                    continue;
                                else
                                {
                                    sub_10011340(var_24_1, 2);
                                    var_24_1 = nullptr;
                                    continue;
                                }
                                break;
                            }
                        }
                }
                
                int32_t var_4cc_1 = var_450;
                _LocaleUpdate::~_LocaleUpdate(&var_44);
                break;
            }
        }
        else
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(format != NULL)", u"_woutput_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x407, 0);
            _LocaleUpdate::~_LocaleUpdate(&var_44);
        }
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(stream != NULL)", u"_woutput_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x402, 0);
        _LocaleUpdate::~_LocaleUpdate(&var_44);
    }
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t* _write_char(int16_t arg1, int16_t** arg2, int32_t* arg3)
{
    int32_t* result;
    
    if (((arg2[3] & 0x40) == 0 || arg2[2] != 0))
    {
        if (sub_100278b0(arg1, arg2) != 0xffff)
        {
            result = arg3;
            *result = (*arg3 + 1);
        }
        else
        {
            result = arg3;
            *result = 0xffffffff;
        }
    }
    else
    {
        result = arg3;
        *arg3 = (*result + 1);
    }
    
    return result;
}

int32_t* sub_10017680(int16_t arg1, int32_t* arg2, int16_t** arg3, int32_t* arg4)
{
    int32_t* result;
    
    do
    {
        result = arg2;
        arg2 -= 1;
        
        if (result <= 0)
            break;
        
        result = _write_char(arg1, arg3, arg4);
    } while (*arg4 != 0xffffffff);
    
    return result;
}

int32_t* sub_100176c0(int16_t* arg1, int32_t* arg2, int16_t** arg3, int32_t* arg4)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t* result;
    
    if (((arg3[3] & 0x40) == 0 || arg3[2] != 0))
    {
        while (true)
        {
            result = arg2;
            arg2 -= 1;
            
            if (result <= 0)
                break;
            
            result = *arg1;
            *var_8[2] = result;
            _write_char(*var_8[2], arg3, arg4);
            arg1 = &arg1[1];
            
            if (*arg4 == 0xffffffff)
            {
                result = sub_1000eca0();
                
                if (*result != 0x2a)
                    break;
                
                _write_char(0x3f, arg3, arg4);
            }
        }
    }
    else
    {
        result = arg4;
        *arg4 = (*result + arg2);
    }
    
    return result;
}

int32_t _get_int_arg(int32_t* arg1)
{
    *arg1 += 4;
    return *(*arg1 - 4);
}

int32_t _get_int64_arg(int32_t* arg1)
{
    *arg1 += 8;
    void* ecx_2 = *arg1;
    *(ecx_2 - 4);
    return *(ecx_2 - 8);
}

int32_t sub_10017790(int16_t** arg1, int16_t* arg2, void** arg3)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    int32_t var_464 = 0;
    int32_t var_14 = 0;
    int32_t var_1c = 0;
    int32_t var_34 = 0;
    int32_t* var_20 = nullptr;
    int32_t var_2c = 0;
    int32_t var_10 = 0;
    void var_44;
    _LocaleUpdate::_LocaleUpdate(&var_44, arg3);
    int32_t var_24 = 0;
    int32_t ecx_1;
    ecx_1 = arg1 != 0;
    
    if ((ecx_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x402, nullptr, u"(stream != NULL)") == 1))
        breakpoint();
    
    if (ecx_1 != 0)
    {
        int32_t eax_6;
        eax_6 = arg2 != 0;
        
        if ((eax_6 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x407, nullptr, u"(format != NULL)") == 1))
            breakpoint();
        
        if (eax_6 != 0)
        {
            int32_t var_450 = 0;
            int32_t i = 0;
            int32_t var_460_1 = 0;
            void* var_24_1 = nullptr;
            int32_t var_48_1 = 0;
            
            while (true)
            {
                eax_6 = *arg2;
                int16_t var_458_1 = eax_6;
                arg2 = &arg2[1];
                
                if ((var_458_1 != 0 && var_450 >= 0))
                {
                    int32_t var_4dc_1;
                    
                    if ((var_458_1 < 0x20 || var_458_1 > 0x78))
                        var_4dc_1 = 0;
                    else
                        var_4dc_1 = (*"A"[var_458_1] & 0xf);
                    
                    var_460_1 = (*(((var_4dc_1 * 9) + var_460_1) + 0x1003b3b8) >> 4);
                    
                    if (var_460_1 == 8)
                    {
                        int32_t var_4e0_1 = 0;
                        
                        if ((var_4e0_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x460, nullptr, u"("Incorrect format specifier", 0…") == 1))
                            breakpoint();
                        
                        if (var_4e0_1 == 0)
                        {
                            *sub_1000eca0() = 0x16;
                            sub_1000c310(u"("Incorrect format specifier", 0…", u"_woutput_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x460, 0);
                            _LocaleUpdate::~_LocaleUpdate(&var_44);
                            break;
                        }
                    }
                    
                    int32_t var_30;
                    
                    if (var_460_1 > 7)
                        continue;
                    else
                        switch (var_460_1)
                        {
                            case 0:
                            {
                            label_10017a90:
                                var_10 = 1;
                                _write_char(var_458_1, arg1, &var_450);
                                continue;
                            }
                            case 1:
                            {
                                var_30 = 0;
                                var_2c = 0;
                                var_1c = 0;
                                var_20 = nullptr;
                                var_14 = 0;
                                var_34 = 0xffffffff;
                                var_10 = 0;
                                continue;
                            }
                            case 2:
                            {
                                if ((var_458_1 - 0x20) > 0x10)
                                    continue;
                                else
                                    switch (var_458_1)
                                    {
                                        case 0x20:
                                        {
                                            var_14 |= 2;
                                            continue;
                                        }
                                        case 0x21:
                                        case 0x22:
                                        case 0x24:
                                        case 0x25:
                                        case 0x26:
                                        case 0x27:
                                        case 0x28:
                                        case 0x29:
                                        case 0x2a:
                                        case 0x2c:
                                        case 0x2e:
                                        case 0x2f:
                                        {
                                            continue;
                                        }
                                        case 0x23:
                                        {
                                            var_14 |= 0x80;
                                            continue;
                                        }
                                        case 0x2b:
                                        {
                                            var_14 |= 1;
                                            continue;
                                        }
                                        case 0x2d:
                                        {
                                            var_14 |= 4;
                                            continue;
                                        }
                                        case 0x30:
                                        {
                                            var_14 |= 8;
                                            continue;
                                        }
                                    }
                                break;
                            }
                            case 3:
                            {
                                if (var_458_1 != 0x2a)
                                {
                                    var_1c = (((var_1c * 0xa) + var_458_1) - 0x30);
                                    continue;
                                }
                                else
                                {
                                    var_1c = _get_int_arg(&arg_10);
                                    
                                    if (var_1c >= 0)
                                        continue;
                                    else
                                    {
                                        var_14 |= 4;
                                        var_1c = -(var_1c);
                                        continue;
                                    }
                                }
                                break;
                            }
                            case 4:
                            {
                                var_34 = 0;
                                continue;
                            }
                            case 5:
                            {
                                if (var_458_1 != 0x2a)
                                {
                                    var_34 = (((var_34 * 0xa) + var_458_1) - 0x30);
                                    continue;
                                }
                                else
                                {
                                    var_34 = _get_int_arg(&arg_10);
                                    
                                    if (var_34 >= 0)
                                        continue;
                                    else
                                    {
                                        var_34 = 0xffffffff;
                                        continue;
                                    }
                                }
                                break;
                            }
                            case 6:
                            {
                                if ((var_458_1 - 0x49) > 0x2e)
                                    continue;
                                else
                                    switch (var_458_1)
                                    {
                                        case 0x49:
                                        {
                                            if ((*arg2 == 0x36 && *(arg2 + 2) == 0x34))
                                            {
                                                arg2 = &arg2[2];
                                                var_14 |= 0x8000;
                                                continue;
                                            }
                                            
                                            if ((*arg2 == 0x33 && *(arg2 + 2) == 0x32))
                                            {
                                                arg2 = &arg2[2];
                                                var_14 &= 0xffff7fff;
                                                continue;
                                            }
                                            
                                            if (*arg2 == 0x64)
                                                continue;
                                            else if (*arg2 == 0x69)
                                                continue;
                                            else if (*arg2 == 0x6f)
                                                continue;
                                            else if (*arg2 == 0x75)
                                                continue;
                                            else if (*arg2 == 0x78)
                                                continue;
                                            else if (*arg2 != 0x58)
                                                var_460_1 = 0;
                                            else
                                                continue;
                                            break;
                                        }
                                        case 0x4a:
                                        case 0x4b:
                                        case 0x4c:
                                        case 0x4d:
                                        case 0x4e:
                                        case 0x4f:
                                        case 0x50:
                                        case 0x51:
                                        case 0x52:
                                        case 0x53:
                                        case 0x54:
                                        case 0x55:
                                        case 0x56:
                                        case 0x57:
                                        case 0x58:
                                        case 0x59:
                                        case 0x5a:
                                        case 0x5b:
                                        case 0x5c:
                                        case 0x5d:
                                        case 0x5e:
                                        case 0x5f:
                                        case 0x60:
                                        case 0x61:
                                        case 0x62:
                                        case 0x63:
                                        case 0x64:
                                        case 0x65:
                                        case 0x66:
                                        case 0x67:
                                        case 0x69:
                                        case 0x6a:
                                        case 0x6b:
                                        case 0x6d:
                                        case 0x6e:
                                        case 0x6f:
                                        case 0x70:
                                        case 0x71:
                                        case 0x72:
                                        case 0x73:
                                        case 0x74:
                                        case 0x75:
                                        case 0x76:
                                        {
                                            continue;
                                        }
                                        case 0x68:
                                        {
                                            var_14 |= 0x20;
                                            continue;
                                        }
                                        case 0x6c:
                                        {
                                            if (*arg2 != 0x6c)
                                            {
                                                var_14 |= 0x10;
                                                continue;
                                            }
                                            else
                                            {
                                                arg2 = &arg2[1];
                                                var_14 |= 0x1000;
                                                continue;
                                            }
                                            break;
                                        }
                                        case 0x77:
                                        {
                                            var_14 |= 0x800;
                                            continue;
                                        }
                                    }
                                
                                goto label_10017a90;
                            }
                            case 7:
                            {
                                int16_t var_45c;
                                int16_t var_18;
                                void* var_8;
                                int16_t var_44c;
                                int32_t var_c_1;
                                
                                if ((var_458_1 - 0x41) <= 0x37)
                                    switch (var_458_1)
                                    {
                                        case 0x41:
                                        case 0x45:
                                        case 0x47:
                                        {
                                            var_30 = 1;
                                            var_458_1 += 0x20;
                                        label_1001810f:
                                            var_14 |= 0x40;
                                            var_8 = &var_44c;
                                            int32_t var_48_2 = 0x200;
                                            
                                            if (var_34 < 0)
                                                var_34 = 6;
                                            else if ((var_34 == 0 && var_458_1 == 0x67))
                                                var_34 = 1;
                                            else if (var_34 > 0x200)
                                                var_34 = 0x200;
                                            
                                            if (var_34 > 0xa3)
                                            {
                                                var_24_1 = __malloc_dbg((var_34 + 0x15d), 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x6da);
                                                
                                                if (var_24_1 == 0)
                                                    var_34 = 0xa3;
                                                else
                                                {
                                                    var_8 = var_24_1;
                                                    var_48_2 = (var_34 + 0x15d);
                                                }
                                            }
                                            
                                            arg_10 += 8;
                                            void* edx_63 = arg_10;
                                            int32_t ecx_69 = *(edx_63 - 4);
                                            int32_t var_494 = *(edx_63 - 8);
                                            int32_t var_490_1 = ecx_69;
                                            sub_10018b70(data_10044cf8)(&var_494, var_8, var_48_2, var_458_1, var_34, var_30, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44));
                                            
                                            if (((var_14 & 0x80) != 0 && var_34 == 0))
                                                sub_10018b70(data_10044d04)(var_8, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44));
                                            
                                            if ((var_458_1 == 0x67 && (var_14 & 0x80) == 0))
                                                sub_10018b70(data_10044d00)(var_8, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44));
                                            
                                            if (*var_8 == 0x2d)
                                            {
                                                var_14 |= 0x100;
                                                var_8 += 1;
                                            }
                                            
                                            i = _strlen(var_8);
                                            break;
                                        }
                                        case 0x43:
                                        {
                                            if ((var_14 & 0x830) == 0)
                                                var_14 |= 0x20;
                                            
                                            goto label_10017d88;
                                        }
                                        case 0x53:
                                        {
                                            if ((var_14 & 0x830) == 0)
                                                var_14 |= 0x20;
                                            
                                            goto label_10017ed1;
                                        }
                                        case 0x58:
                                        {
                                            goto label_100182bd;
                                        }
                                        case 0x5a:
                                        {
                                            int16_t* eax_24 = _get_int_arg(&arg_10);
                                            
                                            if ((eax_24 == 0 || *(eax_24 + 4) == 0))
                                            {
                                                var_8 = data_10044604;
                                                i = _strlen(var_8);
                                            }
                                            else if ((var_14 & 0x800) == 0)
                                            {
                                                var_10 = 0;
                                                var_8 = *(eax_24 + 4);
                                                i = *eax_24;
                                            }
                                            else
                                            {
                                                var_8 = *(eax_24 + 4);
                                                int32_t eax_28;
                                                int32_t edx_43;
                                                edx_43 = HIGHD(*eax_24);
                                                eax_28 = LOWD(*eax_24);
                                                i = ((eax_28 - edx_43) >> 1);
                                                var_10 = 1;
                                            }
                                            break;
                                        }
                                        case 0x61:
                                        case 0x65:
                                        case 0x66:
                                        case 0x67:
                                        {
                                            goto label_1001810f;
                                        }
                                        case 0x63:
                                        {
                                        label_10017d88:
                                            var_10 = 1;
                                            var_45c = _get_int_arg(&arg_10);
                                            
                                            if ((var_14 & 0x20) == 0)
                                            {
                                                int32_t ecx_39;
                                                ecx_39 = var_45c;
                                                var_44c = ecx_39;
                                            }
                                            else
                                            {
                                                char var_474 = var_45c;
                                                char var_473_1 = 0;
                                                void** eax_21 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44);
                                                
                                                if (sub_10027580(&var_44c, &var_474, *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44) + 0xac), eax_21) < 0)
                                                    var_2c = 1;
                                            }
                                            
                                            var_8 = &var_44c;
                                            i = 1;
                                            break;
                                        }
                                        case 0x64:
                                        case 0x69:
                                        {
                                            var_14 |= 0x40;
                                            var_c_1 = 0xa;
                                        label_1001832a:
                                            int32_t var_4a4_1;
                                            int32_t var_4a0_1;
                                            
                                            if ((var_14 & 0x8000) != 0)
                                            {
                                                int32_t eax_70;
                                                int32_t edx_73;
                                                eax_70 = _get_int64_arg(&arg_10);
                                                var_4a4_1 = eax_70;
                                                var_4a0_1 = edx_73;
                                            }
                                            else if ((var_14 & 0x1000) != 0)
                                            {
                                                int32_t eax_71;
                                                int32_t edx_76;
                                                eax_71 = _get_int64_arg(&arg_10);
                                                var_4a4_1 = eax_71;
                                                var_4a0_1 = edx_76;
                                            }
                                            else if ((var_14 & 0x20) == 0)
                                            {
                                                if ((var_14 & 0x40) == 0)
                                                {
                                                    var_4a4_1 = _get_int_arg(&arg_10);
                                                    var_4a0_1 = 0;
                                                }
                                                else
                                                {
                                                    int32_t eax_79;
                                                    int32_t edx_83;
                                                    edx_83 = HIGHD(_get_int_arg(&arg_10));
                                                    eax_79 = LOWD(_get_int_arg(&arg_10));
                                                    var_4a4_1 = eax_79;
                                                    var_4a0_1 = edx_83;
                                                }
                                            }
                                            else if ((var_14 & 0x40) == 0)
                                            {
                                                int32_t eax_77;
                                                int32_t edx_80;
                                                edx_80 = HIGHD(_get_int_arg(&arg_10));
                                                eax_77 = LOWD(_get_int_arg(&arg_10));
                                                var_4a4_1 = eax_77;
                                                var_4a0_1 = edx_80;
                                            }
                                            else
                                            {
                                                int32_t eax_74;
                                                int32_t edx_79;
                                                edx_79 = HIGHD(_get_int_arg(&arg_10));
                                                eax_74 = LOWD(_get_int_arg(&arg_10));
                                                var_4a4_1 = eax_74;
                                                var_4a0_1 = edx_79;
                                            }
                                            
                                            int32_t var_4ac_1;
                                            int32_t var_4a8_1;
                                            
                                            if ((((var_14 & 0x40) == 0 || var_4a0_1 > 0) || (var_4a0_1 >= 0 && var_4a4_1 >= 0)))
                                            {
                                                var_4ac_1 = var_4a4_1;
                                                var_4a8_1 = var_4a0_1;
                                            }
                                            else
                                            {
                                                var_4ac_1 = -(var_4a4_1);
                                                var_4a8_1 = -((var_4a0_1 + 0));
                                                var_14 |= 0x100;
                                            }
                                            
                                            if (((var_14 & 0x8000) == 0 && (var_14 & 0x1000) == 0))
                                                var_4a8_1 = 0;
                                            
                                            if (var_34 >= 0)
                                            {
                                                var_14 &= 0xfffffff7;
                                                
                                                if (var_34 > 0x200)
                                                    var_34 = 0x200;
                                            }
                                            else
                                                var_34 = 1;
                                            
                                            if ((var_4ac_1 | var_4a8_1) == 0)
                                                var_20 = nullptr;
                                            
                                            void var_24d;
                                            void* var_8_1 = &var_24d;
                                            
                                            while (true)
                                            {
                                                int32_t ecx_93 = var_34;
                                                var_34 -= 1;
                                                
                                                if ((ecx_93 <= 0 && (var_4ac_1 | var_4a8_1) == 0))
                                                    break;
                                                
                                                int32_t eax_90;
                                                uint32_t edx_93;
                                                edx_93 = HIGHD(var_c_1);
                                                eax_90 = LOWD(var_c_1);
                                                int32_t var_498_1 = (__aullrem(var_4ac_1, var_4a8_1, eax_90, edx_93) + 0x30);
                                                int32_t eax_94;
                                                uint32_t edx_95;
                                                edx_95 = HIGHD(var_c_1);
                                                eax_94 = LOWD(var_c_1);
                                                uint32_t eax_96;
                                                int32_t edx_96;
                                                eax_96 = __aulldiv(var_4ac_1, var_4a8_1, eax_94, edx_95);
                                                var_4ac_1 = eax_96;
                                                var_4a8_1 = edx_96;
                                                
                                                if (var_498_1 > 0x39)
                                                    var_498_1 += var_464;
                                                
                                                *var_8_1 = var_498_1;
                                                var_8_1 -= 1;
                                            }
                                            
                                            i = (&var_24d - var_8_1);
                                            var_8 = (var_8_1 + 1);
                                            
                                            if (((var_14 & 0x200) != 0 && (i == 0 || *var_8 != 0x30)))
                                            {
                                                var_8 -= 1;
                                                *var_8 = 0x30;
                                                i += 1;
                                            }
                                            break;
                                        }
                                        case 0x6e:
                                        {
                                            int16_t* eax_40 = _get_int_arg(&arg_10);
                                            
                                            if (sub_100274f0() != 0)
                                            {
                                                if ((var_14 & 0x20) == 0)
                                                    *eax_40 = var_450;
                                                else
                                                {
                                                    eax_6 = var_450;
                                                    *eax_40 = eax_6;
                                                }
                                                
                                                var_2c = 1;
                                            }
                                            else
                                            {
                                                int32_t var_4f8_1 = 0;
                                                
                                                if ((var_4f8_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x695, nullptr, u"("'n' format specifier disabled"…") == 1))
                                                    breakpoint();
                                                
                                                if (var_4f8_1 == 0)
                                                {
                                                    *sub_1000eca0() = 0x16;
                                                    sub_1000c310(u"("'n' format specifier disabled"…", u"_woutput_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x695, 0);
                                                    _LocaleUpdate::~_LocaleUpdate(&var_44);
                                                    break;
                                                }
                                            }
                                            break;
                                        }
                                        case 0x6f:
                                        {
                                            var_c_1 = 8;
                                            
                                            if ((var_14 & 0x80) != 0)
                                                var_14 |= 0x200;
                                            
                                            goto label_1001832a;
                                        }
                                        case 0x70:
                                        {
                                            var_34 = 8;
                                        label_100182bd:
                                            var_464 = 7;
                                        label_100182d3:
                                            var_c_1 = 0x10;
                                            
                                            if ((var_14 & 0x80) != 0)
                                            {
                                                var_18 = 0x30;
                                                int16_t var_16_1 = (var_464 + 0x51);
                                                var_20 = 2;
                                            }
                                            
                                            goto label_1001832a;
                                        }
                                        case 0x73:
                                        {
                                        label_10017ed1:
                                            int32_t var_4f4_1;
                                            
                                            if (var_34 != 0xffffffff)
                                                var_4f4_1 = var_34;
                                            else
                                                var_4f4_1 = 0x7fffffff;
                                            
                                            int32_t var_480_1 = var_4f4_1;
                                            var_8 = _get_int_arg(&arg_10);
                                            
                                            if ((var_14 & 0x20) == 0)
                                            {
                                                if (var_8 == 0)
                                                    var_8 = data_10044608;
                                                
                                                var_10 = 1;
                                                void* var_484_1 = var_8;
                                                
                                                while (true)
                                                {
                                                    eax_6 = var_480_1;
                                                    var_480_1 -= 1;
                                                    
                                                    if (eax_6 == 0)
                                                        break;
                                                    
                                                    if (*var_484_1 == 0)
                                                        break;
                                                    
                                                    var_484_1 += 2;
                                                }
                                                
                                                i = ((var_484_1 - var_8) >> 1);
                                            }
                                            else
                                            {
                                                if (var_8 == 0)
                                                    var_8 = data_10044604;
                                                
                                                void* var_47c_1 = var_8;
                                                
                                                for (i = 0; i < var_480_1; i += 1)
                                                {
                                                    if (*var_47c_1 == 0)
                                                        break;
                                                    
                                                    void** eax_35 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44);
                                                    
                                                    if (sub_10027510(*var_47c_1, eax_35) != 0)
                                                        var_47c_1 += 1;
                                                    
                                                    var_47c_1 += 1;
                                                }
                                            }
                                            break;
                                        }
                                        case 0x75:
                                        {
                                            var_c_1 = 0xa;
                                            goto label_1001832a;
                                        }
                                        case 0x78:
                                        {
                                            var_464 = 0x27;
                                            goto label_100182d3;
                                        }
                                    }
                                
                                if (var_2c == 0)
                                {
                                    if ((var_14 & 0x40) != 0)
                                    {
                                        if ((var_14 & 0x100) != 0)
                                        {
                                            var_18 = 0x2d;
                                            var_20 = 1;
                                        }
                                        else if ((var_14 & 1) != 0)
                                        {
                                            var_18 = 0x2b;
                                            var_20 = 1;
                                        }
                                        else if ((var_14 & 2) != 0)
                                        {
                                            var_18 = 0x20;
                                            var_20 = 1;
                                        }
                                    }
                                    
                                    int32_t* eax_102 = ((var_1c - i) - var_20);
                                    
                                    if ((var_14 & 0xc) == 0)
                                        sub_10017680(0x20, eax_102, arg1, &var_450);
                                    
                                    sub_100176c0(&var_18, var_20, arg1, &var_450);
                                    
                                    if (((var_14 & 8) != 0 && (var_14 & 4) == 0))
                                        sub_10017680(0x30, eax_102, arg1, &var_450);
                                    
                                    if ((var_10 != 0 || i <= 0))
                                        sub_100176c0(var_8, i, arg1, &var_450);
                                    else
                                    {
                                        void* var_4b4_1 = var_8;
                                        int32_t i_1 = i;
                                        
                                        while (true)
                                        {
                                            int32_t i_2 = i_1;
                                            i_1 -= 1;
                                            
                                            if (i_2 <= 0)
                                                break;
                                            
                                            void** eax_108 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44);
                                            eax_6 = sub_10027580(&var_45c, var_4b4_1, *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44) + 0xac), eax_108);
                                            
                                            if (eax_6 <= 0)
                                            {
                                                var_450 = 0xffffffff;
                                                break;
                                            }
                                            
                                            _write_char(var_45c, arg1, &var_450);
                                            var_4b4_1 += eax_6;
                                        }
                                    }
                                    
                                    if ((var_450 >= 0 && (var_14 & 4) != 0))
                                        sub_10017680(0x20, eax_102, arg1, &var_450);
                                }
                                
                                if (var_24_1 == 0)
                                    continue;
                                else
                                {
                                    sub_10011340(var_24_1, 2);
                                    var_24_1 = nullptr;
                                    continue;
                                }
                                break;
                            }
                        }
                }
                
                int32_t var_4fc_1;
                
                if ((var_460_1 == 0 || var_460_1 == 7))
                    var_4fc_1 = 1;
                else
                    var_4fc_1 = 0;
                
                if ((var_4fc_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x8f5, nullptr, u"((state == ST_NORMAL) || (state …") == 1))
                    breakpoint();
                
                if (var_4fc_1 != 0)
                {
                    int32_t var_4d8_1 = var_450;
                    _LocaleUpdate::~_LocaleUpdate(&var_44);
                    break;
                }
                
                *sub_1000eca0() = 0x16;
                sub_1000c310(u"((state == ST_NORMAL) || (state …", u"_woutput_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x8f5, 0);
                _LocaleUpdate::~_LocaleUpdate(&var_44);
                break;
            }
        }
        else
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(format != NULL)", u"_woutput_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x407, 0);
            _LocaleUpdate::~_LocaleUpdate(&var_44);
        }
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(stream != NULL)", u"_woutput_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x402, 0);
        _LocaleUpdate::~_LocaleUpdate(&var_44);
    }
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

void* _malloc(int32_t arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    return sub_100105c0(arg1, data_10045c7c, 1, 0, 0);
}

void* _strlen(char* arg1)
{
    char* ecx = arg1;
    
    while ((ecx & 3) != 0)
    {
        int32_t eax;
        eax = *ecx;
        ecx = &ecx[1];
        
        if (eax == 0)
            return (&ecx[0xffffffff] - arg1);
    }
    
    while (true)
    {
        int32_t eax_2 = *ecx;
        ecx = &ecx[4];
        
        if ((((eax_2 ^ 0xffffffff) ^ (0x7efefeff + eax_2)) & 0x81010100) != 0)
        {
            int32_t eax_5 = *(ecx - 4);
            
            if (eax_5 == 0)
                return (&ecx[0xfffffffc] - arg1);
            
            if (*eax_5[1] == 0)
                return (&ecx[0xfffffffd] - arg1);
            
            if ((eax_5 & 0xff0000) == 0)
                return (&ecx[0xfffffffe] - arg1);
            
            if ((eax_5 & 0xff000000) == 0)
                break;
        }
    }
    
    return (&ecx[0xffffffff] - arg1);
}

int32_t __get_startup_argv_mode() __pure
{
    return 1;
}

int32_t __heap_term()
{
    data_1004a384 = 0;
}

int32_t sub_10018a80(int32_t arg1)
{
    int32_t var_8 = 0;
    int32_t eax_1 = TlsGetValue(data_10044328);
    void* eax_3;
    
    if ((eax_1 != 0 && data_10044324 != 0xffffffff))
        eax_3 = TlsGetValue(data_10044328)(data_10044324);
    
    if (((eax_1 != 0 && data_10044324 != 0xffffffff) && eax_3 != 0))
        var_8 = *(eax_3 + 0x1f8);
    else
    {
        HMODULE hModule = sub_10018b20(u"KERNEL32.DLL");
        
        if (hModule != 0)
            var_8 = GetProcAddress(hModule, "EncodePointer");
    }
    
    if (var_8 == 0)
        return arg1;
    
    return var_8(arg1);
}

HMODULE sub_10018b20(PWSTR arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    HMODULE result = GetModuleHandleW(arg1);
    
    if (result == 0)
        return sub_100154e0(arg1);
    
    return result;
}

int32_t __Getmonths()
{
    return sub_10018a80(0);
}

int32_t sub_10018b70(int32_t arg1)
{
    int32_t var_8 = 0;
    int32_t eax_1 = TlsGetValue(data_10044328);
    void* eax_3;
    
    if ((eax_1 != 0 && data_10044324 != 0xffffffff))
        eax_3 = TlsGetValue(data_10044328)(data_10044324);
    
    if (((eax_1 != 0 && data_10044324 != 0xffffffff) && eax_3 != 0))
        var_8 = *(eax_3 + 0x1fc);
    else
    {
        HMODULE hModule = sub_10018b20(u"KERNEL32.DLL");
        
        if (hModule != 0)
            var_8 = GetProcAddress(hModule, "DecodePointer");
    }
    
    if (var_8 == 0)
        return arg1;
    
    return var_8(arg1);
}

uint32_t sub_10018c10()
{
    return TlsAlloc();
}

int32_t sub_10018c20()
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t lpTlsValue = TlsGetValue(data_10044328);
    
    if (lpTlsValue == 0)
    {
        lpTlsValue = sub_10018b70(data_10045b3c);
        TlsSetValue(data_10044328, lpTlsValue);
    }
    
    return lpTlsValue;
}

int32_t sub_10018c70()
{
    HMODULE hModule = sub_10018b20(u"KERNEL32.DLL");
    
    if (hModule == 0)
    {
        sub_10018e80();
        return 0;
    }
    
    data_10045b38 = GetProcAddress(hModule, "FlsAlloc");
    data_10045b3c = GetProcAddress(hModule, "FlsGetValue");
    data_10045b40 = GetProcAddress(hModule, "FlsSetValue");
    data_10045b44 = GetProcAddress(hModule, "FlsFree");
    
    if ((((data_10045b38 == 0 || data_10045b3c == 0) || data_10045b40 == 0) || data_10045b44 == 0))
    {
        data_10045b38 = sub_10018c10;
        data_10045b3c = TlsGetValue;
        data_10045b40 = TlsSetValue;
        data_10045b44 = TlsFree;
    }
    
    data_10044328 = TlsAlloc();
    
    if ((data_10044328 != 0xffffffff && TlsSetValue(data_10044328, data_10045b3c) != 0))
    {
        sub_10015a50();
        data_10045b38 = sub_10018a80(data_10045b38);
        data_10045b3c = sub_10018a80(data_10045b3c);
        data_10045b40 = sub_10018a80(data_10045b40);
        data_10045b44 = sub_10018a80(data_10045b44);
        
        if (sub_100136e0() == 0)
        {
            sub_10018e80();
            return 0;
        }
        
        data_10044324 = sub_10018b70(data_10045b38)(sub_10019130);
        
        if (data_10044324 == 0xffffffff)
        {
            sub_10018e80();
            return 0;
        }
        
        void* eax_18 = sub_10010b10(1, 0x214, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x18a);
        
        if ((eax_18 != 0 && sub_10018b70(data_10045b40)(data_10044324, eax_18) != 0))
        {
            sub_10018ee0(eax_18, 0);
            *eax_18 = GetCurrentThreadId();
            *(eax_18 + 4) = 0xffffffff;
            return 1;
        }
        
        sub_10018e80();
    }
    
    return 0;
}

int32_t sub_10018e80()
{
    if (data_10044324 != 0xffffffff)
    {
        sub_10018b70(data_10045b44)(data_10044324);
        data_10044324 = 0xffffffff;
    }
    
    if (data_10044328 != 0xffffffff)
    {
        TlsFree(data_10044328);
        data_10044328 = 0xffffffff;
    }
    
    return __mtdeletelocks();
}

int32_t sub_10018ee0(void* arg1, int32_t arg2)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041e08;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_2c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_30 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    HMODULE hModule = sub_10018b20(u"KERNEL32.DLL");
    *(arg1 + 0x5c) = 0x1003b270;
    *(arg1 + 0x14) = 1;
    
    if (hModule != 0)
    {
        *(arg1 + 0x1f8) = GetProcAddress(hModule, "EncodePointer");
        *(arg1 + 0x1fc) = GetProcAddress(hModule, "DecodePointer");
    }
    
    *(arg1 + 0x70) = 1;
    *(arg1 + 0xc8) = 0x43;
    *(arg1 + 0x14b) = 0x43;
    *(arg1 + 0x68) = 0x10044610;
    __lock(0xd);
    int32_t var_8_1 = 0;
    InterlockedIncrement(*(arg1 + 0x68));
    int32_t var_8_2 = 0xfffffffe;
    sub_10018fc0();
    __lock(0xc);
    int32_t var_8_3 = 1;
    *(arg1 + 0x6c) = arg2;
    
    if (*(arg1 + 0x6c) == 0)
        *(arg1 + 0x6c) = data_10044c18;
    
    sub_10022990(*(arg1 + 0x6c));
    int32_t var_8_4 = 0xfffffffe;
    int32_t result = sub_10019016();
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10018fc0()
{
    return __unlock(0xd);
}

int32_t sub_10019016()
{
    return __unlock(0xc);
}

void* sub_10019040()
{
    enum WIN32_ERROR dwErrCode = GetLastError();
    void* result = sub_10018c20()(data_10044324);
    
    if (result == 0)
    {
        result = sub_10010a40(1, 0x214, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x24c, nullptr);
        
        if (result != 0)
        {
            if (sub_10018b70(data_10045b40)(data_10044324, result) == 0)
            {
                sub_10011340(result, 2);
                result = nullptr;
            }
            else
            {
                sub_10018ee0(result, 0);
                *result = GetCurrentThreadId();
                *(result + 4) = 0xffffffff;
            }
        }
    }
    
    SetLastError(dwErrCode);
    return result;
}

void* __getptd()
{
    int32_t ecx;
    int32_t var_8 = ecx;
    void* result = sub_10019040();
    
    if (result == 0)
        sub_10015620(0x10);
    
    return result;
}

void* __stdcall sub_10019130(void* arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041e30;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_34 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_38 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void* result = arg1;
    
    if (result != 0)
    {
        if (*(result + 0x24) != 0)
            sub_10011340(*(result + 0x24), 2);
        
        if (*(result + 0x2c) != 0)
            sub_10011340(*(result + 0x2c), 2);
        
        if (*(result + 0x34) != 0)
            sub_10011340(*(result + 0x34), 2);
        
        if (*(result + 0x3c) != 0)
            sub_10011340(*(result + 0x3c), 2);
        
        if (*(result + 0x40) != 0)
            sub_10011340(*(result + 0x40), 2);
        
        if (*(result + 0x44) != 0)
            sub_10011340(*(result + 0x44), 2);
        
        if (*(result + 0x48) != 0)
            sub_10011340(*(result + 0x48), 2);
        
        if (*(result + 0x5c) != 0x1003b270)
            sub_10011340(*(result + 0x5c), 2);
        
        __lock(0xd);
        int32_t var_8_1 = 0;
        int32_t edx_9 = *(result + 0x68);
        
        if ((edx_9 != 0 && (InterlockedDecrement(edx_9) == 0 && edx_9 != 0x10044610)))
            sub_10011340(edx_9, 2);
        
        int32_t var_8_2 = 0xfffffffe;
        sub_10019298();
        __lock(0xc);
        int32_t var_8_3 = 1;
        int32_t* eax_12 = *(result + 0x6c);
        
        if (eax_12 != 0)
        {
            sub_10022ab0(eax_12);
            
            if ((eax_12 != data_10044c18 && (eax_12 != 0x10044b40 && *eax_12 == 0)))
                sub_100226b0(eax_12);
        }
        
        int32_t var_8_4 = 0xfffffffe;
        sub_10019305();
        result = sub_10011340(result, 2);
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10019298()
{
    return __unlock(0xd);
}

int32_t sub_10019305()
{
    return __unlock(0xc);
}

void sub_10019340(void* arg1)
{
    if (data_10044324 != 0xffffffff)
    {
        if ((arg1 == 0 && TlsGetValue(data_10044328) != 0))
            arg1 = TlsGetValue(data_10044328)(data_10044324);
        
        sub_10018b70(data_10045b40)(data_10044324, 0);
        sub_10019130(arg1);
    }
    
    if (data_10044328 != 0xffffffff)
        TlsSetValue(data_10044328, nullptr);
}

int32_t ___p___argc() __pure
{
    return 0x10044330;
}

int32_t sub_100193d0()
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if (data_1004a380 == 0)
        data_1004a380 = 0x200;
    else if (data_1004a380 < 0x14)
        data_1004a380 = 0x14;
    
    data_10049360 = sub_10010b10(data_1004a380, 4, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x85);
    
    if (data_10049360 == 0)
    {
        data_1004a380 = 0x14;
        data_10049360 = sub_10010b10(data_1004a380, 4, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x88);
        
        if (data_10049360 == 0)
            return 0x1a;
    }
    
    for (int32_t i = 0; i < 0x14; i += 1)
        *(data_10049360 + (i << 2)) = ((i << 5) + 0x10044330);
    
    for (int32_t i_1 = 0; i_1 < 3; i_1 += 1)
    {
        if (((*(((i_1 & 0x1f) << 6) + &data_10049260[(i_1 >> 5)]) == 0xffffffff || *(((i_1 & 0x1f) << 6) + &data_10049260[(i_1 >> 5)]) == 0xfffffffe) || *(((i_1 & 0x1f) << 6) + &data_10049260[(i_1 >> 5)]) == 0))
            *((i_1 << 5) + 0x10044340) = 0xfffffffe;
    }
    
    return 0;
}

int32_t sub_10019520()
{
    ___acrt_get_developer_information_policy();
    
    if (data_10045afc != 0)
        sub_10027ba0();
    
    return sub_10011340(data_10049360, 2);
}

void* sub_10019550(void* arg1)
{
    if ((arg1 < 0x10044330 || arg1 > 0x10044590))
        return EnterCriticalSection((arg1 + 0x20));
    
    __lock((((arg1 - 0x10044330) >> 5) + 0x10));
    *(arg1 + 0xc) |= 0x8000;
    return arg1;
}

void* __lock_file2(int32_t arg1, void* arg2)
{
    if (arg1 >= 0x14)
        return EnterCriticalSection((arg2 + 0x20));
    
    __lock((arg1 + 0x10));
    *(arg2 + 0xc) |= 0x8000;
    return arg2;
}

int32_t sub_100195f0(void* arg1)
{
    if ((arg1 < 0x10044330 || arg1 > 0x10044590))
        return LeaveCriticalSection((arg1 + 0x20));
    
    *(arg1 + 0xc) &= 0xffff7fff;
    return __unlock((((arg1 - 0x10044330) >> 5) + 0x10));
}

int32_t __unlock_file2(int32_t arg1, void* arg2)
{
    if (arg1 >= 0x14)
        return LeaveCriticalSection((arg2 + 0x20));
    
    *(arg2 + 0xc) &= 0xffff7fff;
    return __unlock((arg1 + 0x10));
}

uint32_t sub_10019690(int32_t* arg1)
{
    int32_t var_8 = 0;
    int32_t eax;
    eax = arg1 != 0;
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x69, nullptr, u"str != NULL") == 1))
        breakpoint();
    
    if (eax == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"str != NULL", u"_filbuf", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x69, 0);
        return 0xffffffff;
    }
    
    if (((arg1[3] & 0x83) == 0 || (arg1[3] & 0x40) != 0))
        return 0xffffffff;
    
    if ((arg1[3] & 2) != 0)
    {
        arg1[3] |= 0x20;
        return 0xffffffff;
    }
    
    arg1[3] |= 1;
    
    if ((arg1[3] & 0x10c) != 0)
        *arg1 = arg1[2];
    else
        sub_10019ea0(arg1);
    
    arg1[1] = sub_10027cd0(sub_10019e20(arg1), arg1[2], arg1[6]);
    
    if ((arg1[1] == 0 || arg1[1] == 0xffffffff))
    {
        int32_t eax_16 = arg1[1];
        int32_t eax_17 = -(eax_16);
        arg1[3] |= (((eax_17 - eax_17) & 0x10) + 0x10);
        arg1[1] = 0;
        return 0xffffffff;
    }
    
    if ((arg1[3] & 0x82) == 0)
    {
        int32_t eax_24 = sub_10019e20(arg1);
        int32_t eax_25;
        
        if (eax_24 != 0xffffffff)
            eax_25 = sub_10019e20(arg1);
        
        void* var_10_1;
        
        if ((eax_24 == 0xffffffff || eax_25 == 0xfffffffe))
            var_10_1 = &data_100445b0;
        else
        {
            int32_t esi_2 = (sub_10019e20(arg1) >> 5);
            var_10_1 = (((sub_10019e20(arg1) & 0x1f) << 6) + &data_10049260[esi_2]);
        }
        
        if ((*(var_10_1 + 4) & 0x82) == 0x82)
            arg1[3] |= 0x2000;
    }
    
    if ((arg1[6] == 0x200 && ((arg1[3] & 8) != 0 && (arg1[3] & 0x400) == 0)))
        arg1[6] = 0x1000;
    
    arg1[1] -= 1;
    uint32_t result = **arg1;
    *arg1 += 1;
    return result;
}

int32_t sub_100198e0()
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_9c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x10041e58 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_a0 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_1c = &var_a0;
    int32_t var_8_1 = 0;
    void lpStartupInfo;
    GetStartupInfoA(&lpStartupInfo);
    int32_t var_8_2 = 0xfffffffe;
    void* i = sub_10010b10(0x20, 0x40, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x88);
    int32_t result;
    
    if (i != 0)
    {
        data_10049260 = i;
        data_10049258 = 0x20;
        
        for (; i < (data_10049260 + 0x800); i += 0x40)
        {
            *(i + 4) = 0;
            *i = 0xffffffff;
            *(i + 5) = 0xa;
            *(i + 8) = 0;
            void* eax_5;
            eax_5 = *(i + 0x24);
            eax_5 &= 0x80;
            *(i + 0x24) = eax_5;
            eax_5 = *(i + 0x24);
            eax_5 &= 0x7f;
            *(i + 0x24) = eax_5;
            *(i + 0x25) = 0xa;
            *(i + 0x26) = 0xa;
            *(i + 0x38) = 0;
            *(i + 0x34) = 0;
        }
        
        int16_t var_32;
        int32_t* var_30;
        
        if ((var_32 == 0 || var_30 == 0))
        {
        label_10019c13:
            int32_t var_70_2 = 0;
            
            while (true)
            {
                if (var_70_2 >= 3)
                {
                    SetHandleCount(data_10049258);
                    result = 0;
                    break;
                }
                
                int32_t* ecx_34 = ((var_70_2 << 6) + data_10049260);
                
                if ((*ecx_34 == 0xffffffff || *ecx_34 == 0xfffffffe))
                {
                    ecx_34[1] = 0x81;
                    enum STD_HANDLE nStdHandle;
                    
                    if (var_70_2 != 0)
                    {
                        int32_t edx_29 = -((var_70_2 - 1));
                        nStdHandle = ((edx_29 - edx_29) - 0xb);
                    }
                    else
                        nStdHandle = STD_INPUT_HANDLE;
                    
                    HANDLE hFile = GetStdHandle(nStdHandle);
                    enum FILE_TYPE eax_36;
                    
                    if ((hFile != 0xffffffff && hFile != 0))
                        eax_36 = GetFileType(hFile);
                    
                    if (((hFile == 0xffffffff || hFile == 0) || eax_36 == FILE_TYPE_UNKNOWN))
                    {
                        ecx_34[1] |= 0x40;
                        *ecx_34 = 0xfffffffe;
                    }
                    else
                    {
                        *ecx_34 = hFile;
                        
                        if (eax_36 == 2)
                            ecx_34[1] |= 0x40;
                        else if (eax_36 == 3)
                            ecx_34[1] |= 8;
                        
                        if (`eh vector constructor iterator'(&ecx_34[3], 0xfa0) == 0)
                        {
                            result = 0xffffffff;
                            break;
                        }
                        
                        ecx_34[2] += 1;
                    }
                }
                else
                    ecx_34[1] |= 0x80;
                
                var_70_2 += 1;
            }
        }
        else
        {
            int32_t i_3 = *var_30;
            void* var_78_1 = &var_30[1];
            void* var_84_1 = (var_78_1 + i_3);
            int32_t i_2;
            
            if (i_3 >= 0x800)
                i_2 = 0x800;
            else
                i_2 = i_3;
            
            int32_t i_1 = i_2;
            int32_t var_68_1 = 1;
            
            while (data_10049258 < i_1)
            {
                void* j = sub_10010b10(0x20, 0x40, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0xc0);
                
                if (j == 0)
                {
                    i_1 = data_10049258;
                    break;
                }
                
                &data_10049260[var_68_1] = j;
                data_10049258 += 0x20;
                
                for (; j < (&data_10049260[var_68_1] + 0x800); j += 0x40)
                {
                    *(j + 4) = 0;
                    *j = 0xffffffff;
                    *(j + 5) = 0xa;
                    *(j + 8) = 0;
                    void* eax_17;
                    eax_17 = *(j + 0x24);
                    eax_17 &= 0x80;
                    *(j + 0x24) = eax_17;
                    *(j + 0x25) = 0xa;
                    *(j + 0x26) = 0xa;
                    *(j + 0x38) = 0;
                    *(j + 0x34) = 0;
                }
                
                var_68_1 += 1;
            }
            
            int32_t var_70_1 = 0;
            
            while (true)
            {
                if (var_70_1 >= i_1)
                    goto label_10019c13;
                
                if ((*var_84_1 != 0xffffffff && (*var_84_1 != 0xfffffffe && (*var_78_1 & 1) != 0)))
                {
                    if ((*var_78_1 & 8) != 0)
                    {
                    label_10019bc0:
                        int32_t* ecx_28 = (((var_70_1 & 0x1f) << 6) + &data_10049260[(var_70_1 >> 5)]);
                        *ecx_28 = *var_84_1;
                        int32_t ecx_29;
                        ecx_29 = *var_78_1;
                        ecx_28[1] = ecx_29;
                        
                        if (`eh vector constructor iterator'(&ecx_28[3], 0xfa0) == 0)
                        {
                            result = 0xffffffff;
                            break;
                        }
                        
                        ecx_28[2] += 1;
                    }
                    else if (GetFileType(*var_84_1) != FILE_TYPE_UNKNOWN)
                        goto label_10019bc0;
                }
                
                var_70_1 += 1;
                var_78_1 += 1;
                var_84_1 += 4;
            }
        }
    }
    else
        result = 0xffffffff;
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1001992f() __pure
{
    return 1;
}

void __ioterm()
{
    for (int32_t i = 0; i < 0x40; i += 1)
    {
        if (&data_10049260[i] != 0)
        {
            for (void* j = &data_10049260[i]; j < (&data_10049260[i] + 0x800); j += 0x40)
            {
                if (*(j + 8) != 0)
                    DeleteCriticalSection((j + 0xc));
            }
            
            sub_10011340(&data_10049260[i], 2);
            &data_10049260[i] = 0;
        }
    }
}

int32_t sub_10019e20(void* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t eax;
    eax = arg1 != 0;
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x29, nullptr, u"(stream != NULL)") == 1))
        breakpoint();
    
    if (eax != 0)
        return *(arg1 + 0x10);
    
    *sub_1000eca0() = 0x16;
    sub_1000c310(u"(stream != NULL)", u"_fileno", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x29, 0);
    return 0xffffffff;
}

int32_t sub_10019ea0(int32_t* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if ((arg1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2e, nullptr, u"str != NULL") == 1))
        breakpoint();
    
    data_10045b48 += 1;
    arg1[2] = __malloc_dbg(0x1000, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x3a);
    
    if (arg1[2] == 0)
    {
        arg1[3] |= 4;
        arg1[2] = &arg1[5];
        arg1[6] = 2;
    }
    else
    {
        arg1[3] |= 8;
        arg1[6] = 0x1000;
    }
    
    int32_t result = arg1[2];
    *arg1 = result;
    arg1[1] = 0;
    return result;
}

int32_t* sub_10019f60(PWSTR arg1, int16_t* arg2, int32_t arg3, int32_t* arg4)
{
    int32_t var_18 = data_10046034;
    int32_t var_20 = 0;
    int32_t var_1c = 0;
    int32_t var_14 = 0;
    
    if ((arg1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x44, nullptr, u"filename != NULL") == 1))
        breakpoint();
    
    if ((arg2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x45, nullptr, u"mode != NULL") == 1))
        breakpoint();
    
    if ((arg4 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x46, nullptr, u"str != NULL") == 1))
        breakpoint();
    
    while (*arg2 == 0x20)
        arg2 = &arg2[1];
    
    uint32_t edx_2 = *arg2;
    int32_t var_10;
    
    if (edx_2 == 0x61)
    {
        var_10 = 0x109;
        var_18 |= 2;
    }
    else if (edx_2 == 0x72)
    {
        var_10 = 0;
        var_18 |= 1;
    }
    else if (edx_2 == 0x77)
    {
        var_10 = 0x301;
        var_18 |= 2;
    }
    else
    {
        int32_t var_44_1 = 0;
        
        if ((var_44_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x62, nullptr, u"("Invalid file open mode",0)") == 1))
            breakpoint();
        
        if (var_44_1 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"("Invalid file open mode",0)", u"_wopenfile", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x62, 0);
            return nullptr;
        }
    }
    
    int32_t var_24_1 = 1;
    
    while (true)
    {
        arg2 = &arg2[1];
        
        if (*arg2 == 0)
            break;
        
        if (var_24_1 == 0)
            break;
        
        switch ((*arg2 - 0x20))
        {
            case nullptr:
            {
                continue;
            }
            case 0xb:
            {
                if ((var_10 & 2) == 0)
                {
                    var_10 = ((var_10 | 2) & 0xfffffffe);
                    var_18 = ((var_18 | 0x80) & 0xfffffffc);
                    continue;
                }
                else
                {
                    var_24_1 = 0;
                    continue;
                }
                break;
            }
            case 0xc:
            {
                var_14 = 1;
                var_24_1 = 0;
                continue;
            }
            case 0x24:
            {
                if ((var_10 & 0x40) == 0)
                {
                    var_10 |= 0x40;
                    continue;
                }
                else
                {
                    var_24_1 = 0;
                    continue;
                }
                break;
            }
            case 0x2e:
            {
                var_10 |= 0x80;
                continue;
            }
            case 0x32:
            {
                if (var_1c == 0)
                {
                    var_1c = 1;
                    var_10 |= 0x10;
                    continue;
                }
                else
                {
                    var_24_1 = 0;
                    continue;
                }
                break;
            }
            case 0x33:
            {
                if (var_1c == 0)
                {
                    var_1c = 1;
                    var_10 |= 0x20;
                    continue;
                }
                else
                {
                    var_24_1 = 0;
                    continue;
                }
                break;
            }
            case 0x34:
            {
                if ((var_10 & 0x1000) == 0)
                {
                    var_10 |= 0x1000;
                    continue;
                }
                else
                {
                    var_24_1 = 0;
                    continue;
                }
                break;
            }
            case 0x42:
            {
                if ((var_10 & 0xc000) == 0)
                {
                    var_10 |= 0x8000;
                    continue;
                }
                else
                {
                    var_24_1 = 0;
                    continue;
                }
                break;
            }
            case 0x43:
            {
                if (var_20 == 0)
                {
                    var_20 = 1;
                    var_18 |= 0x4000;
                    continue;
                }
                else
                {
                    var_24_1 = 0;
                    continue;
                }
                break;
            }
            case 0x4e:
            {
                if (var_20 == 0)
                {
                    var_20 = 1;
                    var_18 &= 0xffffbfff;
                    continue;
                }
                else
                {
                    var_24_1 = 0;
                    continue;
                }
                break;
            }
            case 0x54:
            {
                if ((var_10 & 0xc000) == 0)
                {
                    var_10 |= 0x4000;
                    continue;
                }
                else
                {
                    var_24_1 = 0;
                    continue;
                }
                break;
            }
        }
        
        int32_t var_4c_1 = 0;
        
        if ((var_4c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xc9, nullptr, u"("Invalid file open mode",0)") == 1))
            breakpoint();
        
        if (var_4c_1 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"("Invalid file open mode",0)", u"_wopenfile", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xc9, 0);
            return nullptr;
        }
    }
    
    if (var_14 != 0)
    {
        while (*arg2 == 0x20)
            arg2 = &arg2[1];
        
        if (_wcsncmp(&data_1003a894, arg2, 3) != 0)
        {
            int32_t var_50_1 = 0;
            
            if ((var_50_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xdd, nullptr, u"("Invalid file open mode",0)") == 1))
                breakpoint();
            
            if (var_50_1 == 0)
            {
                *sub_1000eca0() = 0x16;
                sub_1000c310(u"("Invalid file open mode",0)", u"_wopenfile", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xdd, 0);
                return nullptr;
            }
        }
        
        arg2 = &arg2[3];
        
        while (*arg2 == 0x20)
            arg2 = &arg2[1];
        
        if (*arg2 != 0x3d)
        {
            int32_t var_54_1 = 0;
            
            if ((var_54_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xea, nullptr, u"("Invalid file open mode",0)") == 1))
                breakpoint();
            
            if (var_54_1 == 0)
            {
                *sub_1000eca0() = 0x16;
                sub_1000c310(u"("Invalid file open mode",0)", u"_wopenfile", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xea, 0);
                return nullptr;
            }
        }
        
        arg2 = &arg2[1];
        
        while (*arg2 == 0x20)
            arg2 = &arg2[1];
        
        if (sub_1002a370(arg2, u"UTF-8", 5) != 0)
        {
            if (sub_1002a370(arg2, u"UTF-16LE", 8) != 0)
            {
                if (sub_1002a370(arg2, u"UNICODE", 7) != 0)
                {
                    int32_t var_58_1 = 0;
                    
                    if ((var_58_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x101, nullptr, u"("Invalid file open mode",0)") == 1))
                        breakpoint();
                    
                    if (var_58_1 == 0)
                    {
                        *sub_1000eca0() = 0x16;
                        sub_1000c310(u"("Invalid file open mode",0)", u"_wopenfile", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x101, 0);
                        return nullptr;
                    }
                }
                else
                {
                    arg2 = &arg2[7];
                    var_10 |= 0x10000;
                }
            }
            else
            {
                arg2 = &arg2[8];
                var_10 |= 0x20000;
            }
        }
        else
        {
            arg2 = &arg2[5];
            var_10 |= 0x40000;
        }
    }
    
    while (*arg2 == 0x20)
        arg2 = &arg2[1];
    
    uint32_t edx_33 = *arg2;
    int32_t edx_34 = -(edx_33);
    int32_t edx_35 = (edx_34 - edx_34);
    
    if ((edx_35 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x10b, nullptr, u"(*mode == _T('\0'))") == 1))
        breakpoint();
    
    if (edx_35 == 0xffffffff)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(*mode == _T('\0'))", u"_wopenfile", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x10b, 0);
        return nullptr;
    }
    
    int32_t var_8;
    
    if (__sopen_s(&var_8, arg1, var_10, arg3, 0x180) != 0)
        return nullptr;
    
    data_10045b48 += 1;
    arg4[3] = var_18;
    arg4[1] = 0;
    *arg4 = 0;
    arg4[2] = 0;
    arg4[7] = 0;
    arg4[4] = var_8;
    return arg4;
}

int32_t* sub_1001a720()
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x10041e78 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_34 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* result = nullptr;
    __lock(1);
    int32_t var_8_1 = 0;
    
    for (int32_t i = 0; i < data_1004a380; i += 1)
    {
        if (*(data_10049360 + (i << 2)) == 0)
        {
            *(data_10049360 + (i << 2)) = __malloc_dbg(0x38, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x59);
            
            if (*(data_10049360 + (i << 2)) != 0)
            {
                if (`eh vector constructor iterator'((*(data_10049360 + (i << 2)) + 0x20), 0xfa0) != 0)
                {
                    EnterCriticalSection((*(data_10049360 + (i << 2)) + 0x20));
                    result = *(data_10049360 + (i << 2));
                    result[3] = 0;
                }
                else
                {
                    sub_10011340(*(data_10049360 + (i << 2)), 2);
                    *(data_10049360 + (i << 2)) = 0;
                }
            }
            
            break;
        }
        
        if (((*(*(data_10049360 + (i << 2)) + 0xc) & 0x83) == 0 && (*(*(data_10049360 + (i << 2)) + 0xc) & 0x8000) == 0))
        {
            if (((i > 2 && i < 0x14) && sub_10013830((i + 0x10)) == 0))
                break;
            
            __lock_file2(i, *(data_10049360 + (i << 2)));
            
            if ((*(*(data_10049360 + (i << 2)) + 0xc) & 0x83) == 0)
            {
                result = *(data_10049360 + (i << 2));
                break;
            }
            
            __unlock_file2(i, *(data_10049360 + (i << 2)));
        }
    }
    
    if (result != 0)
    {
        result[3] &= 0x8000;
        result[1] = 0;
        result[2] = 0;
        *result = 0;
        result[7] = 0;
        result[4] = 0xffffffff;
    }
    
    int32_t var_8_2 = 0xfffffffe;
    sub_1001a95d();
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1001a95d()
{
    return __unlock(1);
}

void* __local_unwind4(int32_t arg1, void* arg2, int32_t arg3)
{
    int32_t ebp;
    int32_t var_10 = ebp;
    int32_t var_14 = arg1;
    void* var_18 = arg2;
    int32_t var_1c = arg3;
    int32_t var_20 = arg3;
    int32_t (* var_24)(int32_t arg1, void* arg2, void** arg3) = __unwind_handler4;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t var_20_1 = (__security_cookie ^ &ExceptionList);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    
    while (true)
    {
        int32_t esi_1 = *(arg2 + 0xc);
        
        if (esi_1 == 0xfffffffe)
        {
            fsbase->NtTib.ExceptionList = ExceptionList;
            return arg2;
        }
        
        if ((arg3 != 0xfffffffe && esi_1 <= arg3))
        {
            fsbase->NtTib.ExceptionList = ExceptionList;
            return arg2;
        }
        
        int32_t* ebx_3 = (((*(arg2 + 8) ^ *arg1) + (esi_1 * 0xc)) + 0x10);
        *(arg2 + 0xc) = *ebx_3;
        
        if (ebx_3[1] == 0)
        {
            __NLG_Notify(ebx_3[2], ebp, 0x101);
            ebx_3[2];
            __NLG_Call();
        }
    }
}

int32_t __unwind_handler4(int32_t arg1, void* arg2, void** arg3)
{
    if ((*(arg1 + 4) & 6) == 0)
        return 1;
    
    void* eax_2 = sub_1000ac70((*(arg2 + 8) ^ arg2));
    *(eax_2 + 0x18);
    __local_unwind4(*(eax_2 + 0x14), *(eax_2 + 0x10), *(eax_2 + 0xc));
    *arg3 = arg2;
    return 3;
}

void* __stdcall sub_1001aa56(int32_t* arg1)
{
    *arg1;
    return __local_unwind4(arg1[0xa], arg1[6], arg1[7]);
}

int32_t @_EH4_CallFilterFunc@8()
{
    int32_t ecx;
    return ecx();
}

int32_t __fastcall @_EH4_TransferToHandler@8(int32_t arg1, int32_t arg2)
{
    __NLG_Notify(arg1, arg2, 1);
    /* jump -> arg1 */
}

int32_t __fastcall sub_1001aaa2(int32_t arg1)
{
    return RtlUnwind(arg1, &data_1001aab7, nullptr, nullptr);
}

void* __fastcall sub_1001aabc(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    return __local_unwind4(arg4, arg1, arg2);
}

int32_t sub_1001aae0(int32_t* arg1)
{
    if ((arg1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3f, nullptr, u"str != NULL") == 1))
        breakpoint();
    
    if (sub_10027410(sub_10019e20(arg1)) == 0)
        return 0;
    
    int32_t var_c_1;
    
    if (arg1 != 0x10044350)
    {
        if (arg1 != 0x10044370)
            return 0;
        
        var_c_1 = 1;
    }
    else
        var_c_1 = 0;
    
    data_10045b48 += 1;
    
    if ((arg1[3] & 0x10c) != 0)
        return 0;
    
    if (*((var_c_1 << 2) + &data_10045b4c) != 0)
    {
    label_1001abfb:
        arg1[2] = *((var_c_1 << 2) + &data_10045b4c);
        *arg1 = arg1[2];
        arg1[6] = 0x1000;
        arg1[1] = 0x1000;
    }
    else
    {
        *((var_c_1 << 2) + &data_10045b4c) = __malloc_dbg(0x1000, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x5b);
        
        if (*((var_c_1 << 2) + &data_10045b4c) != 0)
            goto label_1001abfb;
        
        arg1[2] = &arg1[5];
        *arg1 = arg1[2];
        arg1[6] = 2;
        arg1[1] = 2;
    }
    
    arg1[3] |= 0x1102;
    return 1;
}

void sub_1001ac40(int32_t arg1, int32_t* arg2)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if (((arg1 != 0 && arg1 != 1) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x8d, nullptr, u"flag == 0 || flag == 1") == 1))
        breakpoint();
    
    if ((arg1 != 0 && (arg2[3] & 0x1000) != 0))
    {
        sub_1000d670(arg2);
        arg2[3] &= 0xffffeeff;
        arg2[6] = 0;
        *arg2 = 0;
        arg2[2] = 0;
    }
}

enum WIN32_ERROR sub_1001acd0(int32_t arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041e98;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_38 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_3c = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    enum WIN32_ERROR result;
    
    if (arg1 != 0xfffffffe)
    {
        int32_t var_2c_1;
        
        if ((arg1 < 0 || arg1 >= data_10049258))
            var_2c_1 = 0;
        else
            var_2c_1 = 1;
        
        if ((var_2c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2c, nullptr, u"(filedes >= 0 && (unsigned)filed…") == 1))
            breakpoint();
        
        if (var_2c_1 != 0)
        {
            int32_t eax_9 = (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 1);
            int32_t eax_10 = -(eax_9);
            int32_t eax_12 = -((eax_10 - eax_10));
            
            if ((eax_12 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2d, nullptr, u"(_osfile(filedes) & FOPEN)") == 1))
                breakpoint();
            
            if (eax_12 != 0)
            {
                sub_1002aca0(arg1);
                int32_t var_8_1 = 0;
                
                if ((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 1) == 0)
                    goto label_1001ae88;
                
                enum WIN32_ERROR result_1;
                
                if (FlushFileBuffers(sub_1002ab30(arg1)) != 0)
                    result_1 = NO_ERROR;
                else
                    result_1 = GetLastError();
                
                if (result_1 != NO_ERROR)
                {
                    *sub_1000ecd0() = result_1;
                label_1001ae88:
                    *sub_1000eca0() = 9;
                    result_1 = ~NO_ERROR;
                    
                    if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x45, nullptr, u"("Invalid file descriptor. File …") == 1)
                        breakpoint();
                }
                
                int32_t var_8_2 = 0xfffffffe;
                $LN53(&__saved_ebp);
                result = result_1;
            }
            else
            {
                *sub_1000eca0() = 9;
                sub_1000c310(u"(_osfile(filedes) & FOPEN)", u"_commit", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2d, 0);
                result = ~NO_ERROR;
            }
        }
        else
        {
            *sub_1000eca0() = 9;
            sub_1000c310(u"(filedes >= 0 && (unsigned)filed…", u"_commit", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2c, 0);
            result = ~NO_ERROR;
        }
    }
    else
    {
        *sub_1000eca0() = 9;
        result = ~NO_ERROR;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t $LN53(void* arg1 @ ebp)
{
    return __unlock_fhandle(*(arg1 + 8));
}

int32_t sub_1001aef0(PWSTR arg1, char* arg2, uint32_t arg3)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041eb8;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_38 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_3c = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result;
    
    if (arg1 != 0xfffffffe)
    {
        int32_t var_2c_1;
        
        if ((arg1 < 0 || arg1 >= data_10049258))
            var_2c_1 = 0;
        else
            var_2c_1 = 1;
        
        if ((var_2c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x44, nullptr, u"(fh >= 0 && (unsigned)fh < (unsi…") == 1))
            breakpoint();
        
        if (var_2c_1 != 0)
        {
            int32_t eax_11 = (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 1);
            int32_t eax_12 = -(eax_11);
            int32_t eax_14 = -((eax_12 - eax_12));
            
            if ((eax_14 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x45, nullptr, u"(_osfile(fh) & FOPEN)") == 1))
                breakpoint();
            
            if (eax_14 != 0)
            {
                sub_1002aca0(arg1);
                int32_t var_8_1 = 0;
                int32_t result_1;
                
                if ((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 1) == 0)
                {
                    *sub_1000eca0() = 9;
                    *sub_1000ecd0() = 0;
                    result_1 = 0xffffffff;
                    
                    if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x50, nullptr, u"("Invalid file descriptor. File …") == 1)
                        breakpoint();
                }
                else
                    result_1 = sub_1001b120(arg1, arg2, arg3);
                
                int32_t var_8_2 = 0xfffffffe;
                sub_1001b0ef(&__saved_ebp);
                result = result_1;
            }
            else
            {
                *sub_1000ecd0() = 0;
                *sub_1000eca0() = 9;
                sub_1000c310(u"(_osfile(fh) & FOPEN)", u"_write", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x45, 0);
                result = 0xffffffff;
            }
        }
        else
        {
            *sub_1000ecd0() = 0;
            *sub_1000eca0() = 9;
            sub_1000c310(u"(fh >= 0 && (unsigned)fh < (unsi…", u"_write", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x44, 0);
            result = 0xffffffff;
        }
    }
    else
    {
        *sub_1000ecd0() = 0;
        *sub_1000eca0() = 9;
        result = 0xffffffff;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1001b0ef(void* arg1 @ ebp)
{
    return __unlock_fhandle(*(arg1 + 8));
}

int32_t sub_1001b120(PWSTR arg1, char* arg2, uint32_t arg3)
{
    __chkstk(0x3c90);
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    BOOL var_1c = 0;
    int32_t var_20 = 0;
    HANDLE hFile = nullptr;
    
    if (arg3 != 0)
    {
        int32_t ecx_1;
        ecx_1 = arg2 != 0;
        PWSTR lpWideCharStr_3;
        int32_t var_10;
        void* var_c;
        
        if (ecx_1 == 0)
        {
            wchar16 const* const var_8_1 = u"(buf != NULL)";
            var_c = nullptr;
            var_10 = 0x70;
            lpWideCharStr_3 = u"f:\dd\vctools\crt_bld\self_x86\c…";
            hFile = 2;
            
            if (sub_1000b040(hFile, lpWideCharStr_3, var_10, var_c, var_8_1) == 1)
                breakpoint();
        }
        
        if (ecx_1 != 0)
        {
            int32_t eax_8;
            eax_8 = *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x24);
            eax_8 <<= 1;
            eax_8 s>>= 1;
            *var_c[3] = eax_8;
            
            if ((*var_c[3] == 2 || *var_c[3] == 1))
            {
                int32_t eax_10 = (arg3 & 1);
                int32_t eax_11 = -(eax_10);
                int32_t eax_12 = (eax_11 - eax_11);
                
                if (eax_12 == 0xffffffff)
                {
                    wchar16 const* const var_8_3 = u"((cnt & 1) == 0)";
                    var_c = nullptr;
                    var_10 = 0x78;
                    lpWideCharStr_3 = u"f:\dd\vctools\crt_bld\self_x86\c…";
                    hFile = 2;
                    
                    if (sub_1000b040(hFile, lpWideCharStr_3, var_10, var_c, var_8_3) == 1)
                        breakpoint();
                }
                
                if (eax_12 != 0xffffffff)
                    goto label_1001b290;
                
                *sub_1000ecd0() = 0;
                *sub_1000eca0() = 0x16;
                int32_t var_8_4 = 0;
                int32_t var_c_2 = 0x78;
                wchar16 const* const var_10_2 = u"f:\dd\vctools\crt_bld\self_x86\c…";
                lpWideCharStr_3 = u"_write_nolock";
                sub_1000c310(u"((cnt & 1) == 0)", lpWideCharStr_3, var_10_2, var_c_2, var_8_4);
            }
            else
            {
            label_1001b290:
                
                if ((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 0x20) != 0)
                {
                    enum SET_FILE_POINTER_MOVE_METHOD var_8_5 = FILE_END;
                    var_c = nullptr;
                    var_10 = 0;
                    lpWideCharStr_3 = arg1;
                    sub_10027320(lpWideCharStr_3, var_10, var_c, var_8_5);
                }
                
                OVERLAPPED* lpWideCharStr_2 = arg1;
                
                if ((sub_10027410(lpWideCharStr_2) != 0 && (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 0x80) != 0))
                {
                    int32_t edx_11;
                    edx_11 = *(*(__getptd() + 0x6c) + 0x14) == 0;
                    var_20 = edx_11;
                    void var_2c;
                    lpWideCharStr_2 = &var_2c;
                    var_c = &data_10049260[(arg1 >> 5)][((arg1 & 0x1f) * 0x10)];
                    var_1c = GetConsoleMode(var_c, lpWideCharStr_2);
                }
                
                if ((var_1c != 0 && (var_20 == 0 || *var_c[3] != 0)))
                {
                    uint32_t CodePage = GetConsoleCP();
                    int32_t var_3c_1 = 0;
                    int32_t var_38 = 0;
                    char* var_34_1 = arg2;
                    
                    while ((var_34_1 - arg2) < arg3)
                    {
                        int32_t var_54;
                        char var_50;
                        wchar16 lpWideCharStr_1;
                        
                        if (*var_c[3] == 0)
                        {
                            int32_t edx_17;
                            edx_17 = *var_34_1 == 0xa;
                            var_54 = edx_17;
                            
                            if (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x38) == 0)
                            {
                                int32_t edx_24 = *var_34_1;
                                
                                if (__mkgmtime32(edx_24) == 0)
                                {
                                    lpWideCharStr_2 = 1;
                                    var_c = var_34_1;
                                    var_10 = &lpWideCharStr_1;
                                    
                                    if (_wcstoll(var_10, var_c, lpWideCharStr_2) == 0xffffffff)
                                        break;
                                }
                                else
                                {
                                    if ((arg3 - (var_34_1 - arg2)) <= 1)
                                    {
                                        char* edx_28;
                                        edx_28 = *var_34_1;
                                        *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x34) = edx_28;
                                        *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x38) = 1;
                                        lpWideCharStr_2 = (edx_24 + 1);
                                        break;
                                    }
                                    
                                    lpWideCharStr_2 = 2;
                                    var_c = var_34_1;
                                    var_10 = &lpWideCharStr_1;
                                    
                                    if (_wcstoll(var_10, var_c, lpWideCharStr_2) == 0xffffffff)
                                        break;
                                    
                                    var_34_1 = &var_34_1[1];
                                }
                            }
                            else
                            {
                                if (__mkgmtime32(*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x34)) == 0)
                                {
                                    wchar16 const* const var_8_7 = u"isleadbyte(_dbcsBuffer(fh))";
                                    void* var_c_3 = nullptr;
                                    int32_t var_10_3 = 0xb2;
                                    lpWideCharStr_3 = u"f:\dd\vctools\crt_bld\self_x86\c…";
                                    hFile = 2;
                                    
                                    if (sub_1000b040(hFile, lpWideCharStr_3, var_10_3, var_c_3, var_8_7) == 1)
                                        breakpoint();
                                }
                                
                                int32_t edx_21;
                                edx_21 = *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x34);
                                var_50 = edx_21;
                                int32_t ecx_22;
                                ecx_22 = *var_34_1;
                                char var_4f_1 = ecx_22;
                                *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x38) = 0;
                                lpWideCharStr_2 = 2;
                                var_c = &var_50;
                                var_10 = &lpWideCharStr_1;
                                
                                if (_wcstoll(var_10, var_c, lpWideCharStr_2) == 0xffffffff)
                                    break;
                            }
                            
                            var_34_1 = &var_34_1[1];
                        }
                        else if ((*var_c[3] == 1 || *var_c[3] == 2))
                        {
                            int32_t ecx_34;
                            ecx_34 = *var_34_1;
                            lpWideCharStr_1 = ecx_34;
                            int32_t eax_62;
                            eax_62 = lpWideCharStr_1 == 0xa;
                            var_54 = eax_62;
                            var_34_1 = &var_34_1[2];
                        }
                        
                        if (*var_c[3] != 0)
                        {
                            if ((*var_c[3] != 1 && *var_c[3] != 2))
                                continue;
                            
                            lpWideCharStr_2 = lpWideCharStr_1;
                            
                            if (sub_1002add0() != lpWideCharStr_1)
                            {
                                var_10 = GetLastError();
                                break;
                            }
                            
                            lpWideCharStr_2 = (&lpWideCharStr_2->Internal + 2);
                            
                            if (var_54 != 0)
                            {
                                int32_t var_3c_4 = 1;
                                lpWideCharStr_1 = 0xd;
                                lpWideCharStr_2 = lpWideCharStr_1;
                                
                                if (sub_1002add0() != lpWideCharStr_1)
                                {
                                    var_10 = GetLastError();
                                    break;
                                }
                                
                                lpWideCharStr_2 = (&lpWideCharStr_2->Internal + 1);
                                hFile += 1;
                            }
                        }
                        else
                        {
                            lpWideCharStr_2 = nullptr;
                            PSTR lpDefaultChar = nullptr;
                            var_10 = 5;
                            lpWideCharStr_3 = &var_50;
                            int32_t eax_63 = WideCharToMultiByte(CodePage, 0, &lpWideCharStr_1, 1, lpWideCharStr_3, var_10, lpDefaultChar, lpWideCharStr_2);
                            
                            if (eax_63 == 0)
                                break;
                            
                            lpWideCharStr_2 = nullptr;
                            var_c = &var_38;
                            var_10 = eax_63;
                            lpWideCharStr_3 = &var_50;
                            hFile = &data_10049260[(arg1 >> 5)][((arg1 & 0x1f) * 0x10)];
                            
                            if (WriteFile(hFile, lpWideCharStr_3, var_10, var_c, lpWideCharStr_2) == 0)
                            {
                                var_10 = GetLastError();
                                break;
                            }
                            
                            lpWideCharStr_2 = ((var_34_1 - arg2) + hFile);
                            
                            if (var_38 < eax_63)
                                break;
                            
                            if (var_54 != 0)
                            {
                                int32_t var_3c_3 = 1;
                                var_50 = 0xd;
                                lpWideCharStr_2 = nullptr;
                                var_c = &var_38;
                                var_10 = var_3c_3;
                                lpWideCharStr_3 = &var_50;
                                hFile = &data_10049260[(arg1 >> 5)][((arg1 & 0x1f) * 0x10)];
                                
                                if (WriteFile(hFile, lpWideCharStr_3, var_10, var_c, lpWideCharStr_2) == 0)
                                {
                                    var_10 = GetLastError();
                                    break;
                                }
                                
                                if (var_38 < var_3c_3)
                                    break;
                                
                                hFile += 1;
                                lpWideCharStr_2 = (&lpWideCharStr_2->Internal + 1);
                            }
                        }
                    }
                }
                else if ((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 0x80) == 0)
                {
                    lpWideCharStr_2 = nullptr;
                    PWSTR* lpNumberOfBytesWritten_3 = &lpWideCharStr_3;
                    lpWideCharStr_3 = arg2;
                    
                    if (WriteFile(&data_10049260[(arg1 >> 5)][((arg1 & 0x1f) * 0x10)], lpWideCharStr_3, arg3, lpNumberOfBytesWritten_3, lpWideCharStr_2) == 0)
                        var_10 = GetLastError();
                    else
                    {
                        var_10 = 0;
                        lpWideCharStr_2 = lpWideCharStr_3;
                    }
                }
                else
                {
                    var_10 = 0;
                    
                    if (*var_c[3] == 0)
                    {
                        int32_t var_1458_1 = 0;
                        int32_t var_145c_1 = 0;
                        char* var_1458_2 = arg2;
                        
                        while ((var_1458_2 - arg2) < arg3)
                        {
                            void var_1454;
                            char* var_145c_2 = &var_1454;
                            
                            while ((var_145c_2 - &var_1454) < 0x13ff)
                            {
                                if ((var_1458_2 - arg2) >= arg3)
                                    break;
                                
                                char ecx_58 = *var_1458_2;
                                var_1458_2 = &var_1458_2[1];
                                
                                if (ecx_58 == 0xa)
                                {
                                    hFile += 1;
                                    *var_145c_2 = 0xd;
                                    var_145c_2 = &var_145c_2[1];
                                }
                                
                                void* edx_51;
                                edx_51 = ecx_58;
                                *var_145c_2 = edx_51;
                                var_145c_2 = &var_145c_2[1];
                            }
                            
                            lpWideCharStr_2 = nullptr;
                            PWSTR* lpNumberOfBytesWritten = &lpWideCharStr_3;
                            var_10 = (var_145c_2 - &var_1454);
                            lpWideCharStr_3 = &var_1454;
                            hFile = &data_10049260[(arg1 >> 5)][((arg1 & 0x1f) * 0x10)];
                            
                            if (WriteFile(hFile, lpWideCharStr_3, var_10, lpNumberOfBytesWritten, lpWideCharStr_2) == 0)
                            {
                                var_10 = GetLastError();
                                break;
                            }
                            
                            lpWideCharStr_2 += lpWideCharStr_3;
                            
                            if (lpWideCharStr_3 < (var_145c_2 - &var_1454))
                                break;
                        }
                    }
                    else if (*var_c[3] != 2)
                    {
                        char* var_2f30_1 = arg2;
                        int32_t var_2f28_1 = 0;
                        char* var_2f30_2 = arg2;
                        
                        while ((var_2f30_2 - arg2) < arg3)
                        {
                            int32_t var_3c90_1 = 0;
                            void lpWideCharStr;
                            int16_t* var_2f28_2 = &lpWideCharStr;
                            
                            while ((var_2f28_2 - &lpWideCharStr) < 0x6a8)
                            {
                                if ((var_2f30_2 - arg2) >= arg3)
                                    break;
                                
                                int16_t ecx_77 = *var_2f30_2;
                                var_2f30_2 = &var_2f30_2[2];
                                
                                if (ecx_77 == 0xa)
                                {
                                    *var_2f28_2 = 0xd;
                                    var_2f28_2 = &var_2f28_2[1];
                                }
                                
                                void* edx_75;
                                edx_75 = ecx_77;
                                *var_2f28_2 = edx_75;
                                var_2f28_2 = &var_2f28_2[1];
                            }
                            
                            lpWideCharStr_2 = nullptr;
                            PSTR lpDefaultChar_1 = nullptr;
                            int32_t cbMultiByte = 0xd55;
                            void var_3c8c;
                            lpWideCharStr_3 = &var_3c8c;
                            int32_t eax_125;
                            int32_t edx_76;
                            edx_76 = HIGHD((var_2f28_2 - &lpWideCharStr));
                            eax_125 = LOWD((var_2f28_2 - &lpWideCharStr));
                            int32_t eax_128 = WideCharToMultiByte(0xfde9, 0, &lpWideCharStr, ((eax_125 - edx_76) >> 1), lpWideCharStr_3, cbMultiByte, lpDefaultChar_1, lpWideCharStr_2);
                            
                            if (eax_128 == 0)
                            {
                                var_10 = GetLastError();
                                break;
                            }
                            
                            int32_t var_3c94_1 = 0;
                            
                            do
                            {
                                lpWideCharStr_2 = nullptr;
                                uint32_t* lpNumberOfBytesWritten_2 = &lpWideCharStr_3;
                                var_10 = (eax_128 - var_3c94_1);
                                lpWideCharStr_3 = ((&__saved_ebp + var_3c94_1) - 0x3c88);
                                
                                if (WriteFile(&data_10049260[(arg1 >> 5)][((arg1 & 0x1f) * 0x10)], lpWideCharStr_3, var_10, lpNumberOfBytesWritten_2, lpWideCharStr_2) == 0)
                                {
                                    var_10 = GetLastError();
                                    break;
                                }
                                
                                var_3c94_1 += lpWideCharStr_3;
                            } while (eax_128 > var_3c94_1);
                            
                            if (eax_128 > var_3c94_1)
                                break;
                            
                            lpWideCharStr_2 = (var_2f30_2 - arg2);
                        }
                    }
                    else
                    {
                        char* var_2870_1 = arg2;
                        int32_t var_2868_1 = 0;
                        
                        while ((var_2870_1 - arg2) < arg3)
                        {
                            void var_2864;
                            void* var_2868_2 = &var_2864;
                            
                            while ((var_2868_2 - &var_2864) < 0x13fe)
                            {
                                if ((var_2870_1 - arg2) >= arg3)
                                    break;
                                
                                int16_t edx_59 = *var_2870_1;
                                var_2870_1 = &var_2870_1[2];
                                
                                if (edx_59 == 0xa)
                                {
                                    hFile += 2;
                                    *var_2868_2 = 0xd;
                                    var_2868_2 += 2;
                                }
                                
                                void* ecx_69;
                                ecx_69 = edx_59;
                                *var_2868_2 = ecx_69;
                                var_2868_2 += 2;
                            }
                            
                            lpWideCharStr_2 = nullptr;
                            PWSTR* lpNumberOfBytesWritten_1 = &lpWideCharStr_3;
                            var_10 = (var_2868_2 - &var_2864);
                            lpWideCharStr_3 = &var_2864;
                            hFile = &data_10049260[(arg1 >> 5)][((arg1 & 0x1f) * 0x10)];
                            
                            if (WriteFile(hFile, lpWideCharStr_3, var_10, lpNumberOfBytesWritten_1, lpWideCharStr_2) == 0)
                            {
                                var_10 = GetLastError();
                                break;
                            }
                            
                            lpWideCharStr_2 += lpWideCharStr_3;
                            
                            if (lpWideCharStr_3 < (var_2868_2 - &var_2864))
                                break;
                        }
                    }
                }
                
                if (lpWideCharStr_2 == 0)
                {
                    if (var_10 == 0)
                    {
                        if (((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 0x40) == 0 || *arg2 != 0x1a))
                        {
                            *sub_1000eca0() = 0x1c;
                            *sub_1000ecd0() = 0;
                        }
                    }
                    else if (var_10 != 5)
                        ___acrt_errno_map_os_error(var_10);
                    else
                    {
                        *sub_1000eca0() = 9;
                        *sub_1000ecd0() = var_10;
                    }
                }
            }
        }
        else
        {
            *sub_1000ecd0() = 0;
            *sub_1000eca0() = 0x16;
            int32_t var_8_2 = 0;
            int32_t var_c_1 = 0x70;
            wchar16 const* const var_10_1 = u"f:\dd\vctools\crt_bld\self_x86\c…";
            lpWideCharStr_3 = u"_write_nolock";
            sub_1000c310(u"(buf != NULL)", lpWideCharStr_3, var_10_1, var_c_1, var_8_2);
        }
    }
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t sub_1001bbfc(int32_t* arg1 @ ebp)
{
    int32_t result = sub_1000ac70((arg1[-0x11] ^ arg1));
    *arg1;
    return result;
}

int32_t sub_1001bc60(int32_t arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041ed8;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_38 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_3c = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result;
    
    if (arg1 != 0xfffffffe)
    {
        int32_t var_2c_1;
        
        if ((arg1 < 0 || arg1 >= data_10049258))
            var_2c_1 = 0;
        else
            var_2c_1 = 1;
        
        if ((var_2c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2f, nullptr, u"(fh >= 0 && (unsigned)fh < (unsi…") == 1))
            breakpoint();
        
        if (var_2c_1 != 0)
        {
            int32_t eax_11 = (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 1);
            int32_t eax_12 = -(eax_11);
            int32_t eax_14 = -((eax_12 - eax_12));
            
            if ((eax_14 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x30, nullptr, u"(_osfile(fh) & FOPEN)") == 1))
                breakpoint();
            
            if (eax_14 != 0)
            {
                sub_1002aca0(arg1);
                int32_t var_8_1 = 0;
                int32_t result_1;
                
                if ((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 1) == 0)
                {
                    *sub_1000eca0() = 9;
                    result_1 = 0xffffffff;
                    
                    if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3a, nullptr, u"("Invalid file descriptor. File …") == 1)
                        breakpoint();
                }
                else
                    result_1 = sub_1001be70(arg1);
                
                int32_t var_8_2 = 0xfffffffe;
                $LN20(&__saved_ebp);
                result = result_1;
            }
            else
            {
                *sub_1000ecd0() = 0;
                *sub_1000eca0() = 9;
                sub_1000c310(u"(_osfile(fh) & FOPEN)", u"_close", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x30, 0);
                result = 0xffffffff;
            }
        }
        else
        {
            *sub_1000ecd0() = 0;
            *sub_1000eca0() = 9;
            sub_1000c310(u"(fh >= 0 && (unsigned)fh < (unsi…", u"_close", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2f, 0);
            result = 0xffffffff;
        }
    }
    else
    {
        *sub_1000ecd0() = 0;
        *sub_1000eca0() = 9;
        result = 0xffffffff;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t $LN20(void* arg1 @ ebp)
{
    return __unlock_fhandle(*(arg1 + 8));
}

int32_t sub_1001be70(int32_t arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    enum WIN32_ERROR var_8_1;
    
    if (sub_1002ab30(arg1) == 0xffffffff)
        var_8_1 = NO_ERROR;
    else if (((arg1 != 1 || (*(data_10049260 + 0x84) & 1) == 0) && (arg1 != 2 || (*(data_10049260 + 0x44) & 1) == 0)))
    {
    label_1001bedb:
        
        if (CloseHandle(sub_1002ab30(arg1)) == 0)
            var_8_1 = GetLastError();
        else
            var_8_1 = NO_ERROR;
    }
    else
    {
        if (sub_1002ab30(1) != sub_1002ab30(2))
            goto label_1001bedb;
        
        var_8_1 = NO_ERROR;
    }
    
    __free_osfhnd(arg1);
    *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) = 0;
    
    if (var_8_1 == NO_ERROR)
        return 0;
    
    ___acrt_errno_map_os_error(var_8_1);
    return 0xffffffff;
}

void sub_1001bf40(int32_t* arg1)
{
    if ((arg1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x30, nullptr, u"stream != NULL") == 1))
        breakpoint();
    
    if (((arg1[3] & 0x83) != 0 && (arg1[3] & 8) != 0))
    {
        sub_10011340(arg1[2], 2);
        arg1[3] &= 0xfffffbf7;
        *arg1 = 0;
        arg1[2] = 0;
        arg1[1] = 0;
    }
}

uint32_t sub_1001bfd0(int32_t arg1, int32_t arg2, enum SET_FILE_POINTER_MOVE_METHOD arg3)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041ef8;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_38 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_3c = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    uint32_t result;
    
    if (arg1 != 0xfffffffe)
    {
        int32_t var_2c_1;
        
        if ((arg1 < 0 || arg1 >= data_10049258))
            var_2c_1 = 0;
        else
            var_2c_1 = 1;
        
        if ((var_2c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x42, nullptr, u"(fh >= 0 && (unsigned)fh < (unsi…") == 1))
            breakpoint();
        
        if (var_2c_1 != 0)
        {
            int32_t eax_11 = (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 1);
            int32_t eax_12 = -(eax_11);
            int32_t eax_14 = -((eax_12 - eax_12));
            
            if ((eax_14 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x43, nullptr, u"(_osfile(fh) & FOPEN)") == 1))
                breakpoint();
            
            if (eax_14 != 0)
            {
                sub_1002aca0(arg1);
                int32_t var_8_1 = 0;
                uint32_t result_1;
                
                if ((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 1) == 0)
                {
                    *sub_1000eca0() = 9;
                    *sub_1000ecd0() = 0;
                    result_1 = 0xffffffff;
                    
                    if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x4e, nullptr, u"("Invalid file descriptor. File …") == 1)
                        breakpoint();
                }
                else
                    result_1 = sub_1001c200(arg1, arg2, arg3);
                
                int32_t var_8_2 = 0xfffffffe;
                sub_1001c1cf(&__saved_ebp);
                result = result_1;
            }
            else
            {
                *sub_1000ecd0() = 0;
                *sub_1000eca0() = 9;
                sub_1000c310(u"(_osfile(fh) & FOPEN)", u"_lseek", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x43, 0);
                result = 0xffffffff;
            }
        }
        else
        {
            *sub_1000ecd0() = 0;
            *sub_1000eca0() = 9;
            sub_1000c310(u"(fh >= 0 && (unsigned)fh < (unsi…", u"_lseek", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x42, 0);
            result = 0xffffffff;
        }
    }
    else
    {
        *sub_1000ecd0() = 0;
        *sub_1000eca0() = 9;
        result = 0xffffffff;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1001c1cf(void* arg1 @ ebp)
{
    return __unlock_fhandle(*(arg1 + 8));
}

uint32_t sub_1001c200(int32_t arg1, int32_t arg2, enum SET_FILE_POINTER_MOVE_METHOD arg3)
{
    HANDLE hFile = sub_1002ab30(arg1);
    
    if (hFile == 0xffffffff)
    {
        *sub_1000eca0() = 9;
        
        if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x6c, nullptr, u"("Invalid file descriptor",0)") != 1)
            return 0xffffffff;
        
        breakpoint();
    }
    
    uint32_t result = SetFilePointer(hFile, arg2, nullptr, arg3);
    enum WIN32_ERROR var_10_1;
    
    if (result != 0xffffffff)
        var_10_1 = NO_ERROR;
    else
        var_10_1 = GetLastError();
    
    if (var_10_1 == NO_ERROR)
    {
        *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) &= 0xfd;
        return result;
    }
    
    ___acrt_errno_map_os_error(var_10_1);
    return 0xffffffff;
}

int32_t sub_1001c2e0(int32_t* arg1)
{
    int32_t eax;
    eax = arg1 != 0;
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5e, nullptr, u"(str != NULL)") == 1))
        breakpoint();
    
    if (eax == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(str != NULL)", u"_ftell_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5e, 0);
        return 0xffffffff;
    }
    
    int32_t eax_5 = sub_10019e20(arg1);
    
    if (arg1[1] < 0)
        arg1[1] = 0;
    
    uint32_t var_20_1 = sub_1001bfd0(eax_5, 0, FILE_CURRENT);
    
    if (var_20_1 < 0)
        return 0xffffffff;
    
    if ((arg1[3] & 0x108) == 0)
        return (var_20_1 - arg1[1]);
    
    int32_t result = (*arg1 - arg1[2]);
    
    if ((arg1[3] & 3) == 0)
    {
        if ((arg1[3] & 0x80) == 0)
        {
            *sub_1000eca0() = 0x16;
            return 0xffffffff;
        }
    }
    else if ((*((&data_10049260[(eax_5 >> 5)] + ((eax_5 & 0x1f) << 6)) + 4) & 0x80) != 0)
    {
        for (char* i = arg1[2]; i < *arg1; i = &i[1])
        {
            if (*i == 0xa)
                result += 1;
        }
    }
    
    if (var_20_1 == 0)
        return result;
    
    if ((arg1[3] & 1) != 0)
    {
        if (arg1[1] != 0)
        {
            int32_t var_14_1 = ((*arg1 - arg1[2]) + arg1[1]);
            
            if ((*((&data_10049260[(eax_5 >> 5)] + ((eax_5 & 0x1f) << 6)) + 4) & 0x80) != 0)
            {
                if (sub_1001bfd0(eax_5, 0, FILE_END) != var_20_1)
                {
                    if (sub_1001bfd0(eax_5, var_20_1, FILE_BEGIN) < 0)
                        return 0xffffffff;
                    
                    if (((var_14_1 > 0x200 || (arg1[3] & 8) == 0) || (arg1[3] & 0x400) != 0))
                        var_14_1 = arg1[6];
                    else
                        var_14_1 = 0x200;
                    
                    if ((*((&data_10049260[(eax_5 >> 5)] + ((eax_5 & 0x1f) << 6)) + 4) & 4) != 0)
                        var_14_1 += 1;
                }
                else
                {
                    int32_t ecx_23 = (arg1[2] + var_14_1);
                    
                    for (char* i_1 = arg1[2]; i_1 < ecx_23; i_1 = &i_1[1])
                    {
                        if (*i_1 == 0xa)
                            var_14_1 += 1;
                    }
                    
                    if ((arg1[3] & 0x2000) != 0)
                        var_14_1 += 1;
                }
            }
            
            var_20_1 -= var_14_1;
        }
        else
            result = 0;
    }
    
    return (var_20_1 + result);
}

int32_t sub_1001c5b0(void* arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041f18;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_34 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    
    if ((arg1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x31, nullptr, u"stream != NULL") == 1))
        breakpoint();
    
    sub_10019550(arg1);
    int32_t var_8_1 = 0;
    int32_t result;
    int32_t edx_1;
    result = sub_1001c660(arg1);
    int32_t var_20 = edx_1;
    int32_t var_8_2 = 0xfffffffe;
    sub_1001c639(&__saved_ebp);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1001c639(void* arg1 @ ebp)
{
    return sub_100195f0(*(arg1 + 8));
}

int32_t sub_1001c660(void* arg1)
{
    __chkstk(0x1060);
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    void* i_1;
    void* i = i_1;
    
    if ((arg1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5d, nullptr, u"str != NULL") == 1))
        breakpoint();
    
    uint32_t eax_3 = sub_10019e20(arg1);
    
    if (*(arg1 + 4) < 0)
        *(arg1 + 4) = 0;
    
    enum SET_FILE_POINTER_MOVE_METHOD var_c_4 = FILE_CURRENT;
    uint32_t eax_5;
    int32_t edx_2;
    eax_5 = sub_100270d0(eax_3, 0, 0, var_c_4);
    
    if (edx_2 > 0)
    {
    label_1001c70d:
        int32_t eax_8;
        eax_8 = *((&data_10049260[(eax_3 >> 5)] + ((eax_3 & 0x1f) << 6)) + 0x24);
        eax_8 <<= 1;
        eax_8 s>>= 1;
        int32_t var_10_2;
        *var_10_2[3] = eax_8;
        
        if ((*(var_c_4 + 0xc) & 0x108) != 0)
        {
            uint32_t var_14_3 = (*var_c_4 - *(var_c_4 + 8));
            
            if ((*(var_c_4 + 0xc) & 3) != 0)
            {
                if ((*var_10_2[3] != 1 || *((&data_10049260[(eax_3 >> 5)] + ((eax_3 & 0x1f) << 6)) + 0x30) == 0))
                {
                    if ((*((&data_10049260[(eax_3 >> 5)] + ((eax_3 & 0x1f) << 6)) + 4) & 0x80) == 0)
                        goto label_1001ca04;
                    
                    for (i = *(var_c_4 + 8); i < *var_c_4; i += 1)
                    {
                        if (*i == 0xa)
                            var_14_3 += 1;
                    }
                    
                    goto label_1001ca04;
                }
                
                uint32_t var_30_1 = ((*var_c_4 - *(var_c_4 + 8)) >> 1);
                
                if (*(var_c_4 + 4) != 0)
                {
                    int32_t ecx_17 = ((eax_3 & 0x1f) << 6);
                    int32_t edx_16 = &data_10049260[(eax_3 >> 5)];
                    uint32_t eax_24;
                    int32_t edx_18;
                    eax_24 = sub_100270d0(eax_3, *((edx_16 + ecx_17) + 0x28), *((edx_16 + ecx_17) + 0x2c), FILE_BEGIN);
                    int32_t ecx_21 = ((eax_3 & 0x1f) << 6);
                    int32_t edx_19 = &data_10049260[(eax_3 >> 5)];
                    
                    if ((eax_24 == *((edx_19 + ecx_21) + 0x28) && edx_18 == *((edx_19 + ecx_21) + 0x2c)))
                    {
                        HANDLE hFile = &data_10049260[(eax_3 >> 5)][((eax_3 & 0x1f) * 0x10)];
                        int32_t lpNumberOfBytesRead;
                        void lpBuffer;
                        
                        if (ReadFile(hFile, &lpBuffer, 0x1000, &lpNumberOfBytesRead, nullptr) != 0)
                        {
                            uint32_t eax_36;
                            int32_t edx_27;
                            eax_36 = sub_100270d0(hFile, eax_5, edx_2, FILE_BEGIN);
                            
                            if (edx_27 > 0)
                            {
                            label_1001c8d3:
                                
                                if (var_30_1 <= lpNumberOfBytesRead)
                                {
                                    i = &lpBuffer;
                                    
                                    while (true)
                                    {
                                        uint32_t edx_30 = var_30_1;
                                        var_30_1 -= 1;
                                        
                                        if (edx_30 == 0)
                                            break;
                                        
                                        if (i >= ((&__saved_ebp + lpNumberOfBytesRead) - 0x1030))
                                            break;
                                        
                                        if (*i != 0xd)
                                            i += *(*i + 0x10044d10);
                                        else if ((i < ((&__saved_ebp + lpNumberOfBytesRead) - 0x1031) && *(i + 1) == 0xa))
                                            i += 1;
                                        
                                        i += 1;
                                    }
                                }
                            }
                            else if ((edx_27 >= 0 && eax_36 >= 0))
                                goto label_1001c8d3;
                        }
                    }
                }
            }
            else if ((*(var_c_4 + 0xc) & 0x80) != 0)
            {
            label_1001ca04:
                
                if ((eax_5 | edx_2) != 0)
                {
                    if ((*(var_c_4 + 0xc) & 1) == 0)
                        goto label_1001cbc7;
                    
                    if (*(var_c_4 + 4) != 0)
                    {
                        uint32_t var_18_6 = ((*var_c_4 - *(var_c_4 + 8)) + *(var_c_4 + 4));
                        
                        if ((*((&data_10049260[(eax_3 >> 5)] + ((eax_3 & 0x1f) << 6)) + 4) & 0x80) == 0)
                            goto label_1001cba4;
                        
                        enum SET_FILE_POINTER_MOVE_METHOD var_c_8 = FILE_END;
                        var_10_2 = 0;
                        var_14_3 = 0;
                        var_18_6 = eax_3;
                        uint32_t eax_68;
                        int32_t edx_53;
                        eax_68 = sub_100270d0(var_18_6, var_14_3, var_10_2, var_c_8);
                        
                        if ((eax_68 == eax_5 && edx_53 == edx_2))
                        {
                            int32_t edx_56 = (*(var_c_8 + 8) + var_18_6);
                            
                            for (i = *(var_c_8 + 8); i < edx_56; i += 1)
                            {
                                if (*i == 0xa)
                                    var_18_6 += 1;
                            }
                            
                            if ((*(var_c_8 + 0xc) & 0x2000) != 0)
                                var_18_6 += 1;
                            
                            goto label_1001cba4;
                        }
                        
                        enum SET_FILE_POINTER_MOVE_METHOD var_c_9 = FILE_BEGIN;
                        var_10_2 = edx_2;
                        var_14_3 = eax_5;
                        uint32_t eax_77;
                        int32_t edx_63;
                        eax_77 = sub_100270d0(eax_3, var_14_3, var_10_2, var_c_9);
                        
                        if (edx_63 > 0)
                        {
                        label_1001cb60:
                            
                            if (((eax_3 > 0x200 || (*(var_c_9 + 0xc) & 8) == 0) || (*(var_c_9 + 0xc) & 0x400) != 0))
                                var_18_6 = *(var_c_9 + 0x18);
                            else
                                var_18_6 = 0x200;
                            
                            if ((*((&data_10049260[(eax_3 >> 5)] + ((eax_3 & 0x1f) << 6)) + 4) & 4) == 0)
                                goto label_1001cba4;
                            
                            var_18_6 += 1;
                        label_1001cba4:
                            
                            if (*var_10_2[3] == 1)
                                var_18_6 u>>= 1;
                            
                            uint32_t var_2c = (eax_5 - var_18_6);
                            int32_t var_28 = (edx_2 - 0);
                            goto label_1001cbc7;
                        }
                        
                        if ((edx_63 >= 0 && eax_77 >= 0))
                            goto label_1001cb60;
                    }
                    else
                    {
                        var_14_3 = 0;
                    label_1001cbc7:
                        
                        if (*var_10_2[3] == 1)
                            var_14_3 u>>= 1;
                    }
                }
            }
            else
                *sub_1000eca0() = 0x16;
        }
        else
            *(var_c_4 + 4);
    }
    else if ((edx_2 >= 0 && eax_5 >= 0))
        goto label_1001c70d;
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t sub_1001cc00(int32_t* arg1, int32_t arg2, int32_t arg3, enum SET_FILE_POINTER_MOVE_METHOD arg4)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041f38;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_2c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_30 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    
    if ((arg1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3c, nullptr, u"stream != NULL") == 1))
        breakpoint();
    
    sub_10019550(arg1);
    int32_t var_8_1 = 0;
    int32_t result = sub_1001ccc0(arg1, arg2, arg3, arg4);
    int32_t var_8_2 = 0xfffffffe;
    sub_1001cc92(&__saved_ebp);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1001cc92(void* arg1 @ ebp)
{
    return sub_100195f0(*(arg1 + 8));
}

int32_t sub_1001ccc0(int32_t* arg1, int32_t arg2, int32_t arg3, enum SET_FILE_POINTER_MOVE_METHOD arg4)
{
    if ((arg1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x65, nullptr, u"str != NULL") == 1))
        breakpoint();
    
    if (((arg1[3] & 0x83) == 0 || ((arg4 != FILE_BEGIN && arg4 != FILE_CURRENT) && arg4 != FILE_END)))
    {
        *sub_1000eca0() = 0x16;
        return 0xffffffff;
    }
    
    arg1[3] &= 0xffffffef;
    
    if (arg4 == FILE_CURRENT)
    {
        int32_t eax_7;
        int32_t edx_3;
        eax_7 = sub_1001c660(arg1);
        int32_t ecx_4 = (arg3 + edx_3);
        arg2 += eax_7;
        arg3 = ecx_4;
        arg4 = FILE_BEGIN;
    }
    
    sub_1000d670(arg1);
    
    if ((arg1[3] & 0x80) != 0)
        arg1[3] &= 0xfffffffc;
    else if (((arg1[3] & 1) != 0 && ((arg1[3] & 8) != 0 && (arg1[3] & 0x400) == 0)))
        arg1[6] = 0x200;
    
    uint32_t eax_18;
    int32_t edx_11;
    eax_18 = sub_100270d0(sub_10019e20(arg1), arg2, arg3, arg4);
    
    if ((eax_18 & edx_11) != 0xffffffff)
        return 0;
    
    return 0xffffffff;
}

int32_t __initp_misc_purevirt(int32_t arg1)
{
    data_10045b54 = arg1;
    return arg1;
}

int32_t sub_1001ce10(int32_t arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t eax_1 = sub_10018b70(data_10045b54);
    
    if ((eax_1 != 0 && eax_1(arg1, eax_1) != 0))
        return 1;
    
    return 0;
}

int32_t sub_1001ce50()
{
    if (data_1004a394 == 0)
        ___initmbctable();
    
    int32_t var_c = 0;
    char* var_8 = data_10045608;
    
    if (var_8 == 0)
        return 0xffffffff;
    
    while (*var_8 != 0)
    {
        if (*var_8 != 0x3d)
            var_c += 1;
        
        var_8 = ((var_8 + _strlen(var_8)) + 1);
    }
    
    void* var_10_1 = sub_10010b10((var_c + 1), 4, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x75);
    data_10045ae4 = var_10_1;
    
    if (data_10045ae4 == 0)
        return 0xffffffff;
    
    char* var_8_1 = data_10045608;
    
    while (*var_8_1 != 0)
    {
        void* eax_12 = (_strlen(var_8_1) + 1);
        
        if (*var_8_1 != 0x3d)
        {
            *var_10_1 = sub_10010b10(eax_12, 1, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x7e);
            
            if (*var_10_1 == 0)
            {
                sub_10011340(data_10045ae4, 2);
                data_10045ae4 = 0;
                return 0xffffffff;
            }
            
            sub_1000b4b0(sub_10010280(*var_10_1, eax_12, var_8_1), u"strcpy_s(*env, cchars, p)", u"_setenvp", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x85, 0);
            var_10_1 += 4;
        }
        
        var_8_1 += eax_12;
    }
    
    sub_10011340(data_10045608, 2);
    data_10045608 = 0;
    *var_10_1 = 0;
    data_1004a388 = 1;
    return 0;
}

int32_t sub_1001cff0()
{
    int32_t var_8 = 0;
    
    if (data_1004a394 == 0)
        ___initmbctable();
    
    data_10045c5c = 0;
    GetModuleFileNameA(nullptr, &data_10045b58, 0x104);
    __set_pgmptr(0x10045b58);
    char* var_18;
    
    if ((data_1004a3ac == 0 || **&data_1004a3ac == 0))
        var_18 = &data_10045b58;
    else
        var_18 = data_1004a3ac;
    
    int32_t var_14;
    int32_t var_c;
    sub_1001d120(var_18, nullptr, nullptr, &var_c, &var_14);
    
    if ((var_c >= 0x3fffffff || var_14 >= 0xffffffff))
        return 0xffffffff;
    
    if ((var_14 + (var_c << 2)) < var_14)
        return 0xffffffff;
    
    int32_t* eax_7 = __malloc_dbg((var_14 + (var_c << 2)), 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x8e);
    
    if (eax_7 == 0)
        return 0xffffffff;
    
    sub_1001d120(var_18, eax_7, &eax_7[var_c], &var_c, &var_14);
    data_10045ad8 = (var_c - 1);
    data_10045adc = eax_7;
    return 0;
}

int32_t __set_pgmptr(int32_t arg1)
{
    data_10045af4 = arg1;
    return arg1;
}

int32_t* sub_1001d120(char* arg1, int32_t* arg2, char* arg3, int32_t* arg4, int32_t* arg5)
{
    *arg5 = 0;
    *arg4 = 1;
    char* var_8 = arg1;
    
    if (arg2 != 0)
    {
        *arg2 = arg3;
        arg2 = &arg2[1];
    }
    
    int32_t var_c = 0;
    char var_11_1;
    
    while (true)
    {
        if (*var_8 != 0x22)
        {
            *arg5 += 1;
            int32_t* edx_6;
            
            if (arg3 != 0)
            {
                edx_6 = *var_8;
                *arg3 = edx_6;
                arg3 = &arg3[1];
            }
            
            edx_6 = *var_8;
            var_11_1 = edx_6;
            var_8 = &var_8[1];
            
            if (sub_1002aed0(var_11_1) != 0)
            {
                *arg5 += 1;
                
                if (arg3 != 0)
                {
                    int32_t* ecx_8;
                    ecx_8 = *var_8;
                    *arg3 = ecx_8;
                    arg3 = &arg3[1];
                }
                
                var_8 = &var_8[1];
            }
        }
        else
        {
            int32_t edx_3;
            edx_3 = var_c == 0;
            var_c = edx_3;
            int32_t ecx_2;
            ecx_2 = *var_8;
            var_11_1 = ecx_2;
            var_8 = &var_8[1];
        }
        
        if (var_11_1 == 0)
            break;
        
        if (var_c == 0)
        {
            if (var_11_1 == 0x20)
                break;
            
            if (var_11_1 == 9)
                break;
        }
    }
    
    if (var_11_1 == 0)
        var_8 -= 1;
    else if (arg3 != 0)
        arg3[0xffffffff] = 0;
    
    int32_t var_c_1 = 0;
    
    while (true)
    {
        if (*var_8 != 0)
        {
            while ((*var_8 == 0x20 || *var_8 == 9))
                var_8 = &var_8[1];
        }
        
        if (*var_8 == 0)
            break;
        
        if (arg2 != 0)
        {
            *arg2 = arg3;
            arg2 = &arg2[1];
        }
        
        *arg4 += 1;
        
        while (true)
        {
            int32_t var_10_1 = 1;
            uint32_t var_18_1 = 0;
            
            while (*var_8 == 0x5c)
            {
                var_8 = &var_8[1];
                var_18_1 += 1;
            }
            
            if (*var_8 == 0x22)
            {
                if ((COMBINE(0, var_18_1) % 2) == 0)
                {
                    if ((var_c_1 == 0 || var_8[1] != 0x22))
                    {
                        var_10_1 = 0;
                        int32_t edx_25;
                        edx_25 = var_c_1 == 0;
                        var_c_1 = edx_25;
                    }
                    else
                        var_8 = &var_8[1];
                }
                
                var_18_1 u>>= 1;
            }
            
            while (true)
            {
                uint32_t ecx_22 = var_18_1;
                var_18_1 -= 1;
                
                if (ecx_22 == 0)
                    break;
                
                if (arg3 != 0)
                {
                    *arg3 = 0x5c;
                    arg3 = &arg3[1];
                }
                
                *arg5 += 1;
            }
            
            if (*var_8 == 0)
                break;
            
            if (var_c_1 == 0)
            {
                if (*var_8 == 0x20)
                    break;
                
                if (*var_8 == 9)
                    break;
            }
            
            if (var_10_1 != 0)
            {
                if (arg3 == 0)
                {
                    if (sub_1002aed0(*var_8) != 0)
                    {
                        var_8 = &var_8[1];
                        *arg5 += 1;
                    }
                }
                else
                {
                    int32_t eax_38;
                    int32_t* edx_32;
                    eax_38 = sub_1002aed0(*var_8);
                    
                    if (eax_38 != 0)
                    {
                        eax_38 = *var_8;
                        *arg3 = eax_38;
                        arg3 = &arg3[1];
                        var_8 = &var_8[1];
                        *arg5 += 1;
                    }
                    
                    edx_32 = *var_8;
                    *arg3 = edx_32;
                    arg3 = &arg3[1];
                }
                
                *arg5 += 1;
            }
            
            var_8 = &var_8[1];
        }
        
        if (arg3 != 0)
        {
            *arg3 = 0;
            arg3 = &arg3[1];
        }
        
        *arg5 += 1;
    }
    
    if (arg2 != 0)
    {
        *arg2 = 0;
        arg2 = &arg2[1];
    }
    
    *arg4 += 1;
    return arg4;
}

void* sub_1001d480()
{
    PWSTR var_c = nullptr;
    int128_t* penv = nullptr;
    
    if (data_10045c60 == 0)
    {
        var_c = GetEnvironmentStringsW();
        
        if (var_c == 0)
        {
            if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                data_10045c60 = 2;
        }
        else
            data_10045c60 = 1;
    }
    
    if (data_10045c60 != 1)
    {
        if ((data_10045c60 != 2 && data_10045c60 != 0))
            return nullptr;
        
        penv = GetEnvironmentStrings();
        
        if (penv == 0)
            return nullptr;
        
        int128_t* penv_1 = penv;
        
        while (*penv_1 != 0)
        {
            penv_1 += 1;
            
            if (*penv_1 == 0)
                penv_1 += 1;
        }
        
        void* eax_21 = __malloc_dbg(((penv_1 - penv) + 1), 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x8c);
        
        if (eax_21 == 0)
        {
            FreeEnvironmentStringsA(penv);
            return nullptr;
        }
        
        sub_10013c90(eax_21, penv, ((penv_1 - penv) + 1), penv);
        FreeEnvironmentStringsA(penv);
        return eax_21;
    }
    
    if (var_c == 0)
    {
        var_c = GetEnvironmentStringsW();
        
        if (var_c == 0)
            return nullptr;
    }
    
    PWSTR var_10_1 = var_c;
    
    while (*var_10_1 != 0)
    {
        var_10_1 = &var_10_1[1];
        
        if (*var_10_1 == 0)
            var_10_1 = &var_10_1[1];
    }
    
    int32_t cbMultiByte = WideCharToMultiByte(0, 0, var_c, (((var_10_1 - var_c) >> 1) + 1), nullptr, 0, nullptr, nullptr);
    
    if (cbMultiByte != 0)
    {
        void* lpMultiByteStr = __malloc_dbg(cbMultiByte, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x61);
        
        if (lpMultiByteStr != 0)
        {
            if (WideCharToMultiByte(0, 0, var_c, (((var_10_1 - var_c) >> 1) + 1), lpMultiByteStr, cbMultiByte, nullptr, nullptr) == 0)
            {
                sub_10011340(lpMultiByteStr, 2);
                lpMultiByteStr = nullptr;
            }
            
            FreeEnvironmentStringsW(var_c);
            return lpMultiByteStr;
        }
    }
    
    FreeEnvironmentStringsW(var_c);
    return nullptr;
}

void sub_1001d6a0()
{
    return;
}

void sub_1001d6d0()
{
    return;
}

int32_t sub_1001d700() __pure
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t var_8_1 = 0;
    return 1;
}

int32_t sub_1001d720(int32_t arg1)
{
    enum HEAP_FLAGS flOptions;
    flOptions = arg1 == 0;
    data_10045c64 = HeapCreate(flOptions, 0x1000, 0);
    
    if (data_10045c64 == 0)
        return 0;
    
    data_10049254 = 1;
    
    if ((data_10049254 == 3 && sub_10020000(0x3f8) == 0))
    {
        HeapDestroy(data_10045c64);
        data_10045c64 = 0;
        return 0;
    }
    
    return 1;
}

BOOL sub_1001d7a0()
{
    if (data_10049254 == 3)
    {
        void* var_c_1 = data_1004923c;
        
        for (int32_t i = 0; i < data_10049238; i += 1)
        {
            VirtualFree(*(var_c_1 + 0xc), 0, MEM_RELEASE);
            HeapFree(data_10045c64, HEAP_NONE, *(var_c_1 + 0x10));
            var_c_1 += 0x14;
        }
        
        HeapFree(data_10045c64, HEAP_NONE, data_1004923c);
    }
    
    BOOL result = HeapDestroy(data_10045c64);
    data_10045c64 = 0;
    return result;
}

uint32_t sub_1001d840()
{
    int32_t lpSystemTimeAsFileTime = 0;
    int32_t var_8 = 0;
    uint32_t result;
    
    if (__security_cookie != 0xbb40e64e)
        result = (__security_cookie & 0xffff0000);
    
    if ((__security_cookie == 0xbb40e64e || result == 0))
    {
        GetSystemTimeAsFileTime(&lpSystemTimeAsFileTime);
        int32_t eax_4 = (GetCurrentProcessId() ^ (lpSystemTimeAsFileTime ^ var_8));
        int32_t eax_6 = (GetCurrentThreadId() ^ eax_4);
        int32_t eax_8 = (GetTickCount() ^ eax_6);
        int32_t lpPerformanceCount;
        QueryPerformanceCounter(&lpPerformanceCount);
        result = (eax_8 ^ lpPerformanceCount);
        int32_t var_18;
        uint32_t result_1 = (result ^ var_18);
        
        if (result_1 == 0xbb40e64e)
            result_1 = 0xbb40e64f;
        else if ((result_1 & 0xffff0000) == 0)
        {
            result = ((result_1 << 0x10) | result_1);
            result_1 = result;
        }
        
        __security_cookie = result_1;
        data_100441ac = !(result_1);
    }
    else
        data_100441ac = !(__security_cookie);
    
    return result;
}

int32_t ___CppXcptFilter(int32_t arg1, int32_t arg2)
{
    if (arg1 != 0xe06d7363)
        return 0;
    
    return sub_1001d950(arg1, arg2);
}

int32_t sub_1001d950(int32_t arg1, int32_t arg2)
{
    void* eax = sub_10019040();
    
    if (eax == 0)
        return 0;
    
    int32_t* eax_3 = _xcptlookup(arg1, *(eax + 0x5c));
    int32_t var_18_1;
    
    if (eax_3 != 0)
        var_18_1 = eax_3[2];
    else
        var_18_1 = 0;
    
    if (var_18_1 == 0)
        return 0;
    
    if (var_18_1 == 5)
    {
        eax_3[2] = 0;
        return 1;
    }
    
    if (var_18_1 == 1)
        return 0xffffffff;
    
    int32_t ecx_3 = *(eax + 0x60);
    *(eax + 0x60) = arg2;
    
    if (eax_3[1] != 8)
    {
        eax_3[2] = 0;
        var_18_1(eax_3[1]);
    }
    else
    {
        int32_t i;
        
        for (i = data_100445f4; i < (data_100445f4 + data_100445f8); i += 1)
            *((*(eax + 0x5c) + (i * 0xc)) + 8) = 0;
        
        int32_t eax_10 = *(eax + 0x64);
        
        if (*eax_3 == 0xc000008e)
            *(eax + 0x64) = 0x83;
        else if (*eax_3 == 0xc0000090)
            *(eax + 0x64) = 0x81;
        else if (*eax_3 == 0xc0000091)
            *(eax + 0x64) = 0x84;
        else if (*eax_3 == 0xc0000093)
            *(eax + 0x64) = 0x85;
        else if (*eax_3 == 0xc000008d)
            *(eax + 0x64) = 0x82;
        else if (*eax_3 == 0xc000008f)
            *(eax + 0x64) = 0x86;
        else if (*eax_3 == 0xc0000092)
            *(eax + 0x64) = 0x8a;
        
        var_18_1(8, *(eax + 0x64), eax_10, var_18_1, i, ecx_3, eax, eax_3);
        *(eax + 0x64) = eax_10;
    }
    
    *(eax + 0x60) = ecx_3;
    return 0xffffffff;
}

int32_t* _xcptlookup(int32_t arg1, int32_t* arg2)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t* result = arg2;
    
    while (*result != arg1)
    {
        result = &result[3];
        
        if (result >= ((data_10044600 * 0xc) + arg2))
            break;
    }
    
    if ((result < ((data_10044600 * 0xc) + arg2) && *result == arg1))
        return result;
    
    return nullptr;
}

int32_t* _get_short_arg(int32_t* arg1)
{
    *arg1 += 4;
    int32_t* result;
    result = *(*arg1 - 4);
    return result;
}

int32_t sub_1001dba0(int32_t arg1, int32_t arg2, int32_t arg3)
{
    int32_t var_20 = 0;
    int32_t eax = __Getmonths();
    int32_t var_1c = 0;
    int32_t var_28 = 0;
    int32_t var_18 = 0;
    
    if (data_10045c68 == 0)
    {
        HMODULE hModule = LoadLibraryA("USER32.DLL");
        
        if (hModule == 0)
            return 0;
        
        int32_t eax_3 = GetProcAddress(hModule, "MessageBoxA");
        
        if (eax_3 == 0)
            return 0;
        
        data_10045c68 = sub_10018a80(eax_3);
        data_10045c6c = sub_10018a80(GetProcAddress(hModule, "GetActiveWindow"));
        data_10045c70 = sub_10018a80(GetProcAddress(hModule, "GetLastActivePopup"));
        data_10045c78 = sub_10018a80(GetProcAddress(hModule, "GetUserObjectInformationA"));
        
        if (data_10045c78 != 0)
            data_10045c74 = sub_10018a80(GetProcAddress(hModule, "GetProcessWindowStation"));
    }
    
    if ((data_10045c74 != eax && data_10045c78 != eax))
    {
        int32_t eax_16 = sub_10018b70(data_10045c74);
        int32_t eax_17 = sub_10018b70(data_10045c78);
        
        if ((eax_16 != 0 && eax_17 != 0))
        {
            int32_t eax_18 = eax_16();
            int32_t eax_19;
            void var_24;
            void var_14;
            
            if (eax_18 != 0)
                eax_19 = eax_17(eax_18, 1, &var_14, 0xc, &var_24);
            int32_t var_c;
            
            if (((eax_18 == 0 || eax_19 == 0) || (var_c & 1) == 0))
                var_28 = 1;
        }
    }
    
    if (var_28 == 0)
    {
        if (data_10045c6c != eax)
        {
            int32_t eax_22 = sub_10018b70(data_10045c6c);
            
            if (eax_22 != 0)
                var_1c = eax_22();
        }
        
        if ((var_1c != 0 && data_10045c70 != eax))
        {
            int32_t eax_25 = sub_10018b70(data_10045c70);
            
            if (eax_25 != 0)
                var_1c = eax_25(var_1c);
        }
    }
    else
        arg3 |= 0x200000;
    
    int32_t eax_28 = sub_10018b70(data_10045c68);
    
    if (eax_28 == 0)
        return 0;
    
    return eax_28(var_1c, arg1, arg2, arg3);
}

int32_t sub_1001ddc0(char** arg1, char* arg2, void** arg3)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    int32_t var_264 = 0;
    int32_t var_14 = 0;
    int32_t var_1c = 0;
    int32_t var_34 = 0;
    int32_t* var_20 = nullptr;
    int32_t var_2c = 0;
    int32_t var_10 = 0;
    void var_44;
    _LocaleUpdate::_LocaleUpdate(&var_44, arg3);
    int32_t var_24 = 0;
    int32_t ecx_1;
    ecx_1 = arg1 != 0;
    
    if ((ecx_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x402, nullptr, u"(stream != NULL)") == 1))
        breakpoint();
    
    if (ecx_1 != 0)
    {
        int32_t var_310_1;
        
        if ((arg1[3] & 0x40) != 0)
            var_310_1 = 1;
        else
        {
            int32_t eax_8;
            int32_t ecx_4;
            eax_8 = sub_10019e20(arg1);
            int32_t var_308_1;
            
            if ((eax_8 == 0xffffffff || eax_8 == 0xfffffffe))
                var_308_1 = 0x100445b0;
            else
                var_308_1 = (((eax_8 & 0x1f) << 6) + &data_10049260[(eax_8 >> 5)]);
            
            ecx_4 = *(var_308_1 + 0x24);
            ecx_4 <<= 1;
            ecx_4 s>>= 1;
            int32_t eax_9;
            
            if (ecx_4 == 0)
            {
                void* var_30c_1;
                
                if ((eax_8 == 0xffffffff || eax_8 == 0xfffffffe))
                    var_30c_1 = &data_100445b0;
                else
                    var_30c_1 = (((eax_8 & 0x1f) << 6) + &data_10049260[(eax_8 >> 5)]);
                
                eax_9 = *(var_30c_1 + 0x24);
                eax_9 = eax_9;
                eax_9 s>>= 7;
            }
            
            if ((ecx_4 == 0 && eax_9 == 0))
                var_310_1 = 1;
            else
                var_310_1 = 0;
        }
        
        if ((var_310_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x404, nullptr, u"( (_Stream->_flag & _IOSTRG) || …") == 1))
            breakpoint();
        
        if (var_310_1 != 0)
        {
            int32_t ecx_12;
            ecx_12 = arg2 != 0;
            int32_t var_278_1 = ecx_12;
            
            if (var_278_1 == 0)
            {
                int32_t eax_14;
                eax_14 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x407, nullptr, u"(format != NULL)");
                
                if (eax_14 == 1)
                    breakpoint();
            }
            
            if (var_278_1 != 0)
            {
                int32_t var_250 = 0;
                int32_t var_28 = 0;
                int32_t var_260_1 = 0;
                char* var_24_1 = nullptr;
                int32_t var_48_1 = 0;
                
                while (true)
                {
                    ecx_12 = *arg2;
                    char var_255_1 = ecx_12;
                    arg2 = &arg2[1];
                    
                    if ((var_255_1 != 0 && var_250 >= 0))
                    {
                        int32_t var_314_1;
                        
                        if ((var_255_1 < 0x20 || var_255_1 > 0x78))
                            var_314_1 = 0;
                        else
                            var_314_1 = (*"A"[var_255_1] & 0xf);
                        
                        var_260_1 = (*(((var_314_1 * 9) + var_260_1) + 0x1003b3b8) >> 4);
                        
                        if (var_260_1 == 8)
                        {
                            int32_t var_318_1 = 0;
                            
                            if (var_318_1 == 0)
                            {
                                int32_t eax_23;
                                eax_23 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x460, nullptr, u"("Incorrect format specifier", 0…");
                                
                                if (eax_23 == 1)
                                    breakpoint();
                            }
                            
                            if (var_318_1 == 0)
                            {
                                *sub_1000eca0() = 0x16;
                                sub_1000c310(u"("Incorrect format specifier", 0…", &lookup_table_1003b3b8[0x5c], u"f:\dd\vctools\crt_bld\self_x86\c…", 0x460, 0);
                                _LocaleUpdate::~_LocaleUpdate(&var_44);
                                break;
                            }
                        }
                        
                        int32_t var_30;
                        
                        if (var_260_1 > 7)
                            continue;
                        else
                            switch (var_260_1)
                            {
                                case 0:
                                {
                                label_1001e233:
                                    var_10 = 0;
                                    
                                    if (sub_10027510(var_255_1, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44)) != 0)
                                    {
                                        sub_1001f1e0(var_255_1, arg1, &var_250);
                                        var_255_1 = *arg2;
                                        arg2 = &arg2[1];
                                        int32_t eax_30 = var_255_1;
                                        int32_t eax_31 = -(eax_30);
                                        int32_t eax_33 = -((eax_31 - eax_31));
                                        
                                        if ((eax_33 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x486, nullptr, u"(ch != _T('\0'))") == 1))
                                            breakpoint();
                                        
                                        if (eax_33 == 0)
                                        {
                                            *sub_1000eca0() = 0x16;
                                            sub_1000c310(u"(ch != _T('\0'))", &lookup_table_1003b3b8[0x5c], u"f:\dd\vctools\crt_bld\self_x86\c…", 0x486, 0);
                                            _LocaleUpdate::~_LocaleUpdate(&var_44);
                                            break;
                                        }
                                    }
                                    
                                    sub_1001f1e0(var_255_1, arg1, &var_250);
                                    continue;
                                }
                                case 1:
                                {
                                    var_30 = 0;
                                    var_2c = 0;
                                    var_1c = 0;
                                    var_20 = nullptr;
                                    var_14 = 0;
                                    var_34 = 0xffffffff;
                                    var_10 = 0;
                                    continue;
                                }
                                case 2:
                                {
                                    if ((var_255_1 - 0x20) > 0x10)
                                        continue;
                                    else
                                        switch (var_255_1)
                                        {
                                            case 0x20:
                                            {
                                                var_14 |= 2;
                                                continue;
                                            }
                                            case 0x21:
                                            case 0x22:
                                            case 0x24:
                                            case 0x25:
                                            case 0x26:
                                            case 0x27:
                                            case 0x28:
                                            case 0x29:
                                            case 0x2a:
                                            case 0x2c:
                                            case 0x2e:
                                            case 0x2f:
                                            {
                                                continue;
                                            }
                                            case 0x23:
                                            {
                                                var_14 |= 0x80;
                                                continue;
                                            }
                                            case 0x2b:
                                            {
                                                var_14 |= 1;
                                                continue;
                                            }
                                            case 0x2d:
                                            {
                                                var_14 |= 4;
                                                continue;
                                            }
                                            case 0x30:
                                            {
                                                var_14 |= 8;
                                                continue;
                                            }
                                        }
                                    break;
                                }
                                case 3:
                                {
                                    if (var_255_1 != 0x2a)
                                    {
                                        var_1c = (((var_1c * 0xa) + var_255_1) - 0x30);
                                        continue;
                                    }
                                    else
                                    {
                                        int32_t eax_44;
                                        eax_44 = _get_int_arg(&arg_10);
                                        var_1c = eax_44;
                                        
                                        if (var_1c >= 0)
                                            continue;
                                        else
                                        {
                                            var_14 |= 4;
                                            var_1c = -(var_1c);
                                            continue;
                                        }
                                    }
                                    break;
                                }
                                case 4:
                                {
                                    var_34 = 0;
                                    continue;
                                }
                                case 5:
                                {
                                    if (var_255_1 != 0x2a)
                                    {
                                        var_34 = (((var_34 * 0xa) + var_255_1) - 0x30);
                                        continue;
                                    }
                                    else
                                    {
                                        int32_t eax_48;
                                        eax_48 = _get_int_arg(&arg_10);
                                        var_34 = eax_48;
                                        
                                        if (var_34 >= 0)
                                            continue;
                                        else
                                        {
                                            var_34 = 0xffffffff;
                                            continue;
                                        }
                                    }
                                    break;
                                }
                                case 6:
                                {
                                    if ((var_255_1 - 0x49) > 0x2e)
                                        continue;
                                    else
                                        switch (var_255_1)
                                        {
                                            case 0x49:
                                            {
                                                if ((*arg2 == 0x36 && *(arg2 + 1) == 0x34))
                                                {
                                                    arg2 = &arg2[2];
                                                    var_14 |= 0x8000;
                                                    continue;
                                                }
                                                
                                                if ((*arg2 == 0x33 && *(arg2 + 1) == 0x32))
                                                {
                                                    arg2 = &arg2[2];
                                                    var_14 &= 0xffff7fff;
                                                    continue;
                                                }
                                                
                                                if (*arg2 == 0x64)
                                                    continue;
                                                else if (*arg2 == 0x69)
                                                    continue;
                                                else if (*arg2 == 0x6f)
                                                    continue;
                                                else if (*arg2 == 0x75)
                                                    continue;
                                                else if (*arg2 == 0x78)
                                                    continue;
                                                else if (*arg2 != 0x58)
                                                    var_260_1 = 0;
                                                else
                                                    continue;
                                                break;
                                            }
                                            case 0x4a:
                                            case 0x4b:
                                            case 0x4c:
                                            case 0x4d:
                                            case 0x4e:
                                            case 0x4f:
                                            case 0x50:
                                            case 0x51:
                                            case 0x52:
                                            case 0x53:
                                            case 0x54:
                                            case 0x55:
                                            case 0x56:
                                            case 0x57:
                                            case 0x58:
                                            case 0x59:
                                            case 0x5a:
                                            case 0x5b:
                                            case 0x5c:
                                            case 0x5d:
                                            case 0x5e:
                                            case 0x5f:
                                            case 0x60:
                                            case 0x61:
                                            case 0x62:
                                            case 0x63:
                                            case 0x64:
                                            case 0x65:
                                            case 0x66:
                                            case 0x67:
                                            case 0x69:
                                            case 0x6a:
                                            case 0x6b:
                                            case 0x6d:
                                            case 0x6e:
                                            case 0x6f:
                                            case 0x70:
                                            case 0x71:
                                            case 0x72:
                                            case 0x73:
                                            case 0x74:
                                            case 0x75:
                                            case 0x76:
                                            {
                                                continue;
                                            }
                                            case 0x68:
                                            {
                                                var_14 |= 0x20;
                                                continue;
                                            }
                                            case 0x6c:
                                            {
                                                if (*arg2 != 0x6c)
                                                {
                                                    var_14 |= 0x10;
                                                    continue;
                                                }
                                                else
                                                {
                                                    arg2 = &arg2[1];
                                                    var_14 |= 0x1000;
                                                    continue;
                                                }
                                                break;
                                            }
                                            case 0x77:
                                            {
                                                var_14 |= 0x800;
                                                continue;
                                            }
                                        }
                                    
                                    goto label_1001e233;
                                }
                                case 7:
                                {
                                    char var_18;
                                    char* var_8;
                                    char var_24c;
                                    int32_t var_c_1;
                                    
                                    if ((var_255_1 - 0x41) <= 0x37)
                                        switch (var_255_1)
                                        {
                                            case 0x41:
                                            case 0x45:
                                            case 0x47:
                                            {
                                                var_30 = 1;
                                                var_255_1 += 0x20;
                                            label_1001e95b:
                                                var_14 |= 0x40;
                                                var_8 = &var_24c;
                                                int32_t var_48_2 = 0x200;
                                                
                                                if (var_34 < 0)
                                                    var_34 = 6;
                                                else if ((var_34 == 0 && var_255_1 == 0x67))
                                                    var_34 = 1;
                                                else if (var_34 > 0x200)
                                                    var_34 = 0x200;
                                                
                                                if (var_34 > 0xa3)
                                                {
                                                    var_24_1 = __malloc_dbg((var_34 + 0x15d), 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x6da);
                                                    
                                                    if (var_24_1 == 0)
                                                        var_34 = 0xa3;
                                                    else
                                                    {
                                                        var_8 = var_24_1;
                                                        var_48_2 = (var_34 + 0x15d);
                                                    }
                                                }
                                                
                                                arg_10 += 8;
                                                void* eax_106 = arg_10;
                                                int32_t edx_71 = *(eax_106 - 4);
                                                int32_t var_2ac = *(eax_106 - 8);
                                                int32_t var_2a8_1 = edx_71;
                                                sub_10018b70(data_10044cf8)(&var_2ac, var_8, var_48_2, var_255_1, var_34, var_30, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44));
                                                
                                                if (((var_14 & 0x80) != 0 && var_34 == 0))
                                                    sub_10018b70(data_10044d04)(var_8, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44));
                                                
                                                if ((var_255_1 == 0x67 && (var_14 & 0x80) == 0))
                                                    sub_10018b70(data_10044d00)(var_8, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_44));
                                                
                                                if (*var_8 == 0x2d)
                                                {
                                                    var_14 |= 0x100;
                                                    var_8 = &var_8[1];
                                                }
                                                
                                                void* eax_120;
                                                eax_120 = _strlen(var_8);
                                                var_28 = eax_120;
                                                break;
                                            }
                                            case 0x43:
                                            {
                                                if ((var_14 & 0x830) == 0)
                                                    var_14 |= 0x800;
                                                
                                                goto label_1001e60a;
                                            }
                                            case 0x53:
                                            {
                                                if ((var_14 & 0x830) == 0)
                                                    var_14 |= 0x800;
                                                
                                                goto label_1001e745;
                                            }
                                            case 0x58:
                                            {
                                                goto label_1001eb0b;
                                            }
                                            case 0x5a:
                                            {
                                                int32_t eax_74 = _get_int_arg(&arg_10);
                                                
                                                if ((eax_74 == 0 || *(eax_74 + 4) == 0))
                                                {
                                                    var_8 = data_10044604;
                                                    void* eax_76;
                                                    eax_76 = _strlen(var_8);
                                                    var_28 = eax_76;
                                                }
                                                else if ((var_14 & 0x800) == 0)
                                                {
                                                    var_10 = 0;
                                                    var_8 = *(eax_74 + 4);
                                                    var_28 = *eax_74;
                                                }
                                                else
                                                {
                                                    var_8 = *(eax_74 + 4);
                                                    int32_t eax_79;
                                                    int32_t edx_49;
                                                    edx_49 = HIGHD(*eax_74);
                                                    eax_79 = LOWD(*eax_74);
                                                    var_28 = ((eax_79 - edx_49) >> 1);
                                                    var_10 = 1;
                                                }
                                                break;
                                            }
                                            case 0x61:
                                            case 0x65:
                                            case 0x66:
                                            case 0x67:
                                            {
                                                goto label_1001e95b;
                                            }
                                            case 0x63:
                                            {
                                            label_1001e60a:
                                                
                                                if ((var_14 & 0x810) == 0)
                                                {
                                                    char eax_73;
                                                    eax_73 = _get_int_arg(&arg_10);
                                                    ecx_12 = eax_73;
                                                    var_24c = ecx_12;
                                                    var_28 = 1;
                                                }
                                                else
                                                {
                                                    int32_t var_284_1 = 0;
                                                    int32_t eax_72;
                                                    eax_72 = _wctomb_s(&var_28, &var_24c, 0x200, _get_short_arg(&arg_10));
                                                    
                                                    if (eax_72 != 0)
                                                        var_2c = 1;
                                                }
                                                
                                                var_8 = &var_24c;
                                                break;
                                            }
                                            case 0x64:
                                            case 0x69:
                                            {
                                                var_14 |= 0x40;
                                                var_c_1 = 0xa;
                                            label_1001eb72:
                                                int32_t var_2bc_1;
                                                int32_t var_2b8_1;
                                                
                                                if ((var_14 & 0x8000) != 0)
                                                {
                                                    int32_t eax_125;
                                                    int32_t edx_83;
                                                    eax_125 = _get_int64_arg(&arg_10);
                                                    var_2bc_1 = eax_125;
                                                    var_2b8_1 = edx_83;
                                                }
                                                else if ((var_14 & 0x1000) != 0)
                                                {
                                                    int32_t eax_126;
                                                    int32_t edx_86;
                                                    eax_126 = _get_int64_arg(&arg_10);
                                                    var_2bc_1 = eax_126;
                                                    var_2b8_1 = edx_86;
                                                }
                                                else if ((var_14 & 0x20) == 0)
                                                {
                                                    if ((var_14 & 0x40) == 0)
                                                    {
                                                        var_2bc_1 = _get_int_arg(&arg_10);
                                                        var_2b8_1 = 0;
                                                    }
                                                    else
                                                    {
                                                        int32_t eax_134;
                                                        int32_t edx_93;
                                                        edx_93 = HIGHD(_get_int_arg(&arg_10));
                                                        eax_134 = LOWD(_get_int_arg(&arg_10));
                                                        var_2bc_1 = eax_134;
                                                        var_2b8_1 = edx_93;
                                                    }
                                                }
                                                else if ((var_14 & 0x40) == 0)
                                                {
                                                    int32_t eax_132;
                                                    int32_t edx_90;
                                                    edx_90 = HIGHD(_get_int_arg(&arg_10));
                                                    eax_132 = LOWD(_get_int_arg(&arg_10));
                                                    var_2bc_1 = eax_132;
                                                    var_2b8_1 = edx_90;
                                                }
                                                else
                                                {
                                                    int32_t eax_129;
                                                    int32_t edx_89;
                                                    edx_89 = HIGHD(_get_int_arg(&arg_10));
                                                    eax_129 = LOWD(_get_int_arg(&arg_10));
                                                    var_2bc_1 = eax_129;
                                                    var_2b8_1 = edx_89;
                                                }
                                                
                                                int32_t var_2c4_1;
                                                int32_t var_2c0_1;
                                                
                                                if ((((var_14 & 0x40) == 0 || var_2b8_1 > 0) || (var_2b8_1 >= 0 && var_2bc_1 >= 0)))
                                                {
                                                    var_2c4_1 = var_2bc_1;
                                                    var_2c0_1 = var_2b8_1;
                                                }
                                                else
                                                {
                                                    var_2c4_1 = -(var_2bc_1);
                                                    var_2c0_1 = -((var_2b8_1 + 0));
                                                    var_14 |= 0x100;
                                                }
                                                
                                                if (((var_14 & 0x8000) == 0 && (var_14 & 0x1000) == 0))
                                                    var_2c0_1 = 0;
                                                
                                                if (var_34 >= 0)
                                                {
                                                    var_14 &= 0xfffffff7;
                                                    
                                                    if (var_34 > 0x200)
                                                        var_34 = 0x200;
                                                }
                                                else
                                                    var_34 = 1;
                                                
                                                if ((var_2c4_1 | var_2c0_1) == 0)
                                                    var_20 = nullptr;
                                                
                                                void var_4d;
                                                void* var_8_1 = &var_4d;
                                                
                                                while (true)
                                                {
                                                    int32_t ecx_71 = var_34;
                                                    var_34 -= 1;
                                                    
                                                    if ((ecx_71 <= 0 && (var_2c4_1 | var_2c0_1) == 0))
                                                        break;
                                                    
                                                    int32_t eax_145;
                                                    uint32_t edx_103;
                                                    edx_103 = HIGHD(var_c_1);
                                                    eax_145 = LOWD(var_c_1);
                                                    int32_t var_2b0_1 = (__aullrem(var_2c4_1, var_2c0_1, eax_145, edx_103) + 0x30);
                                                    int32_t eax_149;
                                                    uint32_t edx_105;
                                                    edx_105 = HIGHD(var_c_1);
                                                    eax_149 = LOWD(var_c_1);
                                                    uint32_t eax_151;
                                                    int32_t edx_106;
                                                    eax_151 = __aulldiv(var_2c4_1, var_2c0_1, eax_149, edx_105);
                                                    var_2c4_1 = eax_151;
                                                    var_2c0_1 = edx_106;
                                                    
                                                    if (var_2b0_1 > 0x39)
                                                        var_2b0_1 += var_264;
                                                    
                                                    *var_8_1 = var_2b0_1;
                                                    var_8_1 -= 1;
                                                }
                                                
                                                var_28 = (&var_4d - var_8_1);
                                                var_8 = (var_8_1 + 1);
                                                
                                                if (((var_14 & 0x200) != 0 && (var_28 == 0 || *var_8 != 0x30)))
                                                {
                                                    var_8 -= 1;
                                                    *var_8 = 0x30;
                                                    var_28 += 1;
                                                }
                                                break;
                                            }
                                            case 0x6e:
                                            {
                                                int16_t* eax_96 = _get_int_arg(&arg_10);
                                                int32_t eax_97;
                                                eax_97 = sub_100274f0();
                                                
                                                if (eax_97 != 0)
                                                {
                                                    if ((var_14 & 0x20) == 0)
                                                        *eax_96 = var_250;
                                                    else
                                                    {
                                                        ecx_12 = var_250;
                                                        *eax_96 = ecx_12;
                                                    }
                                                    
                                                    var_2c = 1;
                                                }
                                                else
                                                {
                                                    int32_t var_330_1 = 0;
                                                    
                                                    if (var_330_1 == 0)
                                                    {
                                                        int32_t eax_99;
                                                        eax_99 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x695, nullptr, u"("'n' format specifier disabled"…");
                                                        
                                                        if (eax_99 == 1)
                                                            breakpoint();
                                                    }
                                                    
                                                    if (var_330_1 == 0)
                                                    {
                                                        *sub_1000eca0() = 0x16;
                                                        sub_1000c310(u"("'n' format specifier disabled"…", &lookup_table_1003b3b8[0x5c], u"f:\dd\vctools\crt_bld\self_x86\c…", 0x695, 0);
                                                        _LocaleUpdate::~_LocaleUpdate(&var_44);
                                                        break;
                                                    }
                                                }
                                                break;
                                            }
                                            case 0x6f:
                                            {
                                                var_c_1 = 8;
                                                
                                                if ((var_14 & 0x80) != 0)
                                                    var_14 |= 0x200;
                                                
                                                goto label_1001eb72;
                                            }
                                            case 0x70:
                                            {
                                                var_34 = 8;
                                            label_1001eb0b:
                                                var_264 = 7;
                                            label_1001eb21:
                                                var_c_1 = 0x10;
                                                
                                                if ((var_14 & 0x80) != 0)
                                                {
                                                    var_18 = 0x30;
                                                    char var_17_1 = (var_264 + 0x51);
                                                    var_20 = 2;
                                                }
                                                
                                                goto label_1001eb72;
                                            }
                                            case 0x73:
                                            {
                                            label_1001e745:
                                                int32_t var_32c_1;
                                                
                                                if (var_34 != 0xffffffff)
                                                    var_32c_1 = var_34;
                                                else
                                                    var_32c_1 = 0x7fffffff;
                                                
                                                int32_t var_294_1 = var_32c_1;
                                                var_8 = _get_int_arg(&arg_10);
                                                
                                                if ((var_14 & 0x810) == 0)
                                                {
                                                    if (var_8 == 0)
                                                        var_8 = data_10044604;
                                                    
                                                    char* var_290_1 = var_8;
                                                    
                                                    while (true)
                                                    {
                                                        ecx_12 = var_294_1;
                                                        var_294_1 -= 1;
                                                        
                                                        if (ecx_12 == 0)
                                                            break;
                                                        
                                                        if (*var_290_1 == 0)
                                                            break;
                                                        
                                                        var_290_1 = &var_290_1[1];
                                                    }
                                                    
                                                    var_28 = (var_290_1 - var_8);
                                                }
                                                else
                                                {
                                                    if (var_8 == 0)
                                                        var_8 = data_10044608;
                                                    
                                                    var_10 = 1;
                                                    char* var_298_1 = var_8;
                                                    
                                                    while (true)
                                                    {
                                                        int32_t edx_55 = var_294_1;
                                                        var_294_1 -= 1;
                                                        
                                                        if (edx_55 == 0)
                                                            break;
                                                        
                                                        if (*var_298_1 == 0)
                                                            break;
                                                        
                                                        var_298_1 = &var_298_1[2];
                                                    }
                                                    
                                                    var_28 = ((var_298_1 - var_8) >> 1);
                                                }
                                                break;
                                            }
                                            case 0x75:
                                            {
                                                var_c_1 = 0xa;
                                                goto label_1001eb72;
                                            }
                                            case 0x78:
                                            {
                                                var_264 = 0x27;
                                                goto label_1001eb21;
                                            }
                                        }
                                    
                                    if (var_2c == 0)
                                    {
                                        if ((var_14 & 0x40) != 0)
                                        {
                                            if ((var_14 & 0x100) != 0)
                                            {
                                                var_18 = 0x2d;
                                                var_20 = 1;
                                            }
                                            else if ((var_14 & 1) != 0)
                                            {
                                                var_18 = 0x2b;
                                                var_20 = 1;
                                            }
                                            else if ((var_14 & 2) != 0)
                                            {
                                                var_18 = 0x20;
                                                var_20 = 1;
                                            }
                                        }
                                        
                                        int32_t* eax_160 = ((var_1c - var_28) - var_20);
                                        
                                        if ((var_14 & 0xc) == 0)
                                            sub_1001f280(0x20, eax_160, arg1, &var_250);
                                        
                                        sub_1001f2c0(&var_18, var_20, arg1, &var_250);
                                        
                                        if (((var_14 & 8) != 0 && (var_14 & 4) == 0))
                                            sub_1001f280(0x30, eax_160, arg1, &var_250);
                                        
                                        if ((var_10 == 0 || var_28 <= 0))
                                            sub_1001f2c0(var_8, var_28, arg1, &var_250);
                                        else
                                        {
                                            int32_t var_2e0_1 = 0;
                                            char* var_2cc_1 = var_8;
                                            int32_t var_2d0_1 = var_28;
                                            
                                            while (true)
                                            {
                                                ecx_12 = var_2d0_1;
                                                var_2d0_1 -= 1;
                                                
                                                if (ecx_12 == 0)
                                                    break;
                                                
                                                ecx_12 = *var_2cc_1;
                                                void var_2dc;
                                                int32_t* var_2d4;
                                                int32_t eax_168;
                                                eax_168 = _wctomb_s(&var_2d4, &var_2dc, 6, ecx_12);
                                                var_2cc_1 = &var_2cc_1[2];
                                                
                                                if ((eax_168 != 0 || var_2d4 == 0))
                                                {
                                                    var_250 = 0xffffffff;
                                                    break;
                                                }
                                                
                                                sub_1001f2c0(&var_2dc, var_2d4, arg1, &var_250);
                                                continue;
                                            }
                                        }
                                        
                                        if ((var_250 >= 0 && (var_14 & 4) != 0))
                                            sub_1001f280(0x20, eax_160, arg1, &var_250);
                                    }
                                    
                                    if (var_24_1 == 0)
                                        continue;
                                    else
                                    {
                                        sub_10011340(var_24_1, 2);
                                        var_24_1 = nullptr;
                                        continue;
                                    }
                                    break;
                                }
                            }
                    }
                    
                    int32_t var_338_1;
                    
                    if ((var_260_1 == 0 || var_260_1 == 7))
                        var_338_1 = 1;
                    else
                        var_338_1 = 0;
                    
                    if ((var_338_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x8f5, nullptr, u"((state == ST_NORMAL) || (state …") == 1))
                        breakpoint();
                    
                    if (var_338_1 != 0)
                    {
                        int32_t var_304_1 = var_250;
                        _LocaleUpdate::~_LocaleUpdate(&var_44);
                        break;
                    }
                    
                    *sub_1000eca0() = 0x16;
                    sub_1000c310(u"((state == ST_NORMAL) || (state …", &lookup_table_1003b3b8[0x5c], u"f:\dd\vctools\crt_bld\self_x86\c…", 0x8f5, 0);
                    _LocaleUpdate::~_LocaleUpdate(&var_44);
                    break;
                }
            }
            else
            {
                *sub_1000eca0() = 0x16;
                sub_1000c310(u"(format != NULL)", &lookup_table_1003b3b8[0x5c], u"f:\dd\vctools\crt_bld\self_x86\c…", 0x407, 0);
                _LocaleUpdate::~_LocaleUpdate(&var_44);
            }
        }
        else
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"( (_Stream->_flag & _IOSTRG) || …", &lookup_table_1003b3b8[0x5c], u"f:\dd\vctools\crt_bld\self_x86\c…", 0x404, 0);
            _LocaleUpdate::~_LocaleUpdate(&var_44);
        }
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(stream != NULL)", &lookup_table_1003b3b8[0x5c], u"f:\dd\vctools\crt_bld\self_x86\c…", 0x402, 0);
        _LocaleUpdate::~_LocaleUpdate(&var_44);
    }
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t* sub_1001f1e0(char arg1, char** arg2, int32_t* arg3)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t* result;
    
    if (((arg2[3] & 0x40) == 0 || arg2[2] != 0))
    {
        arg2[1] -= 1;
        uint32_t result_1;
        
        if (arg2[1] < 0)
        {
            char** var_c_1 = arg2;
            result = sub_100162c0(arg1);
            result_1 = result;
        }
        else
        {
            char** eax_2;
            eax_2 = arg1;
            **arg2 = eax_2;
            result_1 = arg1;
            result = &*arg2[1];
            *arg2 = result;
        }
        
        if (result_1 != 0xffffffff)
        {
            result = (*arg3 + 1);
            *arg3 = result;
        }
        else
            *arg3 = 0xffffffff;
    }
    else
    {
        result = arg3;
        *arg3 = (*result + 1);
    }
    
    return result;
}

int32_t* sub_1001f280(char arg1, int32_t* arg2, char** arg3, int32_t* arg4)
{
    int32_t* result;
    
    do
    {
        result = arg2;
        arg2 -= 1;
        
        if (result <= 0)
            break;
        
        result = sub_1001f1e0(arg1, arg3, arg4);
    } while (*arg4 != 0xffffffff);
    
    return result;
}

int32_t* sub_1001f2c0(char* arg1, int32_t* arg2, char** arg3, int32_t* arg4)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t* result;
    
    if (((arg3[3] & 0x40) == 0 || arg3[2] != 0))
    {
        while (true)
        {
            result = arg2;
            arg2 -= 1;
            
            if (result <= 0)
                break;
            
            result = *arg1;
            *var_8[3] = result;
            sub_1001f1e0(*var_8[3], arg3, arg4);
            arg1 = &arg1[1];
            
            if (*arg4 == 0xffffffff)
            {
                result = sub_1000eca0();
                
                if (*result != 0x2a)
                    break;
                
                sub_1001f1e0(0x3f, arg3, arg4);
            }
        }
    }
    else
    {
        result = arg4;
        *arg4 = (*result + arg2);
    }
    
    return result;
}

int32_t sub_1001f350(int32_t arg1, int32_t arg2)
{
    int32_t eax_1;
    int32_t edx;
    edx = HIGHD(arg1);
    eax_1 = LOWD(arg1);
    int32_t edi_5 = (((((eax_1 ^ edx) - edx) & 0xf) ^ edx) - edx);
    
    if (edi_5 != 0)
    {
        __builtin_memset(arg1, 0, (-(edi_5) + 0x10));
        sub_1001f350((arg1 + (-(edi_5) + 0x10)), 0, (arg2 - (-(edi_5) + 0x10)), (-(edi_5) + 0x10));
        return arg1;
    }
    
    int32_t n_1 = (arg2 & 0x7f);
    int32_t n = n_1;
    
    if (arg2 != n_1)
    {
        sub_1001f3e0(eax_1, (arg2 - n_1));
        eax_1 = arg1;
        n_1 = n;
    }
    
    if (n_1 == 0)
        return eax_1;
    
    __builtin_memset(((eax_1 + arg2) - n_1), 0, n);
    return arg1;
}

int32_t sub_1001f3e0(int32_t arg1, int32_t arg2)
{
    int32_t s = arg1;
    uint32_t i_1 = (arg2 >> 7);
    uint32_t i;
    
    do
    {
        __builtin_memset(s, 0, 0x80);
        s += 0x80;
        i = i_1;
        i_1 -= 1;
    } while (i != 1);
}

int32_t sub_1001f440()
{
    bool p = /* bool p = unimplemented  {sub esp, 0x18} */;
    bool a = /* bool a = unimplemented  {sub esp, 0x18} */;
    int32_t ebx;
    int32_t var_20 = ebx;
    int32_t var_8 = 0;
    int32_t var_10 = 0;
    int32_t var_c = 0;
    int32_t var_24 = ebx;
    int32_t var_1c;
    int32_t __saved_ebp;
    bool d;
    int32_t var_28 = (((((&__saved_ebp - 0x18)) ? 1 : 0) << 0xb) | ((((d) ? 1 : 0) << 0xa) | ((((&var_1c < 0) ? 1 : 0) << 7) | ((((&__saved_ebp == 0x18) ? 1 : 0) << 6) | ((((a) ? 1 : 0) << 4) | ((((p) ? 1 : 0) << 2) | ((&__saved_ebp < 0x18) ? 1 : 0)))))));
    int32_t eax_1 = (var_28 ^ 0x200000);
    int32_t var_28_2 = (((((TEST_BITD(eax_1, 0xb))) ? 1 : 0) << 0xb) | (((((TEST_BITD(eax_1, 0xa))) ? 1 : 0) << 0xa) | (((((TEST_BITD(eax_1, 7))) ? 1 : 0) << 7) | (((((TEST_BITD(eax_1, 6))) ? 1 : 0) << 6) | (((((TEST_BITD(eax_1, 4))) ? 1 : 0) << 4) | (((((TEST_BITD(eax_1, 2))) ? 1 : 0) << 2) | (((TEST_BITD(eax_1, 0))) ? 1 : 0)))))));
    
    if (var_28_2 != var_28)
    {
        int32_t var_28_3 = var_28;
        int32_t eax_2;
        int32_t ecx_1;
        int32_t edx_2;
        int32_t ebx_1;
        eax_2 = __cpuid(0, var_28);
        int32_t var_10_1 = eax_2;
        int32_t var_1c_1 = ebx_1;
        int32_t var_18_1 = edx_2;
        int32_t var_14_1 = ecx_1;
        int32_t eax_3;
        int32_t ecx_2;
        int32_t edx_3;
        int32_t ebx_2;
        eax_3 = __cpuid(1, ecx_1);
        var_8 = edx_3;
        int32_t var_c_1 = eax_3;
    }
    
    if ((var_8 & 0x4000000) == 0)
        return 0;
    
    _ctrlevent_capture@4();
    return 1;
}

int32_t _ctrlevent_capture@4()
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041f58;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_34 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_38 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_1c = &var_38;
    int32_t var_20 = 0;
    int32_t var_8_1 = 0;
    int32_t var_8_2 = 0xfffffffe;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return 1;
}

int32_t sub_1001f517(void* arg1 @ ebp)
{
    *(arg1 - 0x20) = ***(arg1 - 0x14);
    
    if ((*(arg1 - 0x20) == 0xc0000005 || *(arg1 - 0x20) == 0xc000001d))
        *(arg1 - 0x24) = 1;
    else
        *(arg1 - 0x24) = 0;
    
    return *(arg1 - 0x24);
}

int32_t sub_1001f547(int32_t* arg1 @ ebp)
{
    int32_t* esp_4 = arg1[-6];
    arg1[-7] = 0;
    arg1[-1] = 0xfffffffe;
    TEB* fsbase;
    fsbase->NtTib.ExceptionList = arg1[-4];
    *esp_4;
    esp_4[1];
    esp_4[2];
    esp_4[3];
    *arg1;
    return arg1[-7];
}

int32_t sub_1001f570()
{
    data_10049250 = sub_1001f440();
    return 0;
}

void* sub_1001f590(int32_t arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041f78;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_2c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_30 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void* result = nullptr;
    
    if (arg1 <= data_10049240)
    {
        __lock(4);
        int32_t var_8_1 = 0;
        result = sub_100206f0(arg1);
        int32_t var_8_2 = 0xfffffffe;
        sub_1001f602();
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1001f602()
{
    return __unlock(4);
}

void* __malloc_base(uint32_t arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t var_8_1 = 0;
    
    if (arg1 > 0xffffffe0)
    {
        sub_1001ce10(arg1);
        *sub_1000eca0() = 0xc;
        return nullptr;
    }
    
    void* result;
    int32_t i;
    
    do
    {
        result = sub_1001f6c0(arg1);
        
        if (result != 0)
            break;
        
        if (data_10045c7c == 0)
        {
            *sub_1000eca0() = 0xc;
            break;
        }
        
        i = sub_1001ce10(arg1);
    } while (i != 0);
    
    if (result == 0)
        *sub_1000eca0() = 0xc;
    
    return result;
}

void* sub_1001f6c0(uint32_t arg1)
{
    if (data_10045c64 == 0)
    {
        __FF_MSGBANNER();
        sub_10024990(0x1e);
        sub_100159f0(0xff);
        /* no return */
    }
    
    if (data_10049254 == 1)
    {
        uint32_t dwBytes;
        
        if (arg1 == 0)
            dwBytes = 1;
        else
            dwBytes = arg1;
        
        return HeapAlloc(data_10045c64, HEAP_NONE, dwBytes);
    }
    
    if (data_10049254 == 3)
    {
        void* result = sub_1001f590(arg1);
        
        if (result != 0)
            return result;
    }
    
    if (arg1 == 0)
        arg1 = 1;
    
    return HeapAlloc(data_10045c64, HEAP_NONE, ((arg1 + 0xf) & 0xfffffff0));
}

int32_t sub_1001f780(int32_t arg1, uint32_t arg2)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041f98;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_38 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_3c = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t eax_2;
    eax_2 = arg1 != 0;
    
    if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x60, nullptr, u"pBlock != NULL") == 1))
        breakpoint();
    
    int32_t result;
    
    if (eax_2 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"pBlock != NULL", u"_expand_base", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x60, 0);
        result = 0;
    }
    else if (arg2 <= 0xffffffe0)
    {
        int32_t result_1;
        
        if (data_10049254 != 3)
        {
            int32_t var_2c_1 = 0xffffffff;
            
            if (arg2 == 0)
                arg2 = 1;
            
            uint32_t eax_16 = HeapSize(data_10045c64, HEAP_NONE, arg1);
            result_1 = HeapReAlloc(data_10045c64, HEAP_REALLOC_IN_PLACE_ONLY, arg1, arg2);
            
            if (result_1 == 0)
            {
                if ((eax_16 > 0x4000 || arg2 > eax_16))
                    *sub_1000eca0() = __get_errno_from_oserr(GetLastError());
                else if (sub_1001f9a0() == 0)
                    *sub_1000eca0() = __get_errno_from_oserr(GetLastError());
                else
                    result_1 = arg1;
            }
        }
        else
        {
            __lock(4);
            int32_t var_8_1 = 0;
            void* eax_6 = sub_10020070(arg1);
            
            if (eax_6 != 0)
            {
                result_1 = 0;
                
                if ((arg2 <= data_10049240 && sub_10020f10(eax_6, arg1, arg2) != 0))
                    result_1 = arg1;
            }
            
            int32_t var_8_2 = 0xfffffffe;
            sub_1001f89e();
            
            if (eax_6 == 0)
            {
                if (arg2 == 0)
                    arg2 = 1;
                
                result_1 = HeapReAlloc(data_10045c64, HEAP_REALLOC_IN_PLACE_ONLY, arg1, ((arg2 + 0xf) & 0xfffffff0));
                
                if (result_1 == 0)
                    *sub_1000eca0() = __get_errno_from_oserr(GetLastError());
            }
        }
        
        result = result_1;
    }
    else
    {
        *sub_1000eca0() = 0xc;
        result = 0;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1001f89e()
{
    return __unlock(4);
}

int32_t sub_1001f9a0()
{
    int32_t var_8 = 0xffffffff;
    
    if (data_10045c80 == 0)
    {
        HMODULE hModule = GetModuleHandleW(u"kernel32.dll");
        
        if (hModule != 0)
            data_10045c84 = sub_10018a80(GetProcAddress(hModule, "HeapQueryInformation"));
        
        data_10045c80 = 1;
    }
    
    int32_t eax_4 = __Getmonths();
    
    if ((data_10045c84 != eax_4 && (sub_10018b70(data_10045c84)(data_10045c64, 0, &var_8, 4, 0) != 0 && var_8 == 2)))
        return 1;
    
    return 0;
}

void* sub_1001fa50(int128_t* arg1, void* arg2)
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_40 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x10041fb8 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void* var_24 = arg2;
    void* result;
    
    if (arg1 == 0)
        result = __malloc_base(arg2);
    else if (arg2 == 0)
    {
        sub_1001fdf0(arg1);
        result = nullptr;
    }
    else if (data_10049254 != 3)
    {
        while (true)
        {
            int32_t var_20_1 = 0;
            
            if (arg2 > 0xffffffe0)
            {
                sub_1001ce10(arg2);
                *sub_1000eca0() = 0xc;
                result = nullptr;
                break;
            }
            
            if (arg2 == 0)
                arg2 = 1;
            
            void* result_2 = HeapReAlloc(data_10045c64, HEAP_NONE, arg1, arg2);
            
            if ((result_2 != 0 || data_10045c7c == 0))
            {
                if (result_2 == 0)
                    *sub_1000eca0() = __get_errno_from_oserr(GetLastError());
                
                result = result_2;
                break;
            }
            
            if (sub_1001ce10(arg2) != 0)
                continue;
            
            *sub_1000eca0() = __get_errno_from_oserr(GetLastError());
            result = nullptr;
            break;
        }
    }
    else
    {
        while (true)
        {
            void* result_1 = nullptr;
            
            if (arg2 > 0xffffffe0)
            {
                sub_1001ce10(arg2);
                *sub_1000eca0() = 0xc;
                result = nullptr;
                break;
            }
            
            __lock(4);
            int32_t var_8_1 = 0;
            void* var_2c_1 = sub_10020070(arg1);
            
            if (var_2c_1 != 0)
            {
                if (arg2 <= data_10049240)
                {
                    if (sub_10020f10(var_2c_1, arg1, arg2) == 0)
                    {
                        result_1 = sub_100206f0(arg2);
                        
                        if (result_1 != 0)
                        {
                            void* edx_5 = (*(arg1 - 4) - 1);
                            void* var_30_1;
                            
                            if (edx_5 >= arg2)
                                var_30_1 = arg2;
                            else
                                var_30_1 = edx_5;
                            
                            sub_10013c90(result_1, arg1, var_30_1, eax_1);
                            var_2c_1 = sub_10020070(arg1);
                            sub_10020130(var_2c_1, arg1);
                        }
                    }
                    else
                        result_1 = arg1;
                }
                
                if (result_1 == 0)
                {
                    if (arg2 == 0)
                        arg2 = 1;
                    
                    arg2 = ((arg2 + 0xf) & 0xfffffff0);
                    result_1 = HeapAlloc(data_10045c64, HEAP_NONE, arg2);
                    
                    if (result_1 != 0)
                    {
                        void* ecx_10 = (*(arg1 - 4) - 1);
                        void* var_34_1;
                        
                        if (ecx_10 >= arg2)
                            var_34_1 = arg2;
                        else
                            var_34_1 = ecx_10;
                        
                        sub_10013c90(result_1, arg1, var_34_1, eax_1);
                        sub_10020130(var_2c_1, arg1);
                    }
                }
            }
            
            int32_t var_8_2 = 0xfffffffe;
            sub_1001fc28();
            
            if (var_2c_1 == 0)
            {
                if (arg2 == 0)
                    arg2 = 1;
                
                arg2 = ((arg2 + 0xf) & 0xfffffff0);
                result_1 = HeapReAlloc(data_10045c64, HEAP_NONE, arg1, arg2);
            }
            
            if ((result_1 != 0 || data_10045c7c == 0))
            {
                if (result_1 == 0)
                {
                    if (var_2c_1 != 0)
                        *sub_1000eca0() = 0xc;
                    else
                        *sub_1000eca0() = __get_errno_from_oserr(GetLastError());
                }
                
                result = result_1;
                break;
            }
            
            if (sub_1001ce10(arg2) != 0)
                continue;
            
            if (var_2c_1 != 0)
                *sub_1000eca0() = 0xc;
            else
                *sub_1000eca0() = __get_errno_from_oserr(GetLastError());
            
            result = nullptr;
            break;
        }
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1001fc28()
{
    return __unlock(4);
}

BOOL sub_1001fdf0(int32_t arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041fd8;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    BOOL result = (__security_cookie_1 ^ &__saved_ebp);
    BOOL result_1 = result;
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_20 = 0;
    
    if (arg1 != 0)
    {
        if (data_10049254 != 3)
        {
            result = HeapFree(data_10045c64, HEAP_NONE, arg1);
            
            if (result == 0)
            {
                int32_t eax_8 = __get_errno_from_oserr(GetLastError());
                result = sub_1000eca0();
                *result = eax_8;
            }
        }
        else
        {
            __lock(4);
            int32_t var_8_1 = 0;
            void* eax_2 = sub_10020070(arg1);
            
            if (eax_2 != 0)
                sub_10020130(eax_2, arg1);
            
            int32_t var_8_2 = 0xfffffffe;
            result = sub_1001fe85();
            
            if (eax_2 == 0)
            {
                result = HeapFree(data_10045c64, HEAP_NONE, arg1);
                
                if (result == 0)
                {
                    int32_t eax_5 = __get_errno_from_oserr(GetLastError());
                    result = sub_1000eca0();
                    *result = eax_5;
                }
            }
        }
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1001fe85()
{
    return __unlock(4);
}

int32_t sub_1001ff20()
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10041ff8;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_2c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_30 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result = 0xfffffffe;
    
    if (data_10049254 == 3)
    {
        __lock(4);
        int32_t var_8_1 = 0;
        
        if (sub_100214e0() < 0)
            result = 0xfffffffc;
        
        int32_t var_8_2 = 0xfffffffe;
        sub_1001ff91();
    }
    
    if (HeapValidate(data_10045c64, HEAP_NONE, nullptr) == 0)
    {
        if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
            result = 0xfffffffc;
        else
        {
            *sub_1000ecd0() = 0x78;
            *sub_1000eca0() = 0x28;
        }
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1001ff91()
{
    return __unlock(4);
}

int32_t sub_10020000(int32_t arg1)
{
    data_1004923c = HeapAlloc(data_10045c64, HEAP_NONE, 0x140);
    
    if (data_1004923c == 0)
        return 0;
    
    data_10049240 = arg1;
    data_10049244 = data_1004923c;
    data_10045c88 = 0;
    data_10049238 = 0;
    data_10049248 = 0x10;
    return 1;
}

void* sub_10020070(int32_t arg1)
{
    void* result = data_1004923c;
    
    while (true)
    {
        if (result >= ((data_10049238 * 0x14) + data_1004923c))
            return nullptr;
        
        if ((arg1 - *(result + 0xc)) < 0x100000)
            break;
        
        result += 0x14;
    }
    
    return result;
}

int32_t sub_100200d0(void* arg1, int32_t arg2)
{
    int32_t ecx_1 = (arg2 - *(arg1 + 0xc));
    
    if ((((0x80000000 >> (ecx_1 >> 0xf)) & *(arg1 + 8)) == 0 && ((ecx_1 & 0xf) == 0 && (ecx_1 & 0xfff) != 0)))
        return 1;
    
    return 0;
}

int32_t* sub_10020130(void* arg1, int32_t arg2)
{
    void* ecx = *(arg1 + 0x10);
    int32_t eax_2 = (arg2 - *(arg1 + 0xc));
    uint32_t ecx_2 = (eax_2 >> 0xf);
    void* result_1 = (arg2 - 4);
    int32_t* result = result_1;
    int32_t var_40 = (*result - 1);
    
    if ((var_40 & 1) == 0)
    {
        void* eax_5 = (result_1 + var_40);
        int32_t edx_7 = *eax_5;
        int32_t ecx_7 = *(result_1 - 4);
        int32_t var_14;
        
        if ((edx_7 & 1) == 0)
        {
            var_14 = ((edx_7 >> 4) - 1);
            
            if (var_14 > 0x3f)
                var_14 = 0x3f;
            
            if (*(eax_5 + 4) == *(eax_5 + 8))
            {
                if (var_14 >= 0x20)
                {
                    *((ecx + (ecx_2 << 2)) + 0xc4) &= !((0x80000000 >> (var_14 - 0x20)));
                    uint32_t eax_16;
                    eax_16 = *((ecx + var_14) + 4);
                    eax_16 -= 1;
                    *((ecx + var_14) + 4) = eax_16;
                    
                    if (*((ecx + var_14) + 4) == 0)
                        *(arg1 + 4) &= !((0x80000000 >> (var_14 - 0x20)));
                }
                else
                {
                    *((ecx + (ecx_2 << 2)) + 0x44) &= !((0x80000000 >> var_14));
                    uint32_t eax_12;
                    eax_12 = *((ecx + var_14) + 4);
                    eax_12 -= 1;
                    *((ecx + var_14) + 4) = eax_12;
                    
                    if (*((ecx + var_14) + 4) == 0)
                        *arg1 &= !((0x80000000 >> var_14));
                }
            }
            
            *(*(eax_5 + 8) + 4) = *(eax_5 + 4);
            *(*(eax_5 + 4) + 8) = *(eax_5 + 8);
            var_40 += edx_7;
        }
        
        int32_t var_3c_1 = ((var_40 >> 4) - 1);
        
        if (var_3c_1 > 0x3f)
            var_3c_1 = 0x3f;
        
        int32_t var_34;
        void* result_2;
        
        if ((ecx_7 & 1) == 0)
        {
            result_2 = (result_1 - ecx_7);
            var_34 = ((ecx_7 >> 4) - 1);
            
            if (var_34 > 0x3f)
                var_34 = 0x3f;
            
            var_40 += ecx_7;
            var_3c_1 = ((var_40 >> 4) - 1);
            
            if (var_3c_1 > 0x3f)
                var_3c_1 = 0x3f;
            
            if (var_34 != var_3c_1)
            {
                if (*(result_2 + 4) == *(result_2 + 8))
                {
                    if (var_34 >= 0x20)
                    {
                        *((ecx + (ecx_2 << 2)) + 0xc4) &= !((0x80000000 >> (var_34 - 0x20)));
                        uint32_t eax_36;
                        eax_36 = *((ecx + var_34) + 4);
                        eax_36 -= 1;
                        *((ecx + var_34) + 4) = eax_36;
                        
                        if (*((ecx + var_34) + 4) == 0)
                            *(arg1 + 4) &= !((0x80000000 >> (var_34 - 0x20)));
                    }
                    else
                    {
                        *((ecx + (ecx_2 << 2)) + 0x44) &= !((0x80000000 >> var_34));
                        uint32_t ecx_37;
                        ecx_37 = *((ecx + var_34) + 4);
                        ecx_37 -= 1;
                        *((ecx + var_34) + 4) = ecx_37;
                        
                        if (*((ecx + var_34) + 4) == 0)
                            *arg1 &= !((0x80000000 >> var_34));
                    }
                }
                
                *(*(result_2 + 8) + 4) = *(result_2 + 4);
                *(*(result_2 + 4) + 8) = *(result_2 + 8);
            }
            
            result_1 = result_2;
        }
        
        void* var_28;
        
        if (((ecx_7 & 1) != 0 || var_34 != var_3c_1))
        {
            var_28 = &((ecx + (ecx_2 * 0x204)) + 0x144)[(var_3c_1 * 2)];
            *(result_1 + 4) = *(var_28 + 4);
            *(result_1 + 8) = var_28;
            *(var_28 + 4) = result_1;
            *(*(result_1 + 4) + 8) = result_1;
            
            if (*(result_1 + 4) == *(result_1 + 8))
            {
                if (var_3c_1 >= 0x20)
                {
                    int32_t eax_52 = *((ecx + var_3c_1) + 4);
                    void* edx_76;
                    edx_76 = *((ecx + var_3c_1) + 4);
                    edx_76 += 1;
                    *((ecx + var_3c_1) + 4) = edx_76;
                    
                    if (eax_52 == 0)
                        *(arg1 + 4) |= (0x80000000 >> (var_3c_1 - 0x20));
                    
                    *((ecx + (ecx_2 << 2)) + 0xc4) |= (0x80000000 >> (var_3c_1 - 0x20));
                }
                else
                {
                    int32_t eax_48 = *((ecx + var_3c_1) + 4);
                    void* edx_70;
                    edx_70 = *((ecx + var_3c_1) + 4);
                    edx_70 += 1;
                    *((ecx + var_3c_1) + 4) = edx_70;
                    
                    if (eax_48 == 0)
                        *arg1 |= (0x80000000 >> var_3c_1);
                    
                    *((ecx + (ecx_2 << 2)) + 0x44) |= (0x80000000 >> var_3c_1);
                }
            }
        }
        
        *result_1 = var_40;
        *((result_1 + var_40) - 4) = var_40;
        *((ecx + (ecx_2 * 0x204)) + 0x144) -= 1;
        result = ((ecx + (ecx_2 * 0x204)) + 0x144);
        
        if (*result == 0)
        {
            if (data_10045c88 != 0)
            {
                int32_t lpAddress = ((data_1004924c << 0xf) + *(data_10045c88 + 0xc));
                VirtualFree(lpAddress, 0x8000, MEM_DECOMMIT);
                *(data_10045c88 + 8) |= (0x80000000 >> data_1004924c);
                *((*(data_10045c88 + 0x10) + (data_1004924c << 2)) + 0xc4) = 0;
                int32_t ecx_87;
                ecx_87 = *(*(data_10045c88 + 0x10) + 0x43);
                ecx_87 -= 1;
                *(*(data_10045c88 + 0x10) + 0x43) = ecx_87;
                
                if (*(*(data_10045c88 + 0x10) + 0x43) == 0)
                    *(data_10045c88 + 4) &= 0xfffffffe;
                
                if (*(data_10045c88 + 8) == 0xffffffff)
                {
                    VirtualFree(*(data_10045c88 + 0xc), 0, MEM_RELEASE);
                    HeapFree(data_10045c64, HEAP_NONE, *(data_10045c88 + 0x10));
                    sub_10014000(data_10045c88, (data_10045c88 + 0x14), (((data_10049238 * 0x14) + data_1004923c) - (data_10045c88 + 0x14)), var_40, var_3c_1, edx_7, var_34, ecx, ((ecx + (ecx_2 * 0x204)) + 0x144), var_28, eax_2, ecx_7, result_1, ecx_2, var_14, result_2, eax_5, lpAddress);
                    data_10049238 -= 1;
                    
                    if (arg1 > data_10045c88)
                        arg1 -= 0x14;
                    
                    data_10049244 = data_1004923c;
                }
            }
            
            result = arg1;
            data_10045c88 = result;
            data_1004924c = ecx_2;
        }
    }
    
    return result;
}

void* sub_100206f0(int32_t arg1)
{
    int32_t eax_2 = ((data_10049238 * 0x14) + data_1004923c);
    int32_t ecx_2 = ((arg1 + 0x17) & 0xfffffff0);
    uint32_t var_34;
    uint32_t var_1c;
    
    if (((ecx_2 >> 4) - 1) >= 0x20)
    {
        var_1c = 0;
        var_34 = (0xffffffff >> (((ecx_2 >> 4) - 1) - 0x20));
    }
    else
    {
        var_1c = (0xffffffff >> ((ecx_2 >> 4) - 1));
        var_34 = 0xffffffff;
    }
    
    void* i;
    
    for (i = data_10049244; i < eax_2; i += 0x14)
    {
        if (((var_1c & *i) | (var_34 & *(i + 4))) != 0)
            break;
    }
    
    if (i == eax_2)
    {
        for (i = data_1004923c; i < data_10049244; i += 0x14)
        {
            if (((var_1c & *i) | (var_34 & *(i + 4))) != 0)
                break;
        }
        
        if (i == data_10049244)
        {
            for (; i < eax_2; i += 0x14)
            {
                if (*(i + 8) != 0)
                    break;
            }
            
            if (i == eax_2)
            {
                for (i = data_1004923c; i < data_10049244; i += 0x14)
                {
                    if (*(i + 8) != 0)
                        break;
                }
                
                if (i == data_10049244)
                {
                    i = sub_10020c10();
                    
                    if (i == 0)
                        return nullptr;
                }
            }
            
            **(i + 0x10) = sub_10020d20(i);
            
            if (**(i + 0x10) == 0xffffffff)
                return nullptr;
        }
    }
    
    data_10049244 = i;
    int32_t* eax_21 = *(i + 0x10);
    int32_t var_18_1 = *eax_21;
    
    if ((var_18_1 == 0xffffffff || ((var_1c & eax_21[(var_18_1 + 0x11)]) | (var_34 & eax_21[(var_18_1 + 0x31)])) == 0))
    {
        var_18_1 = 0;
        
        while (((var_1c & eax_21[(var_18_1 + 0x11)]) | (var_34 & eax_21[(var_18_1 + 0x31)])) == 0)
            var_18_1 += 1;
    }
    
    int32_t var_38_1 = 0;
    int32_t i_2 = (var_1c & eax_21[(var_18_1 + 0x11)]);
    int32_t i_1 = i_2;
    
    if (i_2 == 0)
    {
        var_38_1 = 0x20;
        i_1 = (var_34 & eax_21[(var_18_1 + 0x31)]);
    }
    
    while (i_1 >= 0)
    {
        i_1 <<= 1;
        var_38_1 += 1;
    }
    
    int32_t* eax_31 = eax_21[((((var_18_1 * 0x81) + 0x51) + (var_38_1 * 2)) + 1)];
    int32_t edx_34 = (*eax_31 - ecx_2);
    int32_t var_14_1 = ((edx_34 >> 4) - 1);
    
    if (var_14_1 > 0x3f)
        var_14_1 = 0x3f;
    
    if (var_14_1 != var_38_1)
    {
        if (eax_31[1] == eax_31[2])
        {
            if (var_38_1 >= 0x20)
            {
                eax_21[(var_18_1 + 0x31)] &= !((0x80000000 >> (var_38_1 - 0x20)));
                int32_t eax_41;
                eax_41 = *((eax_21 + var_38_1) + 4);
                eax_41 -= 1;
                *((eax_21 + var_38_1) + 4) = eax_41;
                
                if (*((eax_21 + var_38_1) + 4) == 0)
                    *(i + 4) &= !((0x80000000 >> (var_38_1 - 0x20)));
            }
            else
            {
                eax_21[(var_18_1 + 0x11)] &= !((0x80000000 >> var_38_1));
                int32_t eax_37;
                eax_37 = *((eax_21 + var_38_1) + 4);
                eax_37 -= 1;
                *((eax_21 + var_38_1) + 4) = eax_37;
                
                if (*((eax_21 + var_38_1) + 4) == 0)
                    *i &= !((0x80000000 >> var_38_1));
            }
        }
        
        *(eax_31[2] + 4) = eax_31[1];
        *(eax_31[1] + 8) = eax_31[2];
        
        if (edx_34 != 0)
        {
            void* eax_47 = &eax_21[(((var_18_1 * 0x81) + 0x51) + (var_14_1 * 2))];
            eax_31[1] = *(eax_47 + 4);
            eax_31[2] = eax_47;
            *(eax_47 + 4) = eax_31;
            *(eax_31[1] + 8) = eax_31;
            
            if (eax_31[1] == eax_31[2])
            {
                if (var_14_1 >= 0x20)
                {
                    int32_t eax_56 = *((eax_21 + var_14_1) + 4);
                    void* edx_71;
                    edx_71 = *((eax_21 + var_14_1) + 4);
                    edx_71 += 1;
                    *((eax_21 + var_14_1) + 4) = edx_71;
                    
                    if (eax_56 == 0)
                        *(i + 4) |= (0x80000000 >> (var_14_1 - 0x20));
                    
                    eax_21[(var_18_1 + 0x31)] |= (0x80000000 >> (var_14_1 - 0x20));
                }
                else
                {
                    int32_t eax_52 = *((eax_21 + var_14_1) + 4);
                    void* edx_65;
                    edx_65 = *((eax_21 + var_14_1) + 4);
                    edx_65 += 1;
                    *((eax_21 + var_14_1) + 4) = edx_65;
                    
                    if (eax_52 == 0)
                        *i |= (0x80000000 >> var_14_1);
                    
                    eax_21[(var_18_1 + 0x11)] |= (0x80000000 >> var_14_1);
                }
            }
        }
    }
    
    if (edx_34 != 0)
    {
        *eax_31 = edx_34;
        *((eax_31 + edx_34) - 4) = edx_34;
    }
    
    void* eax_62 = (eax_31 + edx_34);
    *eax_62 = (ecx_2 + 1);
    *((eax_62 + ecx_2) - 4) = (ecx_2 + 1);
    int32_t eax_65 = eax_21[((var_18_1 * 0x81) + 0x51)];
    eax_21[((var_18_1 * 0x81) + 0x51)] += 1;
    
    if ((eax_65 == 0 && (i == data_10045c88 && var_18_1 == data_1004924c)))
        data_10045c88 = 0;
    
    *eax_21 = var_18_1;
    return (eax_62 + 4);
}

void* const sub_10020c10()
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if (data_10049238 == data_10049248)
    {
        int32_t eax_2 = HeapReAlloc(data_10045c64, HEAP_NONE, data_1004923c, ((data_10049248 + 0x10) * 0x14));
        
        if (eax_2 == 0)
            return nullptr;
        
        data_1004923c = eax_2;
        data_10049248 += 0x10;
    }
    
    int32_t* result = ((data_10049238 * 0x14) + data_1004923c);
    result[4] = HeapAlloc(data_10045c64, HEAP_ZERO_MEMORY, 0x41c4);
    
    if (result[4] == 0)
        return nullptr;
    
    result[3] = VirtualAlloc(nullptr, 0x100000, MEM_RESERVE, PAGE_READWRITE);
    
    if (result[3] == 0)
    {
        HeapFree(data_10045c64, HEAP_NONE, result[4]);
        return nullptr;
    }
    
    *result = 0;
    result[1] = 0;
    result[2] = 0xffffffff;
    data_10049238 += 1;
    *result[4] = 0xffffffff;
    return result;
}

int32_t sub_10020d20(void* arg1)
{
    void* ecx = *(arg1 + 0x10);
    int32_t i = *(arg1 + 8);
    int32_t result = 0;
    
    while (i >= 0)
    {
        i <<= 1;
        result += 1;
    }
    
    for (int32_t i_1 = 0; i_1 < 0x3f; i_1 += 1)
    {
        void* eax_6 = (((ecx + (result * 0x204)) + 0x144) + (i_1 << 3));
        *(eax_6 + 8) = eax_6;
        *(eax_6 + 4) = eax_6;
    }
    
    void* lpAddress = ((result << 0xf) + *(arg1 + 0xc));
    
    if (VirtualAlloc(lpAddress, 0x8000, MEM_COMMIT, PAGE_READWRITE) == 0)
        return 0xffffffff;
    
    for (void* i_2 = lpAddress; i_2 <= (lpAddress + 0x7000); i_2 += 0x1000)
    {
        *(i_2 + 8) = 0xffffffff;
        *(i_2 + 0xffc) = 0xffffffff;
        *(i_2 + 0xc) = 0xff0;
        *(i_2 + 0x10) = (i_2 + 0x100c);
        *(i_2 + 0x14) = (i_2 - 0xff4);
        *(i_2 + 0xff8) = 0xff0;
    }
    
    *((ecx + (result * 0x204)) + 0x340) = (lpAddress + 0xc);
    *(*((ecx + (result * 0x204)) + 0x340) + 8) = ((ecx + (result * 0x204)) + 0x33c);
    *((ecx + (result * 0x204)) + 0x344) = (lpAddress + 0x700c);
    *(*((ecx + (result * 0x204)) + 0x344) + 4) = ((ecx + (result * 0x204)) + 0x33c);
    *((ecx + (result << 2)) + 0x44) = 0;
    *((ecx + (result << 2)) + 0xc4) = 1;
    int32_t ecx_21 = *(ecx + 0x43);
    void* eax_22;
    eax_22 = *(ecx + 0x43);
    eax_22 += 1;
    *(ecx + 0x43) = eax_22;
    
    if (ecx_21 == 0)
        *(arg1 + 4) |= 1;
    
    *(arg1 + 8) &= !((0x80000000 >> result));
    return result;
}

int32_t sub_10020f10(int32_t* arg1, int32_t arg2, int32_t arg3)
{
    int32_t eax_2 = ((arg3 + 0x17) & 0xfffffff0);
    void* edx = arg1[4];
    uint32_t edx_2 = ((arg2 - arg1[3]) >> 0xf);
    int32_t edx_5 = (*(arg2 - 4) - 1);
    void* eax_9 = ((arg2 - 4) + edx_5);
    int32_t edx_6 = *eax_9;
    
    if (eax_2 > edx_5)
    {
        if (((edx_6 & 1) != 0 || eax_2 > (edx_5 + edx_6)))
            return 0;
        
        int32_t var_c_1 = ((edx_6 >> 4) - 1);
        
        if (var_c_1 > 0x3f)
            var_c_1 = 0x3f;
        
        if (*(eax_9 + 4) == *(eax_9 + 8))
        {
            if (var_c_1 >= 0x20)
            {
                *((edx + (edx_2 << 2)) + 0xc4) &= !((0x80000000 >> (var_c_1 - 0x20)));
                uint32_t eax_21;
                eax_21 = *((edx + var_c_1) + 4);
                eax_21 -= 1;
                *((edx + var_c_1) + 4) = eax_21;
                
                if (*((edx + var_c_1) + 4) == 0)
                    arg1[1] &= !((0x80000000 >> (var_c_1 - 0x20)));
            }
            else
            {
                *((edx + (edx_2 << 2)) + 0x44) &= !((0x80000000 >> var_c_1));
                uint32_t eax_17;
                eax_17 = *((edx + var_c_1) + 4);
                eax_17 -= 1;
                *((edx + var_c_1) + 4) = eax_17;
                
                if (*((edx + var_c_1) + 4) == 0)
                    *arg1 &= !((0x80000000 >> var_c_1));
            }
        }
        
        *(*(eax_9 + 8) + 4) = *(eax_9 + 4);
        *(*(eax_9 + 4) + 8) = *(eax_9 + 8);
        int32_t ecx_29 = ((edx_5 + edx_6) - eax_2);
        
        if (ecx_29 > 0)
        {
            void* edx_34 = ((arg2 - 4) + eax_2);
            int32_t var_c_2 = ((ecx_29 >> 4) - 1);
            
            if (var_c_2 > 0x3f)
                var_c_2 = 0x3f;
            
            void* eax_30 = (((edx + (edx_2 * 0x204)) + 0x144) + (var_c_2 << 3));
            *(edx_34 + 4) = *(eax_30 + 4);
            *(edx_34 + 8) = eax_30;
            *(eax_30 + 4) = edx_34;
            *(*(edx_34 + 4) + 8) = edx_34;
            
            if (*(edx_34 + 4) == *(edx_34 + 8))
            {
                if (var_c_2 >= 0x20)
                {
                    int32_t eax_39 = *((edx + var_c_2) + 4);
                    void* edx_47;
                    edx_47 = *((edx + var_c_2) + 4);
                    edx_47 += 1;
                    *((edx + var_c_2) + 4) = edx_47;
                    
                    if (eax_39 == 0)
                        arg1[1] |= (0x80000000 >> (var_c_2 - 0x20));
                    
                    *((edx + (edx_2 << 2)) + 0xc4) |= (0x80000000 >> (var_c_2 - 0x20));
                }
                else
                {
                    int32_t eax_35 = *((edx + var_c_2) + 4);
                    void* edx_41;
                    edx_41 = *((edx + var_c_2) + 4);
                    edx_41 += 1;
                    *((edx + var_c_2) + 4) = edx_41;
                    
                    if (eax_35 == 0)
                        *arg1 |= (0x80000000 >> var_c_2);
                    
                    *((edx + (edx_2 << 2)) + 0x44) |= (0x80000000 >> var_c_2);
                }
            }
            
            *edx_34 = ecx_29;
            *((edx_34 + ecx_29) - 4) = ecx_29;
        }
        
        *(arg2 - 4) = (eax_2 + 1);
        *(((arg2 - 4) + eax_2) - 4) = (eax_2 + 1);
    }
    else if (eax_2 < edx_5)
    {
        *(arg2 - 4) = (eax_2 + 1);
        *(((arg2 - 4) + eax_2) - 4) = (eax_2 + 1);
        void* eax_50 = ((arg2 - 4) + eax_2);
        int32_t var_34_1 = (edx_5 - eax_2);
        int32_t var_30_1 = ((var_34_1 >> 4) - 1);
        
        if (var_30_1 > 0x3f)
            var_30_1 = 0x3f;
        
        if ((edx_6 & 1) == 0)
        {
            int32_t var_c_3 = ((edx_6 >> 4) - 1);
            
            if (var_c_3 > 0x3f)
                var_c_3 = 0x3f;
            
            if (*(eax_9 + 4) == *(eax_9 + 8))
            {
                if (var_c_3 >= 0x20)
                {
                    *((edx + (edx_2 << 2)) + 0xc4) &= !((0x80000000 >> (var_c_3 - 0x20)));
                    uint32_t eax_59;
                    eax_59 = *((edx + var_c_3) + 4);
                    eax_59 -= 1;
                    *((edx + var_c_3) + 4) = eax_59;
                    
                    if (*((edx + var_c_3) + 4) == 0)
                        arg1[1] &= !((0x80000000 >> (var_c_3 - 0x20)));
                }
                else
                {
                    *((edx + (edx_2 << 2)) + 0x44) &= !((0x80000000 >> var_c_3));
                    uint32_t eax_55;
                    eax_55 = *((edx + var_c_3) + 4);
                    eax_55 -= 1;
                    *((edx + var_c_3) + 4) = eax_55;
                    
                    if (*((edx + var_c_3) + 4) == 0)
                        *arg1 &= !((0x80000000 >> var_c_3));
                }
            }
            
            *(*(eax_9 + 8) + 4) = *(eax_9 + 4);
            *(*(eax_9 + 4) + 8) = *(eax_9 + 8);
            var_34_1 += edx_6;
            var_30_1 = ((var_34_1 >> 4) - 1);
            
            if (var_30_1 > 0x3f)
                var_30_1 = 0x3f;
        }
        
        void* edx_90 = (((edx + (edx_2 * 0x204)) + 0x144) + (var_30_1 << 3));
        *(eax_50 + 4) = *(edx_90 + 4);
        *(eax_50 + 8) = edx_90;
        *(edx_90 + 4) = eax_50;
        *(*(eax_50 + 4) + 8) = eax_50;
        
        if (*(eax_50 + 4) == *(eax_50 + 8))
        {
            if (var_30_1 >= 0x20)
            {
                int32_t eax_78 = *((edx + var_30_1) + 4);
                void* edx_101;
                edx_101 = *((edx + var_30_1) + 4);
                edx_101 += 1;
                *((edx + var_30_1) + 4) = edx_101;
                
                if (eax_78 == 0)
                    arg1[1] |= (0x80000000 >> (var_30_1 - 0x20));
                
                *((edx + (edx_2 << 2)) + 0xc4) |= (0x80000000 >> (var_30_1 - 0x20));
            }
            else
            {
                int32_t edx_95 = *((edx + var_30_1) + 4);
                void* ecx_94;
                ecx_94 = *((edx + var_30_1) + 4);
                ecx_94 += 1;
                *((edx + var_30_1) + 4) = ecx_94;
                
                if (edx_95 == 0)
                    *arg1 |= (0x80000000 >> var_30_1);
                
                *((edx + (edx_2 << 2)) + 0x44) |= (0x80000000 >> var_30_1);
            }
        }
        
        *eax_50 = var_34_1;
        *((eax_50 + var_34_1) - 4) = var_34_1;
    }
    
    return 1;
}

int32_t sub_100214e0()
{
    if (data_1004923c == 0)
        return 0xffffffff;
    
    void* var_3c_1 = data_1004923c;
    int32_t var_170_1 = 0;
    
    while (true)
    {
        if (var_170_1 >= data_10049238)
            return 0;
        
        void* ecx_3 = *(var_3c_1 + 0x10);
        
        if (ecx_3 == 0)
            break;
        
        void* var_14_1 = *(var_3c_1 + 0xc);
        int32_t* var_48_1 = (ecx_3 + 0x144);
        int32_t var_160_1 = *(var_3c_1 + 8);
        int32_t var_38_1 = 0;
        int32_t var_54_1 = 0;
        int32_t i = 0;
        
        while (i < 0x20)
        {
            int32_t var_10_1 = 0;
            int32_t var_8_1 = 0;
            int32_t var_18_1 = 0;
            void var_15c;
            
            for (int32_t j = 0; j < 0x40; j += 1)
                *(&var_15c + (j << 2)) = 0;
            
            if (var_160_1 >= 0)
            {
                if (var_14_1 == 0)
                    return 0xfffffffc;
                
                void* var_2c_1 = var_14_1;
                
                for (int32_t j_1 = 0; j_1 < 8; j_1 += 1)
                {
                    int32_t* var_28_1 = (var_2c_1 + 0xc);
                    int32_t* ecx_10 = &var_28_1[0x3fc];
                    
                    if ((var_28_1[-1] != 0xffffffff || *ecx_10 != 0xffffffff))
                        return 0xfffffffb;
                    
                    do
                    {
                        int32_t var_40_1 = *var_28_1;
                        int32_t var_164_1 = var_40_1;
                        
                        if ((var_164_1 & 1) == 0)
                        {
                            int32_t var_16c_1 = ((var_40_1 >> 4) - 1);
                            
                            if (var_16c_1 > 0x3f)
                                var_16c_1 = 0x3f;
                            
                            *(&var_15c + (var_16c_1 << 2)) += 1;
                        }
                        else
                        {
                            var_40_1 -= 1;
                            
                            if (var_40_1 > 0x400)
                                return 0xfffffffa;
                            
                            var_18_1 += 1;
                        }
                        
                        if (((var_40_1 < 0x10 || (var_40_1 & 0xf) != 0) || var_40_1 > 0xff0))
                            return 0xfffffff9;
                        
                        if (*((var_28_1 + var_40_1) - 4) != var_164_1)
                            return 0xfffffff8;
                        
                        var_28_1 += var_40_1;
                    } while (var_28_1 < ecx_10);
                    
                    if (var_28_1 != ecx_10)
                        return 0xfffffff8;
                    
                    var_2c_1 += 0x1000;
                }
                
                if (*var_48_1 != var_18_1)
                    return 0xfffffff7;
                
                int32_t* var_44_1 = var_48_1;
                int32_t j_2 = 0;
                
                while (j_2 < 0x40)
                {
                    int32_t var_58_1 = 0;
                    int32_t* var_28_2 = var_44_1;
                    
                    while (true)
                    {
                        int32_t* eax_20 = var_28_2[1];
                        
                        if (eax_20 == var_44_1)
                            break;
                        
                        if (var_58_1 == *(&var_15c + (j_2 << 2)))
                            break;
                        
                        if ((eax_20 < var_14_1 || eax_20 >= (var_14_1 + 0x8000)))
                            return 0xfffffff6;
                        
                        void* k = ((eax_20 & 0xfffff000) + 0xc);
                        void* edx_25;
                        
                        for (edx_25 = (k + 0xff0); k != edx_25; k += (*k & 0xfffffffe))
                        {
                            if (k == eax_20)
                                break;
                        }
                        
                        if (k == edx_25)
                            return 0xfffffff5;
                        
                        int32_t var_16c_2 = ((*eax_20 >> 4) - 1);
                        
                        if (var_16c_2 > 0x3f)
                            var_16c_2 = 0x3f;
                        
                        if (var_16c_2 != j_2)
                            return 0xfffffff4;
                        
                        if (eax_20[2] != var_28_2)
                            return 0xfffffff3;
                        
                        var_28_2 = eax_20;
                        var_58_1 += 1;
                    }
                    
                    if (var_58_1 != 0)
                    {
                        if (j_2 >= 0x20)
                        {
                            var_8_1 |= (0x80000000 >> (j_2 - 0x20));
                            var_54_1 |= (0x80000000 >> (j_2 - 0x20));
                        }
                        else
                        {
                            var_10_1 |= (0x80000000 >> j_2);
                            var_38_1 |= (0x80000000 >> j_2);
                        }
                    }
                    
                    if ((var_28_2[1] != var_44_1 || var_58_1 != *(&var_15c + (j_2 << 2))))
                        return 0xfffffff2;
                    
                    if (var_44_1[2] != var_28_2)
                        return 0xfffffff1;
                    
                    var_44_1 = &var_44_1[2];
                    j_2 += 1;
                    continue;
                }
            }
            
            if ((var_10_1 != *((ecx_3 + (i << 2)) + 0x44) || var_8_1 != *((ecx_3 + (i << 2)) + 0xc4)))
                return 0xfffffff0;
            
            var_14_1 += 0x8000;
            var_48_1 = &var_48_1[0x81];
            var_160_1 <<= 1;
            i += 1;
        }
        
        if ((var_38_1 != *var_3c_1 || var_54_1 != *(var_3c_1 + 4)))
            return 0xffffffef;
        
        var_3c_1 += 0x14;
        var_170_1 += 1;
    }
    
    return 0xfffffffe;
}

void* sub_100219d0()
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x10042018 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_34 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void* eax_2 = __getptd();
    void* result;
    
    if (((*(eax_2 + 0x70) & data_10044b34) == 0 || *(eax_2 + 0x6c) == 0))
    {
        __lock(0xd);
        int32_t var_8_1 = 0;
        result = *(eax_2 + 0x68);
        
        if (result != data_10044a38)
        {
            if ((result != 0 && (InterlockedDecrement(result) == 0 && result != 0x10044610)))
                sub_10011340(result, 2);
            
            *(eax_2 + 0x68) = data_10044a38;
            result = data_10044a38;
            InterlockedIncrement(result);
        }
        
        int32_t var_8_2 = 0xfffffffe;
        sub_10021aa1();
    }
    else
        result = *(eax_2 + 0x68);
    
    if (result == 0)
        sub_10015620(0x20);
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10021aa1()
{
    return __unlock(0xd);
}

int32_t sub_10021ae0(uint32_t arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_38 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x10042038 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_3c = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result = 0xffffffff;
    void* eax_2 = __getptd();
    sub_100219d0();
    void* ecx = *(eax_2 + 0x68);
    uint32_t eax_4 = sub_10021d80(arg1);
    
    if (eax_4 == *(ecx + 4))
        result = 0;
    else
    {
        void* eax_6 = __malloc_dbg(0x220, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x251);
        
        if (eax_6 != 0)
        {
            __builtin_memcpy(eax_6, *(eax_2 + 0x68), 0x88);
            *eax_6 = 0;
            result = sub_10021e90(eax_4, eax_6);
            
            if (result == 0)
            {
                if ((InterlockedDecrement(*(eax_2 + 0x68)) == 0 && *(eax_2 + 0x68) != 0x10044610))
                    sub_10011340(*(eax_2 + 0x68), 2);
                
                *(eax_2 + 0x68) = eax_6;
                InterlockedIncrement(*(eax_2 + 0x68));
                
                if (((*(eax_2 + 0x70) & 2) == 0 && (data_10044b34 & 1) == 0))
                {
                    __lock(0xd);
                    int32_t var_8_1 = 0;
                    data_10045c9c = *(eax_6 + 4);
                    data_10045ca0 = *(eax_6 + 8);
                    data_10045ca4 = *(eax_6 + 0xc);
                    
                    for (void* i = nullptr; i < 5; i += 1)
                    {
                        void* edx_10;
                        edx_10 = *((eax_6 + (i << 1)) + 0x10);
                        *((i << 1) + &data_10045c90) = edx_10;
                    }
                    
                    for (void* i_1 = nullptr; i_1 < 0x101; i_1 += 1)
                    {
                        void* eax_15;
                        eax_15 = *((eax_6 + i_1) + 0x1c);
                        *(i_1 + 0x10044830) = eax_15;
                    }
                    
                    for (void* i_2 = nullptr; i_2 < 0x100; i_2 += 1)
                    {
                        void* ecx_9;
                        ecx_9 = *((eax_6 + i_2) + 0x11d);
                        *(i_2 + 0x10044938) = ecx_9;
                    }
                    
                    if ((InterlockedDecrement(data_10044a38) == 0 && data_10044a38 != 0x10044610))
                        sub_10011340(data_10044a38, 2);
                    
                    data_10044a38 = eax_6;
                    InterlockedIncrement(eax_6);
                    int32_t var_8_2 = 0xfffffffe;
                    sub_10021d1e();
                }
            }
            else if (result == 0xffffffff)
            {
                if (eax_6 != 0x10044610)
                    sub_10011340(eax_6, 2);
                
                *sub_1000eca0() = 0x16;
            }
        }
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10021d1e()
{
    return __unlock(0xd);
}

uint32_t sub_10021d80(uint32_t arg1)
{
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = sub_100345a8;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_ebp;
    int32_t var_38 = (__security_cookie ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void var_24;
    _LocaleUpdate::_LocaleUpdate(&var_24, nullptr);
    int32_t var_8_1 = 0;
    data_10045c8c = 0;
    uint32_t result;
    
    if (arg1 == 0xfffffffe)
    {
        data_10045c8c = 1;
        uint32_t result_1 = GetOEMCP();
        int32_t var_8_2 = 0xffffffff;
        _LocaleUpdate::~_LocaleUpdate(&var_24);
        result = result_1;
    }
    else if (arg1 == 0xfffffffd)
    {
        data_10045c8c = 1;
        uint32_t result_2 = GetACP();
        int32_t var_8_3 = 0xffffffff;
        _LocaleUpdate::~_LocaleUpdate(&var_24);
        result = result_2;
    }
    else if (arg1 != 0xfffffffc)
    {
        int32_t var_8_5 = 0xffffffff;
        _LocaleUpdate::~_LocaleUpdate(&var_24);
        result = arg1;
    }
    else
    {
        data_10045c8c = 1;
        uint32_t result_3 = *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_24) + 4);
        int32_t var_8_4 = 0xffffffff;
        _LocaleUpdate::~_LocaleUpdate(&var_24);
        result = result_3;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10021e90(uint32_t arg1, void* arg2)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    uint32_t CodePage = sub_10021d80(arg1);
    
    if (CodePage != 0)
    {
        int32_t var_c_1 = 0;
        
        while (true)
        {
            if (var_c_1 >= 5)
            {
                int32_t lpCPInfo;
                
                if (((CodePage != 0 && (CodePage != 0xfde8 && CodePage != 0xfde9)) && IsValidCodePage(CodePage) != 0))
                {
                    if (GetCPInfo(CodePage, &lpCPInfo) != 0)
                    {
                        for (int32_t i = 0; i < 0x101; i += 1)
                            *((arg2 + i) + 0x1c) = 0;
                        
                        *(arg2 + 4) = CodePage;
                        *(arg2 + 0xc) = 0;
                        
                        if (lpCPInfo <= 1)
                            *(arg2 + 8) = 0;
                        else
                        {
                            void var_26;
                            void* var_30_1 = &var_26;
                            
                            while (*var_30_1 != 0)
                            {
                                if (*(var_30_1 + 1) == 0)
                                    break;
                                
                                for (uint32_t i_1 = *var_30_1; i_1 <= *(var_30_1 + 1); i_1 += 1)
                                    *((arg2 + i_1) + 0x1d) |= 4;
                                
                                var_30_1 += 2;
                            }
                            
                            for (int32_t i_2 = 1; i_2 < 0xff; i_2 += 1)
                                *((arg2 + i_2) + 0x1d) |= 8;
                            
                            *(arg2 + 0xc) = sub_100221e0(*(arg2 + 4));
                            *(arg2 + 8) = 1;
                        }
                        
                        for (int32_t i_3 = 0; i_3 < 6; i_3 += 1)
                            *((arg2 + (i_3 << 1)) + 0x10) = 0;
                        
                        sub_10022340(arg2);
                    }
                    else if (data_10045c8c != 0)
                        setSBCS(arg2);
                }
                break;
            }
            
            if (*((var_c_1 * 0x30) + 0x10044a40) == CodePage)
            {
                for (int32_t i_4 = 0; i_4 < 0x101; i_4 += 1)
                    *((arg2 + i_4) + 0x1c) = 0;
                
                for (void* i_5 = nullptr; i_5 < 4; i_5 += 1)
                {
                    char* var_10_1 = (((var_c_1 * 0x30) + (i_5 << 3)) + 0x10044a50);
                    
                    while (*var_10_1 != 0)
                    {
                        if (var_10_1[1] == 0)
                            break;
                        
                        for (uint32_t j = *var_10_1; j <= var_10_1[1]; j += 1)
                            *((arg2 + j) + 0x1d) |= *(i_5 + 0x10044a3c);
                        
                        var_10_1 = &var_10_1[2];
                    }
                }
                
                *(arg2 + 4) = CodePage;
                *(arg2 + 8) = 1;
                *(arg2 + 0xc) = sub_100221e0(*(arg2 + 4));
                
                for (int32_t i_6 = 0; i_6 < 6; i_6 += 1)
                {
                    int32_t eax_20;
                    eax_20 = *(((var_c_1 * 0x30) + (i_6 << 1)) + 0x10044a44);
                    *((arg2 + (i_6 << 1)) + 0x10) = eax_20;
                }
                
                sub_10022340(arg2);
                break;
            }
            
            var_c_1 += 1;
        }
    }
    else
        setSBCS(arg2);
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t sub_100221e0(int32_t arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if ((arg1 - 0x3a4) <= 0x12)
        switch (arg1)
        {
            case 0x3a4:
            {
                return 0x411;
                break;
            }
            case 0x3a8:
            {
                return 0x804;
                break;
            }
            case 0x3b5:
            {
                return 0x412;
                break;
            }
            case 0x3b6:
            {
                return 0x404;
                break;
            }
        }
    
    return 0;
}

void* setSBCS(void* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    for (int32_t i = 0; i < 0x101; i += 1)
        *((arg1 + i) + 0x1c) = 0;
    
    *(arg1 + 4) = 0;
    void* result = arg1;
    *(result + 8) = 0;
    *(arg1 + 0xc) = 0;
    
    for (void* i_1 = nullptr; i_1 < 6; i_1 += 1)
    {
        result = nullptr;
        *((arg1 + (i_1 << 1)) + 0x10) = 0;
    }
    
    for (void* i_2 = nullptr; i_2 < 0x101; i_2 = result)
    {
        result = *(i_2 + 0x1004462c);
        *((arg1 + i_2) + 0x1c) = result;
        result = (i_2 + 1);
    }
    
    for (void* i_3 = nullptr; i_3 < 0x100; i_3 += 1)
    {
        result = i_3;
        void* ecx_3;
        ecx_3 = *(result + 0x1004472d);
        *((arg1 + i_3) + 0x11d) = ecx_3;
    }
    
    return result;
}

int32_t sub_10022340(void* arg1)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    void lpCPInfo;
    
    if (GetCPInfo(*(arg1 + 4), &lpCPInfo) == 0)
    {
        for (int32_t i = 0; i < 0x100; i += 1)
        {
            if ((i >= 0x41 && i <= 0x5a))
            {
                *((arg1 + i) + 0x1d) |= 0x10;
                *((arg1 + i) + 0x11d) = (i + 0x20);
            }
            else if ((i < 0x61 || i > 0x7a))
                *((arg1 + i) + 0x11d) = 0;
            else
            {
                *((arg1 + i) + 0x1d) |= 0x20;
                *((arg1 + i) + 0x11d) = (i - 0x20);
            }
        }
    }
    else
    {
        uint8_t var_514;
        
        for (int32_t i_1 = 0; i_1 < 0x100; i_1 += 1)
            &var_514[i_1] = i_1;
        
        var_514 = 0x20;
        void var_526;
        void* var_410_1 = &var_526;
        
        while (*var_410_1 != 0)
        {
            for (uint32_t i_2 = *var_410_1; i_2 <= *(var_410_1 + 1); i_2 += 1)
                &var_514[i_2] = 0x20;
            
            var_410_1 += 2;
        }
        
        void var_20c;
        sub_1002c300(nullptr, 1, &var_514, 0x100, &var_20c, *(arg1 + 4), *(arg1 + 0xc), 0);
        void var_30c;
        sub_1002bcb0(nullptr, *(arg1 + 0xc), 0x100, &var_514, 0x100, &var_30c, 0x100, *(arg1 + 4), 0);
        void var_40c;
        sub_1002bcb0(nullptr, *(arg1 + 0xc), 0x200, &var_514, 0x100, &var_40c, 0x100, *(arg1 + 4), 0);
        
        for (int32_t i_3 = 0; i_3 < 0x100; i_3 += 1)
        {
            if ((*(&var_20c + (i_3 << 1)) & 1) != 0)
            {
                *((arg1 + i_3) + 0x1d) |= 0x10;
                void* eax_15;
                eax_15 = *(&var_30c + i_3);
                *((arg1 + i_3) + 0x11d) = eax_15;
            }
            else if ((*(&var_20c + (i_3 << 1)) & 2) == 0)
                *((arg1 + i_3) + 0x11d) = 0;
            else
            {
                *((arg1 + i_3) + 0x1d) |= 0x20;
                void* edx_17;
                edx_17 = *(&var_40c + i_3);
                *((arg1 + i_3) + 0x11d) = edx_17;
            }
        }
    }
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t ___initmbctable()
{
    if (data_1004a394 == 0)
    {
        sub_10021ae0(0xfffffffd);
        data_1004a394 = 1;
    }
    
    return 0;
}

int32_t sub_100226b0(void* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if ((*(arg1 + 0xbc) != 0 && (*(arg1 + 0xbc) != 0x10044ef0 && (*(arg1 + 0xb0) != 0 && **(arg1 + 0xb0) == 0))))
    {
        if ((*(arg1 + 0xb8) != 0 && **(arg1 + 0xb8) == 0))
        {
            sub_10011340(*(arg1 + 0xb8), 2);
            sub_1002d860(*(arg1 + 0xbc));
        }
        
        if ((*(arg1 + 0xb4) != 0 && **(arg1 + 0xb4) == 0))
        {
            sub_10011340(*(arg1 + 0xb4), 2);
            sub_1002d370(*(arg1 + 0xbc));
        }
        
        sub_10011340(*(arg1 + 0xb0), 2);
        sub_10011340(*(arg1 + 0xbc), 2);
    }
    
    if ((*(arg1 + 0xc0) != 0 && **(arg1 + 0xc0) == 0))
    {
        sub_10011340((*(arg1 + 0xc4) - 0xfe), 2);
        sub_10011340((*(arg1 + 0xcc) - 0x80), 2);
        sub_10011340((*(arg1 + 0xd0) - 0x80), 2);
        sub_10011340(*(arg1 + 0xc0), 2);
    }
    
    if ((*(arg1 + 0xd4) != 0x10044e30 && *(*(arg1 + 0xd4) + 0xb4) == 0))
    {
        sub_1002cd00(*(arg1 + 0xd4));
        sub_10011340(*(arg1 + 0xd4), 2);
    }
    
    for (int32_t i = 0; i <= 5; i += 1)
    {
        if ((*((arg1 + (i << 4)) + 0x48) != &data_10044b38 && (*((arg1 + (i << 4)) + 0x50) != 0 && **((arg1 + (i << 4)) + 0x50) == 0)))
            sub_10011340(*((arg1 + (i << 4)) + 0x50), 2);
        
        if ((((*((arg1 + (i << 4)) + 0x4c) == 0 || *((arg1 + (i << 4)) + 0x54) == 0) && (*((arg1 + (i << 4)) + 0x4c) != 0 || *((arg1 + (i << 4)) + 0x54) != 0)) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xca, nullptr, u"((ptloci->lc_category[category].…") == 1))
            breakpoint();
        
        if ((*((arg1 + (i << 4)) + 0x4c) != 0 && (*((arg1 + (i << 4)) + 0x54) != 0 && **((arg1 + (i << 4)) + 0x54) == 0)))
            sub_10011340(*((arg1 + (i << 4)) + 0x54), 2);
    }
    
    return sub_10011340(arg1, 2);
}

int32_t sub_10022990(void* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    InterlockedIncrement(arg1);
    
    if (*(arg1 + 0xb0) != 0)
        InterlockedIncrement(*(arg1 + 0xb0));
    
    if (*(arg1 + 0xb8) != 0)
        InterlockedIncrement(*(arg1 + 0xb8));
    
    if (*(arg1 + 0xb4) != 0)
        InterlockedIncrement(*(arg1 + 0xb4));
    
    if (*(arg1 + 0xc0) != 0)
        InterlockedIncrement(*(arg1 + 0xc0));
    
    for (int32_t i = 0; i <= 5; i += 1)
    {
        if ((*((arg1 + (i << 4)) + 0x48) != &data_10044b38 && *((arg1 + (i << 4)) + 0x50) != 0))
            InterlockedIncrement(*((arg1 + (i << 4)) + 0x50));
        
        if ((*((arg1 + (i << 4)) + 0x4c) != 0 && *((arg1 + (i << 4)) + 0x54) != 0))
            InterlockedIncrement(*((arg1 + (i << 4)) + 0x54));
    }
    
    return InterlockedIncrement((*(arg1 + 0xd4) + 0xb4));
}

void* sub_10022ab0(void* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if (arg1 != 0)
    {
        InterlockedDecrement(arg1);
        
        if (*(arg1 + 0xb0) != 0)
            InterlockedDecrement(*(arg1 + 0xb0));
        
        if (*(arg1 + 0xb8) != 0)
            InterlockedDecrement(*(arg1 + 0xb8));
        
        if (*(arg1 + 0xb4) != 0)
            InterlockedDecrement(*(arg1 + 0xb4));
        
        if (*(arg1 + 0xc0) != 0)
            InterlockedDecrement(*(arg1 + 0xc0));
        
        for (int32_t i = 0; i <= 5; i += 1)
        {
            if ((*((arg1 + (i << 4)) + 0x48) != &data_10044b38 && *((arg1 + (i << 4)) + 0x50) != 0))
                InterlockedDecrement(*((arg1 + (i << 4)) + 0x50));
            
            if ((*((arg1 + (i << 4)) + 0x4c) != 0 && *((arg1 + (i << 4)) + 0x54) != 0))
                InterlockedDecrement(*((arg1 + (i << 4)) + 0x54));
        }
        
        InterlockedDecrement((*(arg1 + 0xd4) + 0xb4));
    }
    
    return arg1;
}

void* sub_10022be0()
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x10042080 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_34 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void* eax_2 = __getptd();
    void* result;
    
    if (((*(eax_2 + 0x70) & data_10044b34) == 0 || *(eax_2 + 0x6c) == 0))
    {
        __lock(0xc);
        int32_t var_8_1 = 0;
        result = __updatetlocinfoEx_nolock((eax_2 + 0x6c), data_10044c18);
        int32_t var_8_2 = 0xfffffffe;
        sub_10022c68();
    }
    else
        result = *(__getptd() + 0x6c);
    
    if (result == 0)
        sub_10015620(0x20);
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10022c68()
{
    return __unlock(0xc);
}

void* __updatetlocinfoEx_nolock(int32_t* arg1, void* arg2)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if ((arg2 == 0 || arg1 == 0))
        return nullptr;
    
    int32_t* ecx_1 = *arg1;
    
    if (ecx_1 != arg2)
    {
        *arg1 = arg2;
        sub_10022990(arg2);
        
        if (ecx_1 != 0)
            sub_10022ab0(ecx_1);
        
        if ((ecx_1 != 0 && (*ecx_1 == 0 && ecx_1 != 0x10044b40)))
            sub_100226b0(ecx_1);
    }
    
    return arg2;
}

int32_t sub_10022d30()
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x100420a0;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_28 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t result = (__security_cookie_1 ^ &__saved_ebp);
    int32_t result_1 = result;
    fsbase->NtTib.ExceptionList = &ExceptionList;
    
    if (data_10044c18 != 0x10044b40)
    {
        __lock(0xc);
        int32_t var_8_1 = 0;
        data_10044c18 = __updatetlocinfoEx_nolock(&data_10044c18, &data_10044b40);
        int32_t var_8_2 = 0xfffffffe;
        result = sub_10022da4();
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10022da4()
{
    return __unlock(0xc);
}

void sub_10022dd0(int32_t* arg1, int32_t arg2)
{
    int32_t edi;
    int32_t var_c = edi;
    
    if ((arg2 != 0 && (arg1 != 0 && arg1 != arg2)))
    {
        __builtin_memcpy(arg1, arg2, 0x36);
        *arg1 = 0;
        sub_10022990(arg1);
    }
}

int32_t sub_10022e20(int32_t arg1, int32_t* arg2)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x100420c0;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_3c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result_1 = 0;
    int32_t var_20 = 0;
    int32_t var_30;
    
    if ((arg1 < 0 || arg1 > 5))
        var_30 = 0;
    else
        var_30 = 1;
    
    if ((var_30 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x32d, nullptr, u"LC_MIN <= _category && _category…") == 1))
        breakpoint();
    
    int32_t result;
    
    if (var_30 != 0)
    {
        void* eax_5 = __getptd();
        sub_10022be0();
        *(eax_5 + 0x70) |= 0x10;
        int32_t var_8_1 = 0;
        void* eax_8 = sub_10010b10(0xd8, 1, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x338);
        int32_t __saved_ebp;
        
        if (eax_8 != 0)
        {
            __lock(0xc);
            int32_t var_8_2 = 1;
            sub_10022dd0(eax_8, *(eax_5 + 0x6c));
            int32_t var_8_3 = 0;
            sub_10022f5c();
            
            if (eax_8 != 0)
                result_1 = sub_10023120(eax_8, arg1, arg2);
            
            if ((eax_8 == 0 || result_1 == 0))
            {
                sub_10022ab0(eax_8);
                sub_100226b0(eax_8);
            }
            else
            {
                if ((arg2 != 0 && sub_10013c00(arg2, &data_10044b38) != 0))
                    data_10045ca8 = 1;
                
                __lock(0xc);
                int32_t var_8_4 = 2;
                __updatetlocinfoEx_nolock((eax_5 + 0x6c), eax_8);
                sub_10022ab0(eax_8);
                
                if (((*(eax_5 + 0x70) & 2) == 0 && (data_10044b34 & 1) == 0))
                {
                    __updatetlocinfoEx_nolock(&data_10044c18, *(eax_5 + 0x6c));
                    sub_10013c90(&data_10045cac, (data_10044c18 + 0xc), 0x18, (__security_cookie_1 ^ &__saved_ebp));
                    sub_100230a0();
                }
                
                int32_t var_8_5 = 0;
                sub_1002303d();
            }
        }
        
        int32_t var_8_6 = 0xfffffffe;
        sub_10023070(&__saved_ebp);
        result = result_1;
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"LC_MIN <= _category && _category…", u"setlocale", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x32d, 0);
        result = 0;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10022f5c()
{
    return __unlock(0xc);
}

int32_t sub_1002303d()
{
    return __unlock(0xc);
}

int32_t sub_10023070(void* arg1 @ ebp)
{
    int32_t result = (*(*(arg1 - 0x24) + 0x70) & 0xffffffef);
    *(*(arg1 - 0x24) + 0x70) = result;
    return result;
}

void* sub_100230a0()
{
    data_10045cc4 = *(data_10044c18 + 4);
    data_10045cc8 = *(data_10044c18 + 8);
    data_10044c1c = *(data_10044c18 + 0xa8);
    data_10044ee8 = *(data_10044c18 + 0xd4);
    data_10044f20 = *(data_10044c18 + 0xbc);
    data_10044e24 = *(data_10044c18 + 0xc8);
    void* result = data_10044c18;
    data_10044f24 = *(result + 0xac);
    return result;
}

int32_t sub_10023120(void* arg1, int32_t arg2, char* arg3)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    void* var_8_1;
    
    if (arg2 == 0)
    {
        int32_t var_a0_1 = 1;
        int32_t var_9c_1 = 0;
        
        if (arg3 == 0)
            var_8_1 = sub_10023a40(arg1);
        else
        {
            void var_94;
            
            if (((*arg3 != 0x4c || arg3[1] != 0x43) || arg3[2] != 0x5f))
            {
                int32_t var_bc_6 = arg2;
                
                if (sub_10023d30(arg3, &var_94, 0x83, nullptr, nullptr) != 0)
                {
                    for (int32_t i = 0; i <= 5; i += 1)
                    {
                        if (i != 0)
                        {
                            if (sub_10013c00(&var_94, *((arg1 + (i << 4)) + 0x48)) == 0)
                                var_9c_1 += 1;
                            else if (sub_10023510(arg1, i, &var_94) == 0)
                                var_a0_1 = 0;
                            else
                                var_9c_1 += 1;
                        }
                    }
                    
                    if (var_a0_1 == 0)
                    {
                        void* var_b8_1;
                        
                        if (var_9c_1 == 0)
                            var_b8_1 = nullptr;
                        else
                            var_b8_1 = sub_10023a40(arg1);
                        
                        var_8_1 = var_b8_1;
                    }
                    else
                        var_8_1 = sub_10023a40(arg1);
                }
            }
            else
            {
                char* var_a4_1 = arg3;
                
                while (true)
                {
                    void* eax_9 = sub_1002e570(var_a4_1, &data_1003b990);
                    
                    if (eax_9 == 0)
                        break;
                    
                    void* eax_11 = (eax_9 - var_a4_1);
                    
                    if (eax_9 == var_a4_1)
                        break;
                    
                    if (*eax_9 == 0x3b)
                        break;
                    
                    int32_t i_1;
                    
                    for (i_1 = 1; i_1 <= 5; i_1 += 1)
                    {
                        if ((sub_1002e3f0(&data_1003b570[(i_1 * 3)], var_a4_1, eax_11) == 0 && eax_11 == _strlen(&data_1003b570[(i_1 * 3)])))
                            break;
                    }
                    
                    int32_t eax_20 = sub_1002e3a0((eax_9 + 1), &data_1003b98c);
                    
                    if ((eax_20 == 0 && *(eax_9 + 1) != 0x3b))
                        break;
                    
                    if (i_1 <= 5)
                    {
                        sub_1000b4b0(sub_1002dfb0(&var_94, 0x83, (eax_9 + 1), eax_20), u"strncpy_s(lctemp, (sizeof(lctemp…", u"_setlocale_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3a6, 0);
                        *(&var_94 + eax_20) = 0;
                        
                        if (sub_10023510(arg1, i_1, &var_94) != 0)
                            var_9c_1 += 1;
                    }
                    
                    var_a4_1 = ((eax_9 + 1) + eax_20);
                    
                    if (*var_a4_1 != 0)
                        var_a4_1 = &var_a4_1[1];
                    
                    if (*var_a4_1 == 0)
                    {
                        void* var_b4_1;
                        
                        if (var_9c_1 == 0)
                            var_b4_1 = nullptr;
                        else
                            var_b4_1 = sub_10023a40(arg1);
                        
                        var_8_1 = var_b4_1;
                        break;
                    }
                }
            }
        }
    }
    else
    {
        void* var_b0_1;
        
        if (arg3 == 0)
            var_b0_1 = *((arg1 + (arg2 << 4)) + 0x48);
        else
            var_b0_1 = sub_10023510(arg1, arg2, arg3);
        
        var_8_1 = var_b0_1;
    }
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t sub_10023510(void* arg1, int32_t arg2, char* arg3)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    int32_t var_ac = 0;
    int32_t var_b0 = 0;
    void* eax_4 = (__getptd() + 0x1d0);
    int32_t var_bc = 5;
    int32_t var_1e4 = arg2;
    int32_t var_c4;
    int16_t var_b8;
    void var_94;
    
    if (sub_10023d30(arg3, &var_94, 0x83, &var_b8, &var_c4) != 0)
    {
        if (sub_10013c00(&var_94, *((arg1 + (arg2 << 4)) + 0x48)) != 0)
        {
            void* eax_12 = (_strlen(&var_94) + 5);
            void* eax_13 = __malloc_dbg(eax_12, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x400);
            
            if (eax_13 != 0)
            {
                int32_t ecx_5 = *((arg1 + (arg2 << 4)) + 0x48);
                int32_t ecx_6 = *((arg1 + (arg2 << 2)) + 0xc);
                void var_1d4;
                sub_10013c90(&var_1d4, ((arg1 + (arg2 * 6)) + 0x24), 6);
                int32_t ecx_8 = *(arg1 + 4);
                sub_1000b4b0(sub_10010280((eax_13 + 4), (eax_12 - 4), &var_94), u"strcpy_s(pch + sizeof(int), cch …", u"_setlocale_set_cat", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x40b, 0);
                *((arg1 + (arg2 << 4)) + 0x48) = (eax_13 + 4);
                *((arg1 + (arg2 << 2)) + 0xc) = var_b8;
                sub_10013c90(((arg1 + (arg2 * 6)) + 0x24), &var_b8, 6);
                int32_t i_1;
                int32_t var_1dc;
                int32_t var_1d8;
                
                if (arg2 == 2)
                {
                    *(arg1 + 4) = var_c4;
                    var_1dc = *((eax_4 + (var_bc << 3)) - 8);
                    var_1d8 = *((eax_4 + (var_bc << 3)) - 4);
                    int32_t i;
                    
                    for (i = 0; i < var_bc; i += 1)
                    {
                        if (*(arg1 + 4) == *(eax_4 + (i << 3)))
                        {
                            if (i != 0)
                            {
                                int32_t eax_33 = *((eax_4 + (i << 3)) + 4);
                                *eax_4 = *(eax_4 + (i << 3));
                                *(eax_4 + 4) = eax_33;
                                *(eax_4 + (i << 3)) = var_1dc;
                                *((eax_4 + (i << 3)) + 4) = var_1d8;
                            }
                            
                            break;
                        }
                        
                        int32_t ecx_22 = *(eax_4 + (i << 3));
                        int32_t edx_19 = *((eax_4 + (i << 3)) + 4);
                        *(eax_4 + (i << 3)) = var_1dc;
                        *((eax_4 + (i << 3)) + 4) = var_1d8;
                        var_1dc = ecx_22;
                        var_1d8 = edx_19;
                    }
                    
                    if (i == var_bc)
                    {
                        void var_1cc;
                        
                        if (sub_1002c300(nullptr, 1, &data_1003b5b8, 0x7f, &var_1cc, *(arg1 + 4), *(arg1 + 0x14), 1) == 0)
                            *(eax_4 + 4) = 0;
                        else
                        {
                            for (i_1 = 0; i_1 < 0x7f; i_1 += 1)
                                *(&var_1cc + (i_1 << 1)) &= 0x1ff;
                            
                            if (sub_10012a20(&var_1cc, data_10044b30, 0xfe) != 0)
                                *(eax_4 + 4) = 0;
                            else
                                *(eax_4 + 4) = 1;
                        }
                        
                        *eax_4 = *(arg1 + 4);
                    }
                    
                    *(arg1 + 0xa8) = *(eax_4 + 4);
                }
                
                if (arg2 == 1)
                    *(arg1 + 8) = var_c4;
                
                if (*((arg2 * 0xc) + 0x1003b578)(arg1, i_1, var_1dc, var_1d8) == 0)
                {
                    if ((ecx_5 != &data_10044b38 && InterlockedDecrement(*((arg1 + (arg2 << 4)) + 0x50)) == 0))
                    {
                        if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x464, nullptr, 0) == 1)
                            breakpoint();
                        
                        sub_10011340(*((arg1 + (arg2 << 4)) + 0x50), 2);
                        sub_10011340(*((arg1 + (arg2 << 4)) + 0x54), 2);
                        *((arg1 + (arg2 << 4)) + 0x4c) = 0;
                    }
                    
                    if (eax_13 != 0)
                        *eax_13 = 1;
                    
                    *((arg1 + (arg2 << 4)) + 0x50) = eax_13;
                    *((arg1 + (arg2 << 4)) + 0x48);
                }
                else
                {
                    *((arg1 + (arg2 << 4)) + 0x48) = ecx_5;
                    sub_10011340(eax_13, 2);
                    *((arg1 + (arg2 << 2)) + 0xc) = ecx_6;
                    *(arg1 + 4) = ecx_8;
                }
            }
        }
        else
            *((arg1 + (arg2 << 4)) + 0x48);
    }
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

void* sub_10023a40(void* arg1)
{
    int32_t var_1c = 1;
    int32_t var_c = 0;
    int32_t var_14 = 0;
    int32_t var_10 = 0;
    int32_t var_18 = 0;
    void* eax = __malloc_dbg(0x355, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x47d);
    
    if (eax == 0)
        return nullptr;
    
    *(eax + 4) = 0;
    *eax = 1;
    int32_t var_8_1 = 1;
    
    while (true)
    {
        int32_t var_20_1 = *((arg1 + (var_8_1 << 4)) + 0x48);
        void* const var_24_1 = &data_1003ba88;
        int32_t var_28_1 = &data_1003b570[(var_8_1 * 3)];
        __wcscats((eax + 4), 0x351, 3);
        
        if (var_8_1 >= 5)
            break;
        
        sub_1000b4b0(sub_100254b0((eax + 4), 0x351, &data_1003b98c), u"strcat_s(pch, cch, ";")", u"_setlocale_get_all", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x48a, 0);
        
        if (sub_10013c00(*((arg1 + (var_8_1 << 4)) + 0x48), *((arg1 + ((var_8_1 + 1) << 4)) + 0x48)) != 0)
            var_1c = 0;
        
        var_8_1 += 1;
    }
    
    if (var_1c == 0)
    {
        if ((*(arg1 + 0x50) != 0 && InterlockedDecrement(*(arg1 + 0x50)) == 0))
        {
            if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x493, nullptr, 0) == 1)
                breakpoint();
            
            sub_10011340(*(arg1 + 0x50), 2);
        }
        
        if ((*(arg1 + 0x54) != 0 && InterlockedDecrement(*(arg1 + 0x54)) == 0))
        {
            if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x498, nullptr, 0) == 1)
                breakpoint();
            
            sub_10011340(*(arg1 + 0x54), 2);
        }
        
        *(arg1 + 0x54) = 0;
        *(arg1 + 0x4c) = 0;
        *(arg1 + 0x50) = eax;
        *(arg1 + 0x48) = (eax + 4);
        return (eax + 4);
    }
    
    sub_10011340(eax, 2);
    
    if ((*(arg1 + 0x50) != 0 && InterlockedDecrement(*(arg1 + 0x50)) == 0))
    {
        if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x4a3, nullptr, 0) == 1)
            breakpoint();
        
        sub_10011340(*(arg1 + 0x50), 2);
    }
    
    if ((*(arg1 + 0x54) != 0 && InterlockedDecrement(*(arg1 + 0x54)) == 0))
    {
        if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x4a8, nullptr, 0) == 1)
            breakpoint();
        
        sub_10011340(*(arg1 + 0x54), 2);
    }
    
    *(arg1 + 0x54) = 0;
    *(arg1 + 0x4c) = 0;
    *(arg1 + 0x50) = 0;
    *(arg1 + 0x48) = 0;
    return *(arg1 + 0x68);
}

int32_t sub_10023d30(char* arg1, char* arg2, void* arg3, int128_t* arg4, int32_t* arg5)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    void* eax_3 = (__getptd() + 0x9c);
    void* var_1c = 0x83;
    void* var_c = 0x83;
    int32_t var_24 = 0;
    
    if ((arg1 != 0 && (arg2 != 0 && arg3 != 0)))
    {
        if ((*arg1 != 0x43 || arg1[1] != 0))
        {
            void* eax_15 = _strlen(arg1);
            char* var_c4;
            void* var_c0;
            
            if (eax_15 >= 0x83)
            {
            label_10023e76:
                int32_t var_c4_1 = 0;
                var_c0 = nullptr;
                void var_bc;
                
                if ((sub_10024060(&var_bc, arg1) == 0 && sub_1002e5b0(&var_bc, (eax_3 + 0x20), &var_bc) != 0))
                {
                    *(eax_3 + 0x28) = *(eax_3 + 0x24);
                    sub_10024260((eax_3 + 0xaf), var_c, &var_bc);
                    
                    if ((*arg1 == 0 || eax_15 >= 0x83))
                        var_c4 = &data_10040802;
                    else
                    {
                        var_c4 = arg1;
                        var_c0 = eax_15;
                    }
                    
                    sub_1000b4b0(sub_1002dfb0((eax_3 + 0x2c), var_1c, var_c4, (var_c0 + 1)), u"strncpy_s(cachein, cacheinSize, …", u"_expandlocale", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x503, 0);
                    goto label_10023f65;
                }
            }
            else
            {
                if (sub_10013c00((eax_3 + 0xaf), arg1) != 0)
                {
                    if (sub_10013c00((eax_3 + 0x2c), arg1) == 0)
                        goto label_10023f65;
                    
                    goto label_10023e76;
                }
                
            label_10023f65:
                
                if (arg4 != 0)
                    sub_10013c90(arg4, (eax_3 + 0x20), 6, var_c4, var_c0);
                
                if (arg5 != 0)
                    sub_10013c90(arg5, (eax_3 + 0x28), 4, var_c4, var_c0);
                
                sub_1000b4b0(sub_10010280(arg2, arg3, (eax_3 + 0xaf)), u"strcpy_s(output, sizeInChars, ca…", u"_expandlocale", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x50c, 0);
            }
        }
        else
        {
            sub_1000b4b0(sub_10010280(arg2, arg3, &data_1003bb60), u"strcpy_s(output, sizeInChars, "C…", u"_expandlocale", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x4d3, 0);
            
            if (arg4 != 0)
            {
                *arg4 = 0;
                *(arg4 + 2) = 0;
                *(arg4 + 4) = 0;
            }
            
            if (arg5 != 0)
                *arg5 = 0;
        }
    }
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

void __wcscats(char* arg1, int32_t arg2, int32_t arg3)
{
    void* var_8 = &arg_10;
    
    for (int32_t i = 0; i < arg3; i += 1)
    {
        var_8 += 4;
        sub_1000b4b0(sub_100254b0(arg1, arg2, *(var_8 - 4)), u"strcat_s(outstr, sizeInBytes, ( …", u"_strcats", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x520, 0);
    }
    
    int32_t var_8_1 = 0;
}

int32_t sub_10024060(char* arg1, char* arg2)
{
    sub_1000fae0(arg1, 0, 0x90);
    
    if (*arg2 == 0)
        return 0;
    
    if ((*arg2 == 0x2e && arg2[1] != 0))
    {
        sub_1000b4b0(sub_1002dfb0(&arg1[0x80], 0x10, &arg2[1], 0xf), u"strncpy_s(names->szCodePage, (si…", u"__lc_strtolc", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x533, 0);
        arg1[0x8f] = 0;
        return 0;
    }
    
    int32_t var_8_1 = 0;
    
    while (true)
    {
        int32_t eax_6 = sub_1002e3a0(arg2, &data_1003bfb4);
        
        if (eax_6 == 0)
            break;
        
        char ecx_6 = arg2[eax_6];
        
        if (((var_8_1 == 0 && eax_6 < 0x40) && ecx_6 != 0x2e))
            sub_1000b4b0(sub_1002dfb0(arg1, 0x40, arg2, eax_6), u"strncpy_s(names->szLanguage, (si…", u"__lc_strtolc", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x541, 0);
        else if (((var_8_1 != 1 || eax_6 >= 0x40) || ecx_6 == 0x5f))
        {
            if (((var_8_1 != 2 || eax_6 >= 0x10) || (ecx_6 != 0 && ecx_6 != 0x2c)))
                return 0xffffffff;
            
            sub_1000b4b0(sub_1002dfb0(&arg1[0x80], 0x10, arg2, eax_6), u"strncpy_s(names->szCodePage, (si…", u"__lc_strtolc", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x547, 0);
        }
        else
            sub_1000b4b0(sub_1002dfb0(&arg1[0x40], 0x40, arg2, eax_6), u"strncpy_s(names->szCountry, (siz…", u"__lc_strtolc", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x544, 0);
        
        if ((ecx_6 == 0x2c || ecx_6 == 0))
            return 0;
        
        arg2 = &arg2[(eax_6 + 1)];
        var_8_1 += 1;
    }
    
    return 0xffffffff;
}

int32_t sub_10024260(char* arg1, void* arg2, char* arg3)
{
    sub_1000b4b0(sub_10010280(arg1, arg2, arg3), u"strcpy_s(locale, sizeInBytes, (c…", u"__lc_lctostr", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x55d, 0);
    
    if (arg3[0x40] != 0)
    {
        void* var_8_1 = &arg3[0x40];
        void* const var_c_1 = &data_1003c0b0;
        __wcscats(arg1, arg2, 2);
    }
    
    int32_t result = arg3[0x80];
    
    if (result == 0)
        return result;
    
    void* var_8_2 = &arg3[0x80];
    void* const var_c_2 = &data_1003c0ac;
    return __wcscats(arg1, arg2, 2);
}

int32_t sub_10024300(int32_t arg1, int32_t arg2)
{
    if (((arg1 + 1) > 0x100 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x38, nullptr, u"(unsigned)(c + 1) <= 256") == 1))
        breakpoint();
    
    return sub_10024350(nullptr, arg1, arg2);
}

int32_t sub_10024350(void** arg1, int32_t arg2, int32_t arg3)
{
    void var_14;
    _LocaleUpdate::_LocaleUpdate(&var_14, arg1);
    
    if (((arg2 + 1) > 0x100 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x44, nullptr, u"(unsigned)(c + 1) <= 256") == 1))
        breakpoint();
    
    if ((arg2 < 0xffffffff || arg2 > 0xff))
    {
        int32_t eax_9 = (*(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 0xc8) - 2) & arg3);
        _LocaleUpdate::~_LocaleUpdate(&var_14);
        return eax_9;
    }
    
    int32_t eax_5 = (*(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 0xc8) + (arg2 << 1)) & arg3);
    _LocaleUpdate::~_LocaleUpdate(&var_14);
    return eax_5;
}

void* sub_100243c9(int32_t* arg1 @ ebp)
{
    void* result = _LocaleUpdate::~_LocaleUpdate(&arg1[-4]);
    *arg1;
    return result;
}

int32_t sub_10024400(int32_t arg1, int32_t arg2, void** arg3)
{
    void var_1c;
    _LocaleUpdate::_LocaleUpdate(&var_1c, arg3);
    
    if ((arg1 >= 0xffffffff && arg1 <= 0xff))
    {
        int32_t ecx_4 = (*(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_1c) + 0xc8) + (arg1 << 1)) & arg2);
        _LocaleUpdate::~_LocaleUpdate(&var_1c);
        return ecx_4;
    }
    
    char var_20;
    uint16_t* var_c_1;
    
    if (sub_10027510((arg1 >> 8), _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_1c)) == 0)
    {
        var_20 = arg1;
        char var_1f_2 = 0;
        var_c_1 = 1;
    }
    else
    {
        var_20 = (arg1 >> 8);
        char var_1f_1 = arg1;
        char var_1e_1 = 0;
        var_c_1 = 2;
    }
    
    int32_t ecx_9 = *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_1c) + 0x14);
    uint32_t eax_12 = *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_1c) + 4);
    int16_t var_8;
    
    if (sub_1002c300(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_1c), 1, &var_20, var_c_1, &var_8, eax_12, ecx_9, 1) == 0)
    {
        _LocaleUpdate::~_LocaleUpdate(&var_1c);
        return 0;
    }
    
    int32_t ecx_14 = (var_8 & arg2);
    _LocaleUpdate::~_LocaleUpdate(&var_1c);
    return ecx_14;
}

int32_t sub_10024520(int16_t* arg1)
{
    if (*arg1 != 0x5a4d)
        return 0;
    
    void* ecx_2 = (arg1 + *(arg1 + 0x3c));
    
    if (*ecx_2 != 0x4550)
        return 0;
    
    if (*(ecx_2 + 0x18) == 0x10b)
        return 1;
    
    return 0;
}

void* sub_10024580(int32_t arg1, int32_t arg2)
{
    void* ecx_1 = (arg1 + *(arg1 + 0x3c));
    int32_t i = 0;
    void* result = ((ecx_1 + *(ecx_1 + 0x14)) + 0x18);
    
    while (i < *(ecx_1 + 6))
    {
        if ((arg2 >= *(result + 0xc) && arg2 < (*(result + 0xc) + *(result + 8))))
            return result;
        
        i += 1;
        result += 0x28;
    }
    
    return nullptr;
}

int32_t sub_10024600(int32_t arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x100420f8;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_48 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_4c = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_1c = &var_4c;
    int32_t var_20 = 0x10000000;
    int32_t var_8_1 = 0;
    int32_t result;
    
    if (sub_10024520(&__dos_header) != 0)
    {
        void* eax_4 = sub_10024580(var_20, (arg1 - var_20));
        
        if (eax_4 != 0)
        {
            int32_t edx_3 = (*(eax_4 + 0x24) & 0x80000000);
            int32_t edx_4 = -(edx_3);
            int32_t var_8_4 = 0xfffffffe;
            result = ((edx_4 - edx_4) + 1);
        }
        else
        {
            int32_t var_8_3 = 0xfffffffe;
            result = 0;
        }
    }
    else
    {
        int32_t var_8_2 = 0xfffffffe;
        result = 0;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_100246c9(void* arg1 @ ebp)
{
    *(arg1 - 0x28) = ***(arg1 - 0x14);
    int32_t result;
    result = *(arg1 - 0x28) == 0xc0000005;
    return result;
}

uint32_t sub_10024720(int16_t arg1, void** arg2)
{
    uint32_t result;
    
    if (arg1 != 0xffff)
    {
        void var_14;
        _LocaleUpdate::_LocaleUpdate(&var_14, arg2);
        
        if (*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 0x14) == 0)
        {
            int16_t var_28_1;
            
            if ((arg1 < 0x41 || arg1 > 0x5a))
                var_28_1 = arg1;
            else
                var_28_1 = (arg1 + 0x20);
            
            void* ecx_3;
            ecx_3 = var_28_1;
            _LocaleUpdate::~_LocaleUpdate(&var_14);
            result = ecx_3;
        }
        else if (arg1 >= 0x100)
        {
            int32_t ecx_12 = *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 4);
            uint32_t edx_6 = *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 0x14);
            int16_t var_18;
            
            if (sub_1002f450(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14), edx_6, 0x100, &arg1, 1, &var_18, 1, ecx_12) != 0)
            {
                int16_t ecx_16 = var_18;
                _LocaleUpdate::~_LocaleUpdate(&var_14);
                result = ecx_16;
            }
            else
            {
                int32_t eax_12;
                eax_12 = arg1;
                _LocaleUpdate::~_LocaleUpdate(&var_14);
                result = eax_12;
            }
        }
        else
        {
            void** eax_3 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14);
            
            if (sub_1002f540(arg1, 1, eax_3) != 0)
            {
                void* edx_5;
                edx_5 = *(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 0xcc) + arg1);
                _LocaleUpdate::~_LocaleUpdate(&var_14);
                result = edx_5;
            }
            else
            {
                int16_t ecx_6 = arg1;
                _LocaleUpdate::~_LocaleUpdate(&var_14);
                result = ecx_6;
            }
        }
    }
    else
        result = arg1;
    
    return result;
}

int32_t ___set_app_type(int32_t arg1)
{
    data_10045ccc = arg1;
    return arg1;
}

BOOL `eh vector constructor iterator'(CRITICAL_SECTION* arg1, uint32_t arg2)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10042118;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_34 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_1c = &var_34;
    int32_t var_8_1 = 0;
    BOOL result = InitializeCriticalSectionAndSpinCount(arg1, arg2);
    int32_t var_8_2 = 0xfffffffe;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_100248e6(void* arg1 @ ebp)
{
    *(arg1 - 0x20) = ***(arg1 - 0x14);
    int32_t result;
    result = *(arg1 - 0x20) == 0xc0000017;
    return result;
}

int32_t sub_100248ff(int32_t* arg1 @ ebp)
{
    int32_t* esp_2 = arg1[-6];
    
    if (arg1[-8] == 0xc0000017)
    {
        *(esp_2 - 4) = 8;
        SetLastError();
    }
    
    arg1[-7] = 0;
    arg1[-1] = 0xfffffffe;
    TEB* fsbase;
    fsbase->NtTib.ExceptionList = arg1[-4];
    *esp_2;
    esp_2[1];
    esp_2[2];
    esp_2[3];
    *arg1;
    return arg1[-7];
}

int32_t __FF_MSGBANNER()
{
    if (sub_1002f5f0(3) != 1)
    {
        int32_t result = sub_1002f5f0(3);
        
        if ((result != 0 || data_10045614 != 1))
            return result;
    }
    
    sub_10024990(0xfc);
    return sub_10024990(0xff);
}

void sub_10024990(int32_t arg1)
{
    HANDLE i;
    
    for (i = nullptr; i < 0x17; i += 1)
    {
        if (arg1 == *((i << 3) + &data_10044c28))
            break;
    }
    
    if (i < 0x17)
    {
        if (((arg1 != 0xfc && (arg1 != 0xff && arg1 != 0x1e)) && sub_1000ed60(1, nullptr, 0, nullptr, &data_10044c2c[(i * 2)]) == 1))
            breakpoint();
        
        int32_t eax_3 = sub_1002f5f0(3);
        HANDLE hFile;
        
        if (eax_3 != 1)
            hFile = sub_1002f5f0(3);
        
        if ((eax_3 == 1 || (hFile == 0 && data_10045614 == 1)))
        {
            hFile = GetStdHandle(STD_ERROR_HANDLE);
            
            if ((hFile != 0 && hFile != 0xffffffff))
            {
                uint32_t nNumberOfBytesToWrite = _strlen(&data_10044c2c[(i * 2)]);
                void lpNumberOfBytesWritten;
                WriteFile(hFile, &data_10044c2c[(i * 2)], nNumberOfBytesToWrite, &lpNumberOfBytesWritten, nullptr);
            }
        }
        else if (arg1 != 0xfc)
        {
            sub_1000b4b0(sub_10010280(&data_10045cd0, 0x314, "Runtime Error!\n\nProgram: "), u"strcpy_s(outmsg, (sizeof(outmsg)…", u"_NMSG_WRITE", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xe0, 0);
            data_10045ded = 0;
            
            if (GetModuleFileNameA(nullptr, &data_10045ce9, 0x104) == 0)
                sub_1000b4b0(sub_10010280(&data_10045ce9, 0x2fb, "<program name unknown>"), u"strcpy_s(progname, progname_size…", u"_NMSG_WRITE", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xe4, 0);
            
            if ((_strlen(&data_10045ce9) + 1) > 0x3c)
            {
                void* eax_13 = (_strlen(&data_10045ce9) + 0x10045cae);
                sub_1000b4b0(sub_1002dfb0(eax_13, (0x2fb - (eax_13 - 0x10045ce9)), &data_10037fc8, 3), u"strncpy_s(pch, progname_size - (…", u"_NMSG_WRITE", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xea, 0);
            }
            
            sub_1000b4b0(sub_100254b0(&data_10045cd0, 0x314, &data_1003815c), u"strcat_s(outmsg, (sizeof(outmsg)…", u"_NMSG_WRITE", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xed, 0);
            sub_1000b4b0(sub_100254b0(&data_10045cd0, 0x314, &data_10044c2c[(i * 2)]), u"strcat_s(outmsg, (sizeof(outmsg)…", u"_NMSG_WRITE", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xee, 0);
            sub_1001dba0(0x10045cd0, "Microsoft Visual C++ Runtime Lib…", 0x12010);
        }
    }
}

int128_t* sub_10024c30(int128_t* arg1, int128_t* arg2, void* arg3)
{
    int32_t eax_1;
    int32_t edx;
    edx = HIGHD(arg2);
    eax_1 = LOWD(arg2);
    int32_t ecx_5 = (((((eax_1 ^ edx) - edx) & 0xf) ^ edx) - edx);
    int128_t* eax_3;
    int32_t edx_1;
    edx_1 = HIGHD(arg1);
    eax_3 = LOWD(arg1);
    int32_t edi_5 = (((((eax_3 ^ edx_1) - edx_1) & 0xf) ^ edx_1) - edx_1);
    
    if ((ecx_5 | edi_5) != 0)
    {
        if (ecx_5 == edi_5)
        {
            __builtin_memcpy(arg1, arg2, (-(ecx_5) + 0x10));
            sub_10024c30((arg1 + (-(ecx_5) + 0x10)), (arg2 + (-(ecx_5) + 0x10)), (arg3 - (-(ecx_5) + 0x10)), (-(ecx_5) + 0x10));
            return arg1;
        }
        
        int32_t esi_5;
        int32_t edi_9;
        edi_9 = __builtin_memcpy(arg1, arg2, (arg3 >> 2));
        __builtin_memcpy(edi_9, esi_5, (arg3 & 3));
        return arg1;
    }
    
    void* n_1 = (arg3 & 0x7f);
    void* n = n_1;
    
    if (arg3 != n_1)
    {
        sub_10024d20(eax_3, arg2, (arg3 - n_1));
        eax_3 = arg1;
        n_1 = n;
    }
    
    if (n_1 == 0)
        return eax_3;
    
    __builtin_memcpy(((arg3 + eax_3) - n_1), ((arg2 + arg3) - n_1), n);
    return arg1;
}

int32_t sub_10024d20(int128_t* arg1, int128_t* arg2, int32_t arg3)
{
    int128_t* esi = arg2;
    int128_t* edi = arg1;
    uint32_t i_1 = (arg3 >> 7);
    uint32_t i;
    
    do
    {
        int128_t xmm1_1 = esi[1];
        int128_t xmm2_1 = esi[2];
        int128_t xmm3_1 = esi[3];
        *edi = *esi;
        edi[1] = xmm1_1;
        edi[2] = xmm2_1;
        edi[3] = xmm3_1;
        int128_t xmm5_1 = esi[5];
        int128_t xmm6_1 = esi[6];
        int128_t xmm7_1 = esi[7];
        edi[4] = esi[4];
        edi[5] = xmm5_1;
        edi[6] = xmm6_1;
        edi[7] = xmm7_1;
        esi = &esi[8];
        edi = &edi[8];
        i = i_1;
        i_1 -= 1;
    } while (i != 1);
}

int32_t sub_10024db0(int16_t* arg1, uint8_t* arg2, int32_t arg3, void** arg4)
{
    int32_t var_8 = 0;
    
    if ((arg1 != 0 && arg3 == 0))
        return 0;
    
    if ((arg1 != 0 && arg3 > 0))
        *arg1 = 0;
    
    int32_t edx_1;
    edx_1 = arg2 != 0;
    
    if ((edx_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x45, nullptr, u"s != NULL") == 1))
        breakpoint();
    
    if (edx_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"s != NULL", u"_mbstowcs_l_helper", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x45, 0);
        return 0xffffffff;
    }
    
    void var_18;
    _LocaleUpdate::_LocaleUpdate(&var_18, arg4);
    
    if (arg1 == 0)
    {
        if (*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_18) + 0x14) == 0)
        {
            void* eax_31 = _strlen(arg2);
            _LocaleUpdate::~_LocaleUpdate(&var_18);
            return eax_31;
        }
        
        int32_t eax_34 = MultiByteToWideChar(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_18) + 4), MB_ERR_INVALID_CHARS | MB_PRECOMPOSED, arg2, 0xffffffff, nullptr, 0);
        
        if (eax_34 != 0)
        {
            _LocaleUpdate::~_LocaleUpdate(&var_18);
            return (eax_34 - 1);
        }
        
        *sub_1000eca0() = 0x2a;
        _LocaleUpdate::~_LocaleUpdate(&var_18);
        return 0xffffffff;
    }
    
    if (*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_18) + 0x14) == 0)
    {
        while (true)
        {
            if (var_8 >= arg3)
            {
                _LocaleUpdate::~_LocaleUpdate(&var_18);
                return var_8;
            }
            
            int16_t* edx_2;
            edx_2 = arg2[var_8];
            *arg1 = edx_2;
            
            if (arg2[var_8] == 0)
                break;
            
            var_8 += 1;
            arg1 = &arg1[1];
        }
        
        _LocaleUpdate::~_LocaleUpdate(&var_18);
        return var_8;
    }
    
    int32_t eax_11 = MultiByteToWideChar(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_18) + 4), MB_ERR_INVALID_CHARS | MB_PRECOMPOSED, arg2, 0xffffffff, arg1, arg3);
    
    if (eax_11 != 0)
    {
        _LocaleUpdate::~_LocaleUpdate(&var_18);
        return (eax_11 - 1);
    }
    
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        *sub_1000eca0() = 0x2a;
        *arg1 = 0;
        _LocaleUpdate::~_LocaleUpdate(&var_18);
        return 0xffffffff;
    }
    
    int32_t var_24_1 = arg3;
    uint8_t* var_20_1 = arg2;
    
    while (true)
    {
        int32_t eax_17 = var_24_1;
        var_24_1 -= 1;
        
        if (eax_17 == 0)
            break;
        
        if (*var_20_1 == 0)
            break;
        
        void** eax_19 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_18);
        
        if (sub_10027510(*var_20_1, eax_19) != 0)
        {
            if (var_20_1[1] == 0)
            {
                *sub_1000eca0() = 0x2a;
                *arg1 = 0;
                _LocaleUpdate::~_LocaleUpdate(&var_18);
                return 0xffffffff;
            }
            
            var_20_1 = &var_20_1[1];
        }
        
        var_20_1 = &var_20_1[1];
    }
    
    int32_t eax_27 = MultiByteToWideChar(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_18) + 4), MB_PRECOMPOSED, arg2, (var_20_1 - arg2), arg1, arg3);
    
    if (eax_27 != 0)
    {
        _LocaleUpdate::~_LocaleUpdate(&var_18);
        return eax_27;
    }
    
    *sub_1000eca0() = 0x2a;
    *arg1 = 0;
    _LocaleUpdate::~_LocaleUpdate(&var_18);
    return 0xffffffff;
}

void* sub_10024ed5(int32_t* arg1 @ ebp)
{
    void* result = _LocaleUpdate::~_LocaleUpdate(&arg1[-5]);
    *arg1;
    return result;
}

int32_t sub_10025100(int32_t* arg1, int16_t* arg2, char* arg3, uint8_t* arg4, int32_t arg5, void** arg6)
{
    int32_t var_8 = 0;
    int32_t var_40;
    
    if (((arg2 != 0 || arg3 != 0) && (arg2 == 0 || arg3 <= 0)))
        var_40 = 0;
    else
        var_40 = 1;
    
    if ((var_40 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xf1, nullptr, u"(pwcs == NULL && sizeInWords == …") == 1))
        breakpoint();
    
    if (var_40 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(pwcs == NULL && sizeInWords == …", u"_mbstowcs_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xf1, 0);
        return 0x16;
    }
    
    if (arg2 != 0)
    {
        *arg2 = 0;
        
        if ((arg3 != 0xffffffff && (arg3 != 0x7fffffff && arg3 > 1)))
        {
            void* var_44_1;
            
            if (data_100441c4 >= (arg3 - 1))
                var_44_1 = (arg3 - 1);
            else
                var_44_1 = data_100441c4;
            
            sub_1000fae0(&arg2[1], 0xfe, (var_44_1 << 1));
        }
    }
    
    if (arg1 != 0)
        *arg1 = 0;
    
    void var_1c;
    int32_t ecx_7 = _LocaleUpdate::_LocaleUpdate(&var_1c, arg6);
    int32_t var_48_1;
    
    if (arg5 <= arg3)
    {
        ecx_7 = arg5;
        var_48_1 = ecx_7;
    }
    else
        var_48_1 = arg3;
    
    int32_t ecx_8 = (ecx_7 - ecx_7);
    
    if ((ecx_8 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x101, nullptr, u"bufferSize <= INT_MAX") == 1))
        breakpoint();
    
    if (ecx_8 == 0xffffffff)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"bufferSize <= INT_MAX", u"_mbstowcs_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x101, 0);
        _LocaleUpdate::~_LocaleUpdate(&var_1c);
        return 0x16;
    }
    
    int32_t eax_13 = sub_10024db0(arg2, arg4, var_48_1, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_1c));
    
    if (eax_13 == 0xffffffff)
    {
        if (arg2 != 0)
        {
            *arg2 = 0;
            
            if ((arg3 != 0xffffffff && (arg3 != 0x7fffffff && arg3 > 1)))
            {
                void* var_4c_1;
                
                if (data_100441c4 >= (arg3 - 1))
                    var_4c_1 = (arg3 - 1);
                else
                    var_4c_1 = data_100441c4;
                
                sub_1000fae0(&arg2[1], 0xfe, (var_4c_1 << 1));
            }
        }
        
        int32_t ecx_16 = *sub_1000eca0();
        _LocaleUpdate::~_LocaleUpdate(&var_1c);
        return ecx_16;
    }
    
    char* var_20_2 = (eax_13 + 1);
    
    if (arg2 != 0)
    {
        char* eax_18 = var_20_2;
        
        if (eax_18 > arg3)
        {
            if (arg5 != 0xffffffff)
            {
                *arg2 = 0;
                
                if ((arg3 != 0xffffffff && (arg3 != 0x7fffffff && arg3 > 1)))
                {
                    void* var_50_1;
                    
                    if (data_100441c4 >= (arg3 - 1))
                        var_50_1 = (arg3 - 1);
                    else
                        var_50_1 = data_100441c4;
                    
                    eax_18 = sub_1000fae0(&arg2[1], 0xfe, (var_50_1 << 1));
                }
                
                int32_t eax_23 = (eax_18 - eax_18);
                
                if ((eax_23 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x11b, nullptr, u"retsize <= sizeInWords") == 1))
                    breakpoint();
                
                if (eax_23 == 0xffffffff)
                {
                    *sub_1000eca0() = 0x22;
                    sub_1000c310(u"retsize <= sizeInWords", u"_mbstowcs_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x11b, 0);
                    _LocaleUpdate::~_LocaleUpdate(&var_1c);
                    return 0x22;
                }
            }
            
            var_20_2 = arg3;
            var_8 = 0x50;
        }
        
        arg2[&var_20_2[-1]] = 0;
    }
    
    if (arg1 != 0)
        *arg1 = var_20_2;
    
    _LocaleUpdate::~_LocaleUpdate(&var_1c);
    return var_8;
}

int32_t __Wcsftime(int32_t* arg1, int16_t* arg2, char* arg3, uint8_t* arg4, int32_t arg5)
{
    return sub_10025100(arg1, arg2, arg3, arg4, arg5, nullptr);
}

int32_t sub_100254b0(char* arg1, int32_t arg2, char* arg3)
{
    int32_t var_20;
    
    if ((arg1 == 0 || arg2 <= 0))
        var_20 = 0;
    else
        var_20 = 1;
    
    if ((var_20 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x12, nullptr, u"((_Dst)) != NULL && ((_SizeInByt…") == 1))
        breakpoint();
    
    if (var_20 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"((_Dst)) != NULL && ((_SizeInByt…", u"strcat_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x12, 0);
        return 0x16;
    }
    
    if (arg3 == 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            int32_t var_24_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_24_1 = (arg2 - 1);
            else
                var_24_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, var_24_1);
        }
        
        int32_t edx_4;
        edx_4 = arg3 != 0;
        
        if ((edx_4 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13, nullptr, u"(((_Src))) != NULL") == 1))
            breakpoint();
        
        if (edx_4 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(((_Src))) != NULL", u"strcat_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13, 0);
            return 0x16;
        }
    }
    
    char* var_8_1 = arg1;
    int32_t i;
    
    for (i = arg2; i > 0; i -= 1)
    {
        if (*var_8_1 == 0)
            break;
        
        var_8_1 = &var_8_1[1];
    }
    
    char* ecx_4;
    
    if (i == 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            int32_t var_28_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_28_1 = (arg2 - 1);
            else
                var_28_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, var_28_1);
        }
        
        int32_t var_2c_1 = 0;
        
        if (var_2c_1 == 0)
        {
            int32_t eax_16;
            eax_16 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x20, nullptr, u"(L"String is not null terminated…");
            
            if (eax_16 == 1)
                breakpoint();
        }
        
        if (var_2c_1 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(L"String is not null terminated…", u"strcat_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x20, 0);
            return 0x16;
        }
    }
    
    bool cond:0_1;
    
    do
    {
        ecx_4 = *arg3;
        *var_8_1 = ecx_4;
        int32_t eax_19 = *var_8_1;
        var_8_1 = &var_8_1[1];
        arg3 = &arg3[1];
        
        if (eax_19 == 0)
            break;
        
        cond:0_1 = i == 1;
        i -= 1;
    } while (!(cond:0_1));
    
    if (i == 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            int32_t var_30_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_30_1 = (arg2 - 1);
            else
                var_30_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, var_30_1);
        }
        
        int32_t var_34_1 = 0;
        
        if ((var_34_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2a, nullptr, u"(L"Buffer is too small" && 0)") == 1))
            breakpoint();
        
        if (var_34_1 == 0)
        {
            *sub_1000eca0() = 0x22;
            sub_1000c310(u"(L"Buffer is too small" && 0)", u"strcat_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2a, 0);
            return 0x22;
        }
    }
    
    if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && ((arg2 - i) + 1) < arg2)))
    {
        int32_t var_38_1;
        
        if (data_100441c4 >= (arg2 - ((arg2 - i) + 1)))
            var_38_1 = (arg2 - ((arg2 - i) + 1));
        else
            var_38_1 = data_100441c4;
        
        sub_1000fae0(&arg1[((arg2 - i) + 1)], 0xfe, var_38_1);
    }
    
    return 0;
}

int32_t sub_10025890(int32_t arg1, char* arg2, int32_t arg3, int32_t arg4)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t var_8_1 = 0;
    
    if ((arg4 == 0xa && arg1 < 0))
        return sub_100258f0(arg1, arg2, arg3, arg4, 1);
    
    return sub_100258f0(arg1, arg2, arg3, arg4, 0);
}

int32_t __stdcall sub_100258f0(int32_t arg1, char* arg2, int32_t arg3, int32_t arg4, int32_t arg5)
{
    int32_t eax;
    eax = arg2 != 0;
    int32_t var_1c = eax;
    
    if (var_1c == 0)
    {
        eax = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x66, nullptr, u"buf != NULL");
        
        if (eax == 1)
            breakpoint();
    }
    
    if (var_1c == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"buf != NULL", u"xtoa_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x66, 0);
        return 0x16;
    }
    
    int32_t eax_4 = -((eax - eax));
    int32_t var_20_1 = eax_4;
    
    if (eax_4 == 0)
    {
        eax_4 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x67, nullptr, u"sizeInTChars > 0");
        
        if (eax_4 == 1)
            breakpoint();
    }
    
    if (var_20_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"sizeInTChars > 0", u"xtoa_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x67, 0);
        return 0x16;
    }
    
    *arg2 = 0;
    
    if ((arg3 != 0xffffffff && (arg3 != 0x7fffffff && arg3 > 1)))
    {
        int32_t var_30_1;
        
        if (data_100441c4 >= (arg3 - 1))
            var_30_1 = (arg3 - 1);
        else
            var_30_1 = data_100441c4;
        
        eax_4 = sub_1000fae0(&arg2[1], 0xfe, var_30_1);
    }
    
    int32_t edx_4;
    edx_4 = arg5 != 0;
    int32_t eax_10 = -((eax_4 - eax_4));
    
    if ((eax_10 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x69, nullptr, u"sizeInTChars > (size_t)(is_neg ?…") == 1))
        breakpoint();
    
    if (eax_10 == 0)
    {
        *sub_1000eca0() = 0x22;
        sub_1000c310(u"sizeInTChars > (size_t)(is_neg ?…", u"xtoa_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x69, 0);
        return 0x22;
    }
    
    int32_t var_34_1;
    
    if ((arg4 < 2 || arg4 > 0x24))
        var_34_1 = 0;
    else
        var_34_1 = 1;
    
    if ((var_34_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x6a, nullptr, u"2 <= radix && radix <= 36") == 1))
        breakpoint();
    
    if (var_34_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"2 <= radix && radix <= 36", u"xtoa_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x6a, 0);
        return 0x16;
    }
    
    int32_t var_c_1 = 0;
    char* var_8_1 = arg2;
    
    if (arg5 != 0)
    {
        *var_8_1 = 0x2d;
        var_8_1 = &var_8_1[1];
        var_c_1 = 1;
        arg1 = -(arg1);
    }
    
    char* var_18_1 = var_8_1;
    
    do
    {
        uint32_t temp1_1 = (COMBINE(0, arg1) % arg4);
        arg1 = (COMBINE(0, arg1) / arg4);
        
        if (temp1_1 <= 9)
        {
            *var_8_1 = (temp1_1 + 0x30);
            var_8_1 = &var_8_1[1];
        }
        else
        {
            *var_8_1 = (temp1_1 + 0x57);
            var_8_1 = &var_8_1[1];
        }
        
        var_c_1 += 1;
        
        if (arg1 <= 0)
            break;
    } while (var_c_1 < arg3);
    
    if (var_c_1 >= arg3)
    {
        *arg2 = 0;
        int32_t eax_27 = -((var_c_1 - var_c_1));
        
        if ((eax_27 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x8e, nullptr, u"length < sizeInTChars") == 1))
            breakpoint();
        
        if (eax_27 == 0)
        {
            *sub_1000eca0() = 0x22;
            sub_1000c310(u"length < sizeInTChars", u"xtoa_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x8e, 0);
            return 0x22;
        }
    }
    
    *var_8_1 = 0;
    void* var_8_2 = (var_8_1 - 1);
    
    do
    {
        void* edx_18;
        edx_18 = *var_8_2;
        char var_11_1 = edx_18;
        edx_18 = *var_18_1;
        *var_8_2 = edx_18;
        char* ecx_13;
        ecx_13 = var_11_1;
        *var_18_1 = ecx_13;
        var_8_2 -= 1;
        var_18_1 = &var_18_1[1];
    } while (var_18_1 < var_8_2);
    
    return 0;
}

int32_t sub_10025c60(PSTR arg1, int16_t* arg2, int32_t arg3, void** arg4)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    int32_t var_8 = 0;
    int32_t lpUsedDefaultChar = 0;
    
    if ((arg1 == 0 || arg3 != 0))
    {
        int32_t eax_3;
        eax_3 = arg2 != 0;
        
        if ((eax_3 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x66, nullptr, u"pwcs != NULL") == 1))
            breakpoint();
        
        if (eax_3 != 0)
        {
            void var_24;
            _LocaleUpdate::_LocaleUpdate(&var_24, arg4);
            
            if (arg1 == 0)
            {
                if (*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_24) + 0x14) != 0)
                {
                    int32_t eax_61 = WideCharToMultiByte(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_24) + 4), 0, arg2, 0xffffffff, nullptr, 0, nullptr, &lpUsedDefaultChar);
                    
                    if ((eax_61 == 0 || lpUsedDefaultChar != 0))
                    {
                        *sub_1000eca0() = 0x2a;
                        _LocaleUpdate::~_LocaleUpdate(&var_24);
                    }
                    else
                    {
                        int32_t var_70_1 = (eax_61 - 1);
                        _LocaleUpdate::~_LocaleUpdate(&var_24);
                    }
                }
                else
                {
                    int32_t var_68_1 = sub_100136b0(arg2);
                    _LocaleUpdate::~_LocaleUpdate(&var_24);
                }
            }
            else if (*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_24) + 0x14) != 0)
            {
                if (*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_24) + 0xac) != 1)
                {
                    int32_t var_8_2 = WideCharToMultiByte(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_24) + 4), 0, arg2, 0xffffffff, arg1, arg3, nullptr, &lpUsedDefaultChar);
                    
                    if ((var_8_2 != 0 && lpUsedDefaultChar == 0))
                    {
                        int32_t var_4c_1 = (var_8_2 - 1);
                        _LocaleUpdate::~_LocaleUpdate(&var_24);
                    }
                    else if (lpUsedDefaultChar != 0)
                    {
                        *sub_1000eca0() = 0x2a;
                        _LocaleUpdate::~_LocaleUpdate(&var_24);
                    }
                    else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                    {
                    label_10025efb:
                        
                        if (var_8_2 >= arg3)
                        {
                            int32_t var_64_1 = var_8_2;
                            _LocaleUpdate::~_LocaleUpdate(&var_24);
                        }
                        else
                        {
                            int32_t cbMultiByte = *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_24) + 0xac);
                            void lpMultiByteStr;
                            int32_t eax_41 = WideCharToMultiByte(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_24) + 4), 0, arg2, 1, &lpMultiByteStr, cbMultiByte, nullptr, &lpUsedDefaultChar);
                            
                            if ((eax_41 == 0 || lpUsedDefaultChar != 0))
                            {
                                *sub_1000eca0() = 0x2a;
                                _LocaleUpdate::~_LocaleUpdate(&var_24);
                            }
                            else if ((eax_41 < 0 || eax_41 > 5))
                            {
                                *sub_1000eca0() = 0x2a;
                                _LocaleUpdate::~_LocaleUpdate(&var_24);
                            }
                            else if ((var_8_2 + eax_41) <= arg3)
                            {
                                int32_t var_c_1 = 0;
                                
                                while (true)
                                {
                                    if (var_c_1 >= eax_41)
                                    {
                                        arg2 = &arg2[1];
                                        goto label_10025efb;
                                    }
                                    
                                    int32_t ecx_33;
                                    ecx_33 = *(&lpMultiByteStr + var_c_1);
                                    arg1[var_8_2] = ecx_33;
                                    
                                    if (arg1[var_8_2] == 0)
                                    {
                                        int32_t var_60_1 = var_8_2;
                                        _LocaleUpdate::~_LocaleUpdate(&var_24);
                                        break;
                                    }
                                    
                                    var_c_1 += 1;
                                    var_8_2 += 1;
                                }
                            }
                            else
                            {
                                int32_t var_5c_1 = var_8_2;
                                _LocaleUpdate::~_LocaleUpdate(&var_24);
                            }
                        }
                    }
                    else
                    {
                        *sub_1000eca0() = 0x2a;
                        _LocaleUpdate::~_LocaleUpdate(&var_24);
                    }
                }
                else
                {
                    if (arg3 > 0)
                        arg3 = wcsncnt(arg2, arg3);
                    
                    int32_t var_8_1 = WideCharToMultiByte(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_24) + 4), 0, arg2, arg3, arg1, arg3, nullptr, &lpUsedDefaultChar);
                    
                    if ((var_8_1 == 0 || lpUsedDefaultChar != 0))
                    {
                        *sub_1000eca0() = 0x2a;
                        _LocaleUpdate::~_LocaleUpdate(&var_24);
                    }
                    else
                    {
                        if (arg1[(var_8_1 - 1)] == 0)
                            var_8_1 -= 1;
                        
                        int32_t var_44_1 = var_8_1;
                        _LocaleUpdate::~_LocaleUpdate(&var_24);
                    }
                }
            }
            else
            {
                while (true)
                {
                    if (var_8 >= arg3)
                    {
                        int32_t var_40_1 = var_8;
                        _LocaleUpdate::~_LocaleUpdate(&var_24);
                        break;
                    }
                    
                    if (*arg2 > 0xff)
                    {
                        *sub_1000eca0() = 0x2a;
                        _LocaleUpdate::~_LocaleUpdate(&var_24);
                        break;
                    }
                    
                    uint32_t eax_9;
                    eax_9 = *arg2;
                    arg1[var_8] = eax_9;
                    uint32_t edx_4 = *arg2;
                    arg2 = &arg2[1];
                    
                    if (edx_4 == 0)
                    {
                        int32_t var_3c_1 = var_8;
                        _LocaleUpdate::~_LocaleUpdate(&var_24);
                        break;
                    }
                    
                    var_8 += 1;
                }
            }
        }
        else
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"pwcs != NULL", u"_wcstombs_l_helper", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x66, 0);
        }
    }
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t sub_10025daf(int32_t* arg1 @ ebp)
{
    _LocaleUpdate::~_LocaleUpdate(&arg1[-8]);
    int32_t result = sub_1000ac70((arg1[-9] ^ arg1));
    *arg1;
    return result;
}

int32_t wcsncnt(int16_t* arg1, int32_t arg2)
{
    int32_t var_c = (arg2 + 1);
    int16_t* var_8 = arg1;
    
    while (true)
    {
        bool cond:0_1 = var_c == 1;
        var_c -= 1;
        
        if (cond:0_1)
            break;
        
        if (*var_8 == 0)
            break;
        
        var_8 = &var_8[1];
    }
    
    if ((var_c != 0 && *var_8 == 0))
        return (((var_8 - arg1) >> 1) + 1);
    
    return arg2;
}

int32_t __convention("regparm") sub_10026150(int32_t arg1, char* arg2, char* arg3, PSTR arg4, char* arg5, int16_t* arg6, char* arg7, void** arg8)
{
    int32_t result = 0;
    int32_t var_20;
    
    if (((arg4 == 0 || arg5 <= 0) && (arg4 != 0 || arg5 != 0)))
        var_20 = 0;
    else
        var_20 = 1;
    
    if (var_20 == 0)
    {
        int32_t eax_1;
        eax_1 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x133, nullptr, u"(dst != NULL && sizeInBytes > 0)…");
        
        if (eax_1 == 1)
            breakpoint();
    }
    
    if (var_20 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(dst != NULL && sizeInBytes > 0)…", u"_wcstombs_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x133, 0);
        return 0x16;
    }
    
    if (arg4 != 0)
    {
        arg2 = arg4;
        *arg2 = 0;
        
        if ((arg5 != 0xffffffff && (arg5 != 0x7fffffff && arg5 > 1)))
        {
            void* var_24_1;
            
            if (data_100441c4 >= (arg5 - 1))
                var_24_1 = (arg5 - 1);
            else
                var_24_1 = data_100441c4;
            
            arg2 = sub_1000fae0(&arg4[1], 0xfe, var_24_1);
        }
    }
    
    if (arg3 != 0)
    {
        arg2 = arg3;
        *arg2 = 0;
    }
    
    char* var_28_1;
    
    if (arg7 <= arg5)
    {
        arg2 = arg7;
        var_28_1 = arg2;
    }
    else
        var_28_1 = arg5;
    
    int32_t edx_2 = (arg2 - arg2);
    
    if ((edx_2 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13f, nullptr, u"bufferSize <= INT_MAX") == 1))
        breakpoint();
    
    if (edx_2 == 0xffffffff)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"bufferSize <= INT_MAX", u"_wcstombs_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13f, 0);
        return 0x16;
    }
    
    void* eax_12 = sub_10025c60(arg4, arg6, var_28_1, arg8);
    
    if (eax_12 == 0xffffffff)
    {
        if (arg4 != 0)
        {
            *arg4 = 0;
            
            if ((arg5 != 0xffffffff && (arg5 != 0x7fffffff && arg5 > 1)))
            {
                void* var_2c_1;
                
                if (data_100441c4 >= (arg5 - 1))
                    var_2c_1 = (arg5 - 1);
                else
                    var_2c_1 = data_100441c4;
                
                sub_1000fae0(&arg4[1], 0xfe, var_2c_1);
            }
        }
        
        return *sub_1000eca0();
    }
    
    char* edx_9 = (eax_12 + 1);
    char* var_10_2 = edx_9;
    
    if (arg4 != 0)
    {
        if (var_10_2 > arg5)
        {
            if (arg7 != 0xffffffff)
            {
                *arg4 = 0;
                
                if ((arg5 != 0xffffffff && (arg5 != 0x7fffffff && arg5 > 1)))
                {
                    void* var_30_1;
                    
                    if (data_100441c4 >= (arg5 - 1))
                        var_30_1 = (arg5 - 1);
                    else
                        var_30_1 = data_100441c4;
                    
                    edx_9 = sub_1000fae0(&arg4[1], 0xfe, var_30_1);
                }
                
                int32_t edx_14 = -((edx_9 - edx_9));
                
                if ((edx_14 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x157, nullptr, u"sizeInBytes > retsize") == 1))
                    breakpoint();
                
                if (edx_14 == 0)
                {
                    *sub_1000eca0() = 0x22;
                    sub_1000c310(u"sizeInBytes > retsize", u"_wcstombs_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x157, 0);
                    return 0x22;
                }
            }
            
            var_10_2 = arg5;
            result = 0x50;
        }
        
        *((arg4 + var_10_2) - 1) = 0;
    }
    
    if (arg3 != 0)
        *arg3 = var_10_2;
    
    return result;
}

int32_t _wcstombs_s(char* arg1, char* arg2, char* arg3, char* arg4, void** arg5)
{
    int32_t var_8 = 0;
    return sub_10026150(arg2, arg3, arg1, arg1, arg2, arg3, arg4, arg5);
}

int32_t sub_100264b0(int16_t* arg1, void* arg2, int16_t* arg3)
{
    int32_t var_20;
    
    if ((arg1 == 0 || arg2 <= 0))
        var_20 = 0;
    else
        var_20 = 1;
    
    if ((var_20 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x12, nullptr, u"((_Dst)) != NULL && ((_SizeInWor…") == 1))
        breakpoint();
    
    if (var_20 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"((_Dst)) != NULL && ((_SizeInWor…", u"wcscat_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x12, 0);
        return 0x16;
    }
    
    if (arg3 == 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            void* var_24_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_24_1 = (arg2 - 1);
            else
                var_24_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, (var_24_1 << 1));
        }
        
        int32_t eax_7;
        eax_7 = arg3 != 0;
        
        if ((eax_7 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13, nullptr, u"(((_Src))) != NULL") == 1))
            breakpoint();
        
        if (eax_7 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(((_Src))) != NULL", u"wcscat_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13, 0);
            return 0x16;
        }
    }
    
    int16_t* var_8_1 = arg1;
    void* i;
    
    for (i = arg2; i > 0; i -= 1)
    {
        if (*var_8_1 == 0)
            break;
        
        var_8_1 = &var_8_1[1];
    }
    
    if (i == 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            void* var_28_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_28_1 = (arg2 - 1);
            else
                var_28_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, (var_28_1 << 1));
        }
        
        int32_t var_2c_1 = 0;
        
        if ((var_2c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x20, nullptr, u"(L"String is not null terminated…") == 1))
            breakpoint();
        
        if (var_2c_1 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(L"String is not null terminated…", u"wcscat_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x20, 0);
            return 0x16;
        }
    }
    
    bool cond:0_1;
    
    do
    {
        void* eax_10;
        eax_10 = *arg3;
        *var_8_1 = eax_10;
        uint32_t edx_11 = *var_8_1;
        var_8_1 = &var_8_1[1];
        arg3 = &arg3[1];
        
        if (edx_11 == 0)
            break;
        
        cond:0_1 = i == 1;
        i -= 1;
    } while (!(cond:0_1));
    
    if (i == 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            void* var_30_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_30_1 = (arg2 - 1);
            else
                var_30_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, (var_30_1 << 1));
        }
        
        int32_t var_34_1 = 0;
        
        if ((var_34_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2a, nullptr, u"(L"Buffer is too small" && 0)") == 1))
            breakpoint();
        
        if (var_34_1 == 0)
        {
            *sub_1000eca0() = 0x22;
            sub_1000c310(u"(L"Buffer is too small" && 0)", u"wcscat_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2a, 0);
            return 0x22;
        }
    }
    
    if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && ((arg2 - i) + 1) < arg2)))
    {
        void* var_38_1;
        
        if (data_100441c4 >= (arg2 - ((arg2 - i) + 1)))
            var_38_1 = (arg2 - ((arg2 - i) + 1));
        else
            var_38_1 = data_100441c4;
        
        sub_1000fae0(&arg1[((arg2 - i) + 1)], 0xfe, (var_38_1 << 1));
    }
    
    return 0;
}

int32_t sub_100268a0(int32_t arg1, int16_t* arg2, int32_t arg3, int32_t arg4)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t var_8_1 = 0;
    
    if ((arg4 == 0xa && arg1 < 0))
        return sub_10026900(arg3, arg1, arg2, arg3, arg4, 1);
    
    return sub_10026900(arg1, arg1, arg2, arg3, arg4, 0);
}

int32_t __thiscall sub_10026900(int32_t arg1, int32_t arg2, int16_t* arg3, int32_t arg4, int32_t arg5, int32_t arg6)
{
    int32_t eax;
    eax = arg3 != 0;
    int32_t var_1c = eax;
    
    if (var_1c == 0)
    {
        eax = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x66, nullptr, u"buf != NULL");
        
        if (eax == 1)
            breakpoint();
    }
    
    if (var_1c == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"buf != NULL", u"xtow_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x66, 0);
        return 0x16;
    }
    
    int32_t eax_4 = -((eax - eax));
    
    if (eax_4 == 0)
    {
        int32_t eax_5;
        eax_5 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x67, nullptr, u"sizeInTChars > 0");
        
        if (eax_5 == 1)
            breakpoint();
    }
    
    if (eax_4 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"sizeInTChars > 0", u"xtow_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x67, 0);
        return 0x16;
    }
    
    *arg3 = 0;
    
    if ((arg4 != 0xffffffff && (arg4 != 0x7fffffff && arg4 > 1)))
    {
        int32_t var_30_1;
        
        if (data_100441c4 >= (arg4 - 1))
            var_30_1 = (arg4 - 1);
        else
            var_30_1 = data_100441c4;
        
        arg1 = sub_1000fae0(&arg3[1], 0xfe, (var_30_1 << 1));
    }
    
    int32_t eax_10;
    eax_10 = arg6 != 0;
    int32_t ecx_5 = -((arg1 - arg1));
    
    if ((ecx_5 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x69, nullptr, u"sizeInTChars > (size_t)(is_neg ?…") == 1))
        breakpoint();
    
    if (ecx_5 == 0)
    {
        *sub_1000eca0() = 0x22;
        sub_1000c310(u"sizeInTChars > (size_t)(is_neg ?…", u"xtow_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x69, 0);
        return 0x22;
    }
    
    int32_t var_34_1;
    
    if ((arg5 < 2 || arg5 > 0x24))
        var_34_1 = 0;
    else
        var_34_1 = 1;
    
    if ((var_34_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x6a, nullptr, u"2 <= radix && radix <= 36") == 1))
        breakpoint();
    
    if (var_34_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"2 <= radix && radix <= 36", u"xtow_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x6a, 0);
        return 0x16;
    }
    
    int32_t var_c_1 = 0;
    int16_t* var_8_1 = arg3;
    
    if (arg6 != 0)
    {
        *var_8_1 = 0x2d;
        var_8_1 = &var_8_1[1];
        var_c_1 = 1;
        arg2 = -(arg2);
    }
    
    int16_t* var_18_1 = var_8_1;
    
    do
    {
        uint32_t temp1_1 = (COMBINE(0, arg2) % arg5);
        arg2 = (COMBINE(0, arg2) / arg5);
        
        if (temp1_1 <= 9)
        {
            *var_8_1 = (temp1_1 + 0x30);
            var_8_1 = &var_8_1[1];
        }
        else
        {
            *var_8_1 = (temp1_1 + 0x57);
            var_8_1 = &var_8_1[1];
        }
        
        var_c_1 += 1;
        
        if (arg2 <= 0)
            break;
    } while (var_c_1 < arg4);
    
    if (var_c_1 >= arg4)
    {
        *arg3 = 0;
        int32_t eax_27 = -((0 - 0));
        
        if ((eax_27 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x8e, nullptr, u"length < sizeInTChars") == 1))
            breakpoint();
        
        if (eax_27 == 0)
        {
            *sub_1000eca0() = 0x22;
            sub_1000c310(u"length < sizeInTChars", u"xtow_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x8e, 0);
            return 0x22;
        }
    }
    
    *var_8_1 = 0;
    void* var_8_2 = (var_8_1 - 2);
    
    do
    {
        void* eax_30;
        eax_30 = *var_8_2;
        int16_t var_14_1 = eax_30;
        eax_30 = *var_18_1;
        *var_8_2 = eax_30;
        int16_t* edx_19;
        edx_19 = var_14_1;
        *var_18_1 = edx_19;
        var_8_2 -= 2;
        var_18_1 = &var_18_1[1];
    } while (var_18_1 < var_8_2);
    
    return 0;
}

void sub_10026c80()
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    for (int32_t i = 0; i < 0xa; i += 1)
        &data_10044ce0[i] = sub_10018a80(&data_10044ce0[i]);
}

int32_t __initp_misc_rand_s(int32_t arg1)
{
    data_10046020 = arg1;
    return arg1;
}

int32_t sub_10026ce0(void** arg1, int32_t arg2, uint32_t arg3, uint32_t arg4, char** arg5)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    
    if (arg2 == 1)
    {
        void var_94;
        void* var_8_1 = &var_94;
        int32_t var_a0_1 = 0;
        int32_t var_98_1 = sub_1002f990(arg1, arg3, arg4, var_8_1, 0x80, 0);
        
        if (var_98_1 != 0)
        {
        label_10026e18:
            *arg5 = sub_10010b10(var_98_1, 1, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x67);
            
            if (*arg5 == 0)
                goto label_10026e81;
            
            sub_1000b4b0(sub_1002dfb0(*arg5, var_98_1, var_8_1, (var_98_1 - 1)), u"strncpy_s(*straddress, outsize, …", u"__getlocaleinfo", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x6a, 0);
            
            if (var_a0_1 != 0)
                sub_10011340(var_8_1, 2);
        }
        else
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                int32_t eax_8 = sub_1002f990(arg1, arg3, arg4, nullptr, 0, 0);
                
                if (eax_8 != 0)
                {
                    var_8_1 = sub_10010b10(eax_8, 1, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x5c);
                    
                    if (var_8_1 != 0)
                    {
                        var_a0_1 = 1;
                        var_98_1 = sub_1002f990(arg1, arg3, arg4, var_8_1, eax_8, 0);
                        
                        if (var_98_1 != 0)
                            goto label_10026e18;
                    }
                }
            }
            
        label_10026e81:
            
            if (var_a0_1 != 0)
                sub_10011340(var_8_1, 2);
        }
    }
    else if ((arg2 == 0 && sub_1002f920(arg1, arg3, arg4, 0x10046024, 4, 0) != 0))
    {
        *arg5 = nullptr;
        
        for (int32_t i = 0; i < 4; i += 1)
        {
            char** ecx_11;
            ecx_11 = *((i << 1) + &data_10046024);
            char var_a9_1 = ecx_11;
            
            if (_isdigit(var_a9_1) == 0)
                break;
            
            *arg5 = (((*arg5 * 0xa) + var_a9_1) - 0x30);
        }
    }
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t __set_wpgmptr(int32_t arg1)
{
    data_1004602c = arg1;
    return arg1;
}

int32_t sub_10026f90()
{
    int32_t ebp;
    int32_t var_4 = ebp;
    int32_t eax_1 = (__security_cookie ^ &var_4);
    int32_t var_8 = 0;
    
    if ((data_10044d08 & 1) != 0)
        sub_10024990(0xa);
    
    int32_t eax_4;
    int32_t edx;
    eax_4 = sub_10015ef0();
    
    if (eax_4 != 0)
        eax_4 = sub_10015b80(0x16);
    
    int32_t ecx = data_10044d08;
    bool p = /* bool p = unimplemented  {and ecx, 0x2} */;
    bool a = /* undefined */;
    bool z = (ecx & 2) == 0;
    
    if (!(z))
    {
        int32_t var_234_1 = eax_4;
        int32_t var_238_1 = (ecx & 2);
        int32_t var_23c_1 = edx;
        int32_t ebx;
        int32_t var_240_1 = ebx;
        int32_t esi;
        int32_t var_244_1 = esi;
        int32_t edi;
        int32_t var_248_1 = edi;
        int16_t ss;
        int16_t var_21c_1 = ss;
        int16_t cs;
        int16_t var_228_1 = cs;
        int16_t ds;
        int16_t var_24c_1 = ds;
        int16_t es;
        int16_t var_250_1 = es;
        int16_t fs;
        int16_t var_254_1 = fs;
        int16_t gs;
        int16_t var_258_1 = gs;
        bool d;
        int32_t var_338_1 = ((((0) ? 1 : 0) << 0xb) | ((((d) ? 1 : 0) << 0xa) | (((((ecx & 2) < 0) ? 1 : 0) << 7) | ((((z) ? 1 : 0) << 6) | ((((a) ? 1 : 0) << 4) | ((((p) ? 1 : 0) << 2) | ((0) ? 1 : 0)))))));
        int32_t var_224_1 = var_338_1;
        int32_t var_2e4 = 0x10001;
        void* const __return_addr_2 = __return_addr;
        int32_t var_230_1 = var_4;
        int32_t var_334;
        sub_1000fae0(&var_334, 0, 0x50);
        var_334 = 0x40000015;
        void* const __return_addr_1 = __return_addr;
        int32_t* ExceptionInfo = &var_334;
        int32_t* var_c_1 = &var_2e4;
        SetUnhandledExceptionFilter(nullptr);
        UnhandledExceptionFilter(&ExceptionInfo);
    }
    
    sub_100155e0(3);
    return sub_1000ac70((eax_1 ^ &var_4));
}

uint32_t sub_100270d0(int32_t arg1, int32_t arg2, int32_t arg3, enum SET_FILE_POINTER_MOVE_METHOD arg4)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10042138;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_3c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_40 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_24 = 0xffffffff;
    int32_t var_20 = 0xffffffff;
    uint32_t result;
    
    if (arg1 != 0xfffffffe)
    {
        int32_t var_30_1;
        
        if ((arg1 < 0 || arg1 >= data_10049258))
            var_30_1 = 0;
        else
            var_30_1 = 1;
        
        if ((var_30_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x4e, nullptr, u"(fh >= 0 && (unsigned)fh < (unsi…") == 1))
            breakpoint();
        
        if (var_30_1 != 0)
        {
            int32_t eax_11 = (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 1);
            int32_t eax_12 = -(eax_11);
            int32_t eax_14 = -((eax_12 - eax_12));
            
            if ((eax_14 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x4f, nullptr, u"(_osfile(fh) & FOPEN)") == 1))
                breakpoint();
            
            if (eax_14 != 0)
            {
                sub_1002aca0(arg1);
                int32_t var_8_1 = 0;
                uint32_t result_1;
                int32_t var_20_1;
                
                if ((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 1) == 0)
                {
                    *sub_1000eca0() = 9;
                    *sub_1000ecd0() = 0;
                    result_1 = 0xffffffff;
                    var_20_1 = 0xffffffff;
                    
                    if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5a, nullptr, u"("Invalid file descriptor. File …") == 1)
                        breakpoint();
                }
                else
                {
                    uint32_t result_2;
                    int32_t edx_7;
                    result_2 = sub_10027320(arg1, arg2, arg3, arg4);
                    result_1 = result_2;
                    var_20_1 = edx_7;
                }
                int32_t var_8_2 = 0xfffffffe;
                sub_100272f4(&__saved_ebp);
                result = result_1;
            }
            else
            {
                *sub_1000ecd0() = 0;
                *sub_1000eca0() = 9;
                sub_1000c310(u"(_osfile(fh) & FOPEN)", u"_lseeki64", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x4f, 0);
                result = 0xffffffff;
            }
        }
        else
        {
            *sub_1000ecd0() = 0;
            *sub_1000eca0() = 9;
            sub_1000c310(u"(fh >= 0 && (unsigned)fh < (unsi…", u"_lseeki64", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x4e, 0);
            result = 0xffffffff;
        }
    }
    else
    {
        *sub_1000ecd0() = 0;
        *sub_1000eca0() = 9;
        result = 0xffffffff;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_100272f4(void* arg1 @ ebp)
{
    return __unlock_fhandle(*(arg1 + 8));
}

uint32_t sub_10027320(int32_t arg1, int32_t arg2, int32_t arg3, enum SET_FILE_POINTER_MOVE_METHOD arg4)
{
    int32_t lpDistanceToMoveHigh = arg3;
    HANDLE hFile = sub_1002ab30(arg1);
    uint32_t result;
    
    if (hFile != 0xffffffff)
    {
        uint32_t result_1 = SetFilePointer(hFile, arg2, &lpDistanceToMoveHigh, arg4);
        enum WIN32_ERROR eax_3;
        
        if (result_1 == 0xffffffff)
            eax_3 = GetLastError();
        
        if ((result_1 != 0xffffffff || eax_3 == NO_ERROR))
        {
            *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) &= 0xfd;
            result = result_1;
        }
        else
        {
            ___acrt_errno_map_os_error(eax_3);
            result = 0xffffffff;
        }
    }
    else
    {
        *sub_1000eca0() = 9;
        
        if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x89, nullptr, u"("Invalid file descriptor. File …") == 1)
            breakpoint();
        
        result = 0xffffffff;
    }
    
    return result;
}

int32_t sub_10027410(int32_t arg1)
{
    if (arg1 == 0xfffffffe)
    {
        *sub_1000eca0() = 9;
        return 0;
    }
    
    int32_t var_c_1;
    
    if ((arg1 < 0 || arg1 >= data_10049258))
        var_c_1 = 0;
    else
        var_c_1 = 1;
    
    if ((var_c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2d, nullptr, u"(fh >= 0 && (unsigned)fh < (unsi…") == 1))
        breakpoint();
    
    if (var_c_1 == 0)
    {
        *sub_1000eca0() = 9;
        sub_1000c310(u"(fh >= 0 && (unsigned)fh < (unsi…", u"_isatty", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2d, 0);
        return 0;
    }
    
    if (data_10044d0c == 0xffffffff)
    {
        sub_1002fb70();
        data_10044d0c = 0;
    }
    
    if (data_10044d0c == 0)
        return (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 0x40);
    
    return 1;
}

int32_t sub_100274f0()
{
    int32_t result;
    result = data_10046030 == (__security_cookie | 1);
    return result;
}

int32_t sub_10027510(char arg1, void** arg2)
{
    void var_14;
    _LocaleUpdate::_LocaleUpdate(&var_14, arg2);
    int32_t result = (*(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 0xc8) + (arg1 << 1)) & 0x8000);
    _LocaleUpdate::~_LocaleUpdate(&var_14);
    return result;
}

int32_t __mkgmtime32(char arg1)
{
    return sub_10027510(arg1, nullptr);
}

int32_t sub_10027580(int16_t* arg1, char* arg2, int32_t arg3, void** arg4)
{
    if ((arg2 == 0 || arg3 == 0))
        return 0;
    
    if (*arg2 == 0)
    {
        if (arg1 != 0)
            *arg1 = 0;
        
        return 0;
    }
    
    void var_14;
    _LocaleUpdate::_LocaleUpdate(&var_14, arg4);
    
    if (((*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 0xac) != 1 && *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 0xac) != 2) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x47, nullptr, u"_loc_update.GetLocaleT()->locinf…") == 1))
        breakpoint();
    
    if (*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 0x14) == 0)
    {
        if (arg1 != 0)
        {
            void* ecx_6;
            ecx_6 = *arg2;
            *arg1 = ecx_6;
        }
        
        _LocaleUpdate::~_LocaleUpdate(&var_14);
        return 1;
    }
    
    void** eax_9 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14);
    
    if (sub_10027510(*arg2, eax_9) == 0)
    {
        int32_t cchWideChar;
        cchWideChar = arg1 != 0;
        
        if (MultiByteToWideChar(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 4), MB_ERR_INVALID_CHARS | MB_PRECOMPOSED, arg2, 1, arg1, cchWideChar) != 0)
        {
            _LocaleUpdate::~_LocaleUpdate(&var_14);
            return 1;
        }
        
        *sub_1000eca0() = 0x2a;
        _LocaleUpdate::~_LocaleUpdate(&var_14);
        return 0xffffffff;
    }
    
    if (*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 0xac) <= 1)
    {
    label_100276d1:
        
        if ((arg3 < *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 0xac) || arg2[1] == 0))
        {
            *sub_1000eca0() = 0x2a;
            _LocaleUpdate::~_LocaleUpdate(&var_14);
            return 0xffffffff;
        }
    }
    else
    {
        if (arg3 < *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 0xac))
            goto label_100276d1;
        
        int32_t cchWideChar_1;
        cchWideChar_1 = arg1 != 0;
        int32_t cbMultiByte = *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 0xac);
        
        if (MultiByteToWideChar(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 4), MB_ERR_INVALID_CHARS | MB_PRECOMPOSED, arg2, cbMultiByte, arg1, cchWideChar_1) == 0)
            goto label_100276d1;
    }
    
    int32_t result = *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 0xac);
    _LocaleUpdate::~_LocaleUpdate(&var_14);
    return result;
}

void* sub_1002772b(int32_t* arg1 @ ebp)
{
    void* result = _LocaleUpdate::~_LocaleUpdate(&arg1[-4]);
    *arg1;
    return result;
}

int32_t _wcstoll(int16_t* arg1, char* arg2, int32_t arg3)
{
    return sub_10027580(arg1, arg2, arg3, nullptr);
}

uint32_t __stdcall __aulldiv(int32_t arg1, uint32_t arg2, int32_t arg3, uint32_t arg4) __pure
{
    if (arg4 == 0)
        return (COMBINE((COMBINE(0, arg2) % arg3), arg1) / arg3);
    
    uint32_t i = arg4;
    int32_t ebx_1 = arg3;
    uint32_t edx_3 = arg2;
    int32_t eax_6 = arg1;
    
    do
    {
        ebx_1 = (RRCD(ebx_1, 1, (i & 1) != 0));
        uint32_t temp4_1 = edx_3;
        edx_3 u>>= 1;
        eax_6 = (RRCD(eax_6, 1, (temp4_1 & 1) != 0));
        i u>>= 1;
    } while (i != 0);
    
    uint32_t result = (COMBINE(edx_3, eax_6) / ebx_1);
    int32_t eax_8;
    int32_t edx_4;
    edx_4 = HIGHD((result * arg4));
    eax_8 = LOWD((result * arg4));
    int32_t eax_10;
    int32_t edx_5;
    edx_5 = HIGHD((arg3 * result));
    eax_10 = LOWD((arg3 * result));
    int32_t edx_6 = (edx_5 + eax_8);
    
    if (((edx_5 + eax_8) >= edx_5 && (edx_6 <= arg2 && (edx_6 < arg2 || eax_10 <= arg1))))
        return result;
    
    return (result - 1);
}

uint32_t __stdcall __aullrem(int32_t arg1, uint32_t arg2, int32_t arg3, uint32_t arg4) __pure
{
    uint32_t result;
    
    if (arg4 != 0)
    {
        uint32_t i = arg4;
        int32_t ebx_1 = arg3;
        uint32_t edx_4 = arg2;
        int32_t eax_4 = arg1;
        
        do
        {
            ebx_1 = (RRCD(ebx_1, 1, (i & 1) != 0));
            uint32_t temp4_1 = edx_4;
            edx_4 u>>= 1;
            eax_4 = (RRCD(eax_4, 1, (temp4_1 & 1) != 0));
            i u>>= 1;
        } while (i != 0);
        
        uint32_t temp0_1 = (COMBINE(edx_4, eax_4) / ebx_1);
        int32_t eax_6;
        int32_t edx_5;
        edx_5 = HIGHD((temp0_1 * arg4));
        eax_6 = LOWD((temp0_1 * arg4));
        int32_t eax_8;
        int32_t edx_6;
        edx_6 = HIGHD((temp0_1 * arg3));
        eax_8 = LOWD((temp0_1 * arg3));
        int32_t edx_7 = (edx_6 + eax_6);
        
        if (((edx_6 + eax_6) < edx_6 || edx_7 > arg2))
            eax_8 -= arg3;
        else if ((edx_7 >= arg2 && eax_8 > arg1))
            eax_8 -= arg3;
        
        result = -((eax_8 - arg1));
    }
    else
        result = (COMBINE((COMBINE(0, arg2) % arg3), arg1) % arg3);
    
    return result;
}

int32_t sub_100278b0(int16_t arg1, int16_t** arg2)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    
    if ((arg2[3] & 0x40) != 0)
    {
    label_10027b39:
        arg2[1] -= 2;
        
        if (arg2[1] < 0)
            sub_1002fc30(arg1, arg2);
        else
        {
            int16_t** eax_48;
            eax_48 = arg1;
            **arg2 = eax_48;
            *arg2 = &*arg2[1];
            void* eax_50;
            eax_50 = arg1;
        }
    }
    else
    {
        int32_t eax_3 = sub_10019e20(arg2);
        int32_t eax_5;
        
        if (eax_3 != 0xffffffff)
            eax_5 = sub_10019e20(arg2);
        
        void* var_1c_1;
        
        if ((eax_3 == 0xffffffff || eax_5 == 0xfffffffe))
            var_1c_1 = &data_100445b0;
        else
        {
            int32_t esi_2 = (sub_10019e20(arg2) >> 5);
            var_1c_1 = (((sub_10019e20(arg2) & 0x1f) << 6) + &data_10049260[esi_2]);
        }
        
        if (((*(var_1c_1 + 0x24) << 1) >> 1) == 2)
        {
        label_100279b2:
            arg2[1] -= 2;
            
            if (arg2[1] < 0)
                sub_1002fc30(arg1, arg2);
            else
            {
                int16_t** ecx_7;
                ecx_7 = arg1;
                **arg2 = ecx_7;
                *arg2 = &*arg2[1];
                int16_t** eax_24;
                eax_24 = arg1;
            }
        }
        else
        {
            int32_t eax_13 = sub_10019e20(arg2);
            int32_t eax_14;
            
            if (eax_13 != 0xffffffff)
                eax_14 = sub_10019e20(arg2);
            
            void* var_20_1;
            
            if ((eax_13 == 0xffffffff || eax_14 == 0xfffffffe))
                var_20_1 = &data_100445b0;
            else
            {
                int32_t esi_4 = (sub_10019e20(arg2) >> 5);
                var_20_1 = (((sub_10019e20(arg2) & 0x1f) << 6) + &data_10049260[esi_4]);
            }
            
            if (((*(var_20_1 + 0x24) << 1) >> 1) == 1)
                goto label_100279b2;
            
            int32_t eax_26 = sub_10019e20(arg2);
            int32_t eax_28;
            
            if (eax_26 != 0xffffffff)
                eax_28 = sub_10019e20(arg2);
            
            void* var_28_1;
            
            if ((eax_26 == 0xffffffff || eax_28 == 0xfffffffe))
                var_28_1 = &data_100445b0;
            else
            {
                int32_t esi_6 = (sub_10019e20(arg2) >> 5);
                var_28_1 = (((sub_10019e20(arg2) & 0x1f) << 6) + &data_10049260[esi_6]);
            }
            
            if ((*(var_28_1 + 4) & 0x80) == 0)
                goto label_10027b39;
            
            void var_18;
            int32_t var_c;
            
            if (_wctomb_s(&var_c, &var_18, 5, arg1) == 0)
            {
                for (int32_t i = 0; i < var_c; i += 1)
                {
                    arg2[1] -= 1;
                    uint32_t var_2c_1;
                    
                    if (arg2[1] < 0)
                    {
                        int16_t** var_38_15 = arg2;
                        var_2c_1 = sub_100162c0(*(&var_18 + i));
                    }
                    else
                    {
                        int16_t** edx_19;
                        edx_19 = *(&var_18 + i);
                        **arg2 = edx_19;
                        var_2c_1 = **arg2;
                        *arg2 += 1;
                    }
                    
                    if (var_2c_1 == 0xffffffff)
                        break;
                }
            }
        }
    }
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t sub_100279ee(int32_t* arg1 @ ebp)
{
    *(arg1[3] + 4) -= 2;
    
    if (*(arg1[3] + 4) < 0)
        sub_1002fc30(arg1[2], arg1[3]);
    else
    {
        void* eax_1;
        eax_1 = arg1[2];
        **arg1[3] = eax_1;
        *(arg1 - 0x2a) = arg1[2];
        *arg1[3] += 2;
        int32_t eax_3;
        eax_3 = *(arg1 - 0x2a);
    }
    
    int32_t result = sub_1000ac70((arg1[-3] ^ arg1));
    *arg1;
    return result;
}

int32_t sub_10027ba0()
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x10042158 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_34 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result = 0;
    __lock(1);
    int32_t var_8_1 = 0;
    
    for (int32_t i = 3; i < data_1004a380; i += 1)
    {
        if (*(data_10049360 + (i << 2)) != 0)
        {
            if (((*(*(data_10049360 + (i << 2)) + 0xc) & 0x83) != 0 && sub_1000d900(*(data_10049360 + (i << 2))) != 0xffffffff))
                result += 1;
            
            if (i >= 0x14)
            {
                DeleteCriticalSection((*(data_10049360 + (i << 2)) + 0x20));
                sub_10011340(*(data_10049360 + (i << 2)), 2);
                *(data_10049360 + (i << 2)) = 0;
            }
        }
    }
    
    int32_t var_8_2 = 0xfffffffe;
    sub_10027ca8();
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10027ca8()
{
    return __unlock(1);
}

int32_t sub_10027cd0(int32_t arg1, wchar16* arg2, uint32_t arg3)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10042178;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_3c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_40 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result;
    
    if (arg1 != 0xfffffffe)
    {
        int32_t var_30_1;
        
        if ((arg1 < 0 || arg1 >= data_10049258))
            var_30_1 = 0;
        else
            var_30_1 = 1;
        
        if ((var_30_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x55, nullptr, u"(fh >= 0 && (unsigned)fh < (unsi…") == 1))
            breakpoint();
        
        if (var_30_1 != 0)
        {
            int32_t eax_11 = (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 1);
            int32_t eax_12 = -(eax_11);
            int32_t eax_14 = -((eax_12 - eax_12));
            int32_t var_28_1 = eax_14;
            
            if (eax_14 == 0)
            {
                eax_14 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x56, nullptr, u"(_osfile(fh) & FOPEN)");
                
                if (eax_14 == 1)
                    breakpoint();
            }
            
            if (var_28_1 != 0)
            {
                int32_t eax_17 = (eax_14 - eax_14);
                
                if ((eax_17 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x57, nullptr, u"(cnt <= INT_MAX)") == 1))
                    breakpoint();
                
                if (eax_17 != 0xffffffff)
                {
                    sub_1002aca0(arg1);
                    int32_t var_8_1 = 0;
                    int32_t result_1;
                    
                    if ((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 1) == 0)
                    {
                        *sub_1000eca0() = 9;
                        *sub_1000ecd0() = 0;
                        result_1 = 0xffffffff;
                        
                        if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x62, nullptr, u"("Invalid file descriptor. File …") == 1)
                            breakpoint();
                    }
                    else
                        result_1 = sub_10027f60(arg1, arg2, arg3);
                    
                    int32_t var_8_2 = 0xfffffffe;
                    sub_10027f3e(&__saved_ebp);
                    result = result_1;
                }
                else
                {
                    *sub_1000ecd0() = 0;
                    *sub_1000eca0() = 0x16;
                    sub_1000c310(u"(cnt <= INT_MAX)", u"_read", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x57, 0);
                    result = 0xffffffff;
                }
            }
            else
            {
                *sub_1000ecd0() = 0;
                *sub_1000eca0() = 9;
                sub_1000c310(u"(_osfile(fh) & FOPEN)", u"_read", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x56, 0);
                result = 0xffffffff;
            }
        }
        else
        {
            *sub_1000ecd0() = 0;
            *sub_1000eca0() = 9;
            sub_1000c310(u"(fh >= 0 && (unsigned)fh < (unsi…", u"_read", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x55, 0);
            result = 0xffffffff;
        }
    }
    else
    {
        *sub_1000ecd0() = 0;
        *sub_1000eca0() = 9;
        result = 0xffffffff;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10027f3e(void* arg1 @ ebp)
{
    return __unlock_fhandle(*(arg1 + 8));
}

int32_t sub_10027f60(int32_t arg1, wchar16* arg2, uint32_t arg3)
{
    int32_t var_10 = 0xfffffffe;
    uint32_t var_8 = arg3;
    
    if (arg1 == 0xfffffffe)
    {
        *sub_1000ecd0() = 0;
        *sub_1000eca0() = 9;
        return 0xffffffff;
    }
    
    int32_t var_6c_1;
    
    if ((arg1 < 0 || arg1 >= data_10049258))
        var_6c_1 = 0;
    else
        var_6c_1 = 1;
    
    if ((var_6c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x84, nullptr, u"(fh >= 0 && (unsigned)fh < (unsi…") == 1))
        breakpoint();
    
    if (var_6c_1 == 0)
    {
        *sub_1000ecd0() = 0;
        *sub_1000eca0() = 9;
        sub_1000c310(u"(fh >= 0 && (unsigned)fh < (unsi…", u"_read_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x84, 0);
        return 0xffffffff;
    }
    
    int32_t ecx_5 = (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 1);
    int32_t ecx_6 = -(ecx_5);
    int32_t ecx_8 = -((ecx_6 - ecx_6));
    int32_t var_4c_1 = ecx_8;
    
    if (ecx_8 == 0)
    {
        int32_t eax_8;
        eax_8 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x85, nullptr, u"(_osfile(fh) & FOPEN)");
        
        if (eax_8 == 1)
            breakpoint();
    }
    
    if (var_4c_1 == 0)
    {
        *sub_1000ecd0() = 0;
        *sub_1000eca0() = 9;
        sub_1000c310(u"(_osfile(fh) & FOPEN)", u"_read_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x85, 0);
        return 0xffffffff;
    }
    
    int32_t ecx_9 = (ecx_8 - ecx_8);
    
    if ((ecx_9 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x86, nullptr, u"(cnt <= INT_MAX)") == 1))
        breakpoint();
    
    if (ecx_9 == 0xffffffff)
    {
        *sub_1000ecd0() = 0;
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(cnt <= INT_MAX)", u"_read_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x86, 0);
        return 0xffffffff;
    }
    
    int32_t var_38_1 = 0;
    
    if ((arg3 == 0 || (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 2) != 0))
        return 0;
    
    int32_t ecx_14;
    ecx_14 = arg2 != 0;
    
    if ((ecx_14 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x90, nullptr, u"(inputbuf != NULL)") == 1))
        breakpoint();
    
    if (ecx_14 == 0)
    {
        *sub_1000ecd0() = 0;
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(inputbuf != NULL)", u"_read_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x90, 0);
        return 0xffffffff;
    }
    
    int32_t eax_22;
    eax_22 = *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x24);
    eax_22 <<= 1;
    eax_22 s>>= 1;
    char var_19_1 = eax_22;
    int32_t ecx_17;
    ecx_17 = var_19_1;
    char var_70_1 = ecx_17;
    void* lpMultiByteStr;
    
    if (var_70_1 == 1)
    {
        int32_t edx_8 = (arg3 & 1);
        int32_t edx_9 = -(edx_8);
        int32_t edx_10 = (edx_9 - edx_9);
        
        if ((edx_10 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xac, nullptr, u"((cnt & 1) == 0)") == 1))
            breakpoint();
        
        if (edx_10 == 0xffffffff)
        {
            *sub_1000ecd0() = 0;
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"((cnt & 1) == 0)", u"_read_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xac, 0);
            return 0xffffffff;
        }
        
        uint32_t var_74_1;
        
        if ((arg3 >> 1) >= 4)
            var_74_1 = (arg3 >> 1);
        else
            var_74_1 = 4;
        
        arg3 = var_74_1;
        lpMultiByteStr = __malloc_dbg(arg3, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0xb0);
        
        if (lpMultiByteStr == 0)
        {
            *sub_1000eca0() = 0xc;
            *sub_1000ecd0() = 8;
            return 0xffffffff;
        }
        
        uint32_t eax_30;
        int32_t edx_15;
        eax_30 = sub_10027320(arg1, 0, 0, FILE_CURRENT);
        int32_t esi_3 = ((arg1 & 0x1f) << 6);
        int32_t ecx_23 = &data_10049260[(arg1 >> 5)];
        *((ecx_23 + esi_3) + 0x28) = eax_30;
        *((ecx_23 + esi_3) + 0x2c) = edx_15;
    }
    else
    {
        if (var_70_1 == 2)
        {
            int32_t edx_17 = (arg3 & 1);
            int32_t edx_18 = -(edx_17);
            int32_t edx_19 = (edx_18 - edx_18);
            
            if ((edx_19 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xbc, nullptr, u"((cnt & 1) == 0)") == 1))
                breakpoint();
            
            if (edx_19 == 0xffffffff)
            {
                *sub_1000ecd0() = 0;
                *sub_1000eca0() = 0x16;
                sub_1000c310(u"((cnt & 1) == 0)", u"_read_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xbc, 0);
                return 0xffffffff;
            }
            
            arg3 &= 0xfffffffe;
        }
        
        lpMultiByteStr = arg2;
    }
    
    char* lpBuffer = lpMultiByteStr;
    
    if (((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 0x48) != 0 && (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 5) != 0xa && arg3 != 0)))
    {
        int32_t ecx_33;
        ecx_33 = *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 5);
        *lpBuffer = ecx_33;
        lpBuffer = &lpBuffer[1];
        var_38_1 = 1;
        arg3 -= 1;
        *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 5) = 0xa;
        
        if ((var_19_1 != 0 && (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x25) != 0xa && arg3 != 0)))
        {
            int32_t edx_37;
            edx_37 = *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x25);
            *lpBuffer = edx_37;
            lpBuffer = &lpBuffer[1];
            var_38_1 = 2;
            arg3 -= 1;
            *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x25) = 0xa;
            
            if ((var_19_1 == 1 && (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x26) != 0xa && arg3 != 0)))
            {
                int32_t eax_57;
                eax_57 = *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x26);
                *lpBuffer = eax_57;
                lpBuffer = &lpBuffer[1];
                var_38_1 = 3;
                arg3 -= 1;
                *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x26) = 0xa;
            }
        }
    }
    
    uint32_t lpNumberOfBytesRead;
    
    if (((ReadFile(&data_10049260[(arg1 >> 5)][((arg1 & 0x1f) * 0x10)], lpBuffer, arg3, &lpNumberOfBytesRead, nullptr) == 0 || lpNumberOfBytesRead < 0) || lpNumberOfBytesRead > arg3))
    {
        enum WIN32_ERROR eax_64 = GetLastError();
        
        if (eax_64 == ERROR_ACCESS_DENIED)
        {
            *sub_1000eca0() = 9;
            *sub_1000ecd0() = eax_64;
            var_10 = 0xffffffff;
        }
        else if (eax_64 != ERROR_BROKEN_PIPE)
        {
            ___acrt_errno_map_os_error(eax_64);
            var_10 = 0xffffffff;
        }
        else
            var_10 = 0;
    }
    else
    {
        var_38_1 += lpNumberOfBytesRead;
        
        if ((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 0x80) != 0)
        {
            if (var_19_1 == 2)
            {
                if ((lpNumberOfBytesRead == 0 || *lpMultiByteStr != 0xa))
                    *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) &= 0xfb;
                else
                    *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) |= 4;
                
                void* var_24_1 = lpMultiByteStr;
                void* i = var_24_1;
                
                while (i < (lpMultiByteStr + var_38_1))
                {
                    if (*i == 0x1a)
                    {
                        if ((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 0x40) != 0)
                        {
                            int32_t eax_164;
                            eax_164 = *i;
                            *var_24_1 = eax_164;
                            var_24_1 += 2;
                            void* var_34_1 = (i + 2);
                        }
                        else
                            *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) |= 2;
                        
                        break;
                    }
                    
                    if (*i != 0xd)
                    {
                        uint32_t ecx_157;
                        ecx_157 = *i;
                        *var_24_1 = ecx_157;
                        var_24_1 += 2;
                        i += 2;
                    }
                    else if (i >= ((lpMultiByteStr + var_38_1) - 2))
                    {
                        i += 2;
                        enum WIN32_ERROR var_28_3 = NO_ERROR;
                        int16_t lpBuffer_1;
                        
                        if (ReadFile(&data_10049260[(arg1 >> 5)][((arg1 & 0x1f) * 0x10)], &lpBuffer_1, 2, &lpNumberOfBytesRead, nullptr) == 0)
                            var_28_3 = GetLastError();
                        
                        if ((var_28_3 == NO_ERROR && lpNumberOfBytesRead != 0))
                        {
                            if ((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 0x48) == 0)
                            {
                                if ((var_24_1 == lpMultiByteStr && lpBuffer_1 == 0xa))
                                {
                                    *var_24_1 = 0xa;
                                    var_24_1 += 2;
                                    continue;
                                }
                                
                                uint32_t eax_198;
                                int32_t edx_183;
                                eax_198 = sub_10027320(arg1, 0xfffffffe, 0xffffffff, FILE_CURRENT);
                                uint32_t var_44_3 = eax_198;
                                int32_t var_40_3 = edx_183;
                                
                                if (lpBuffer_1 == 0xa)
                                    continue;
                                else
                                {
                                    *var_24_1 = 0xd;
                                    var_24_1 += 2;
                                    continue;
                                }
                            }
                            else if (lpBuffer_1 != 0xa)
                            {
                                int16_t* var_68_1 = &lpBuffer_1;
                                *var_24_1 = 0xd;
                                var_24_1 += 2;
                                int16_t* ecx_173;
                                ecx_173 = *var_68_1;
                                *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 5) = ecx_173;
                                void* eax_195;
                                eax_195 = *(var_68_1 + 1);
                                *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x25) = eax_195;
                                *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x26) = 0xa;
                                continue;
                            }
                            else
                            {
                                *var_24_1 = 0xa;
                                var_24_1 += 2;
                                continue;
                            }
                        }
                        
                        *var_24_1 = 0xd;
                        var_24_1 += 2;
                    }
                    else if (*(i + 2) != 0xa)
                    {
                        void* eax_175;
                        eax_175 = *i;
                        *var_24_1 = eax_175;
                        var_24_1 += 2;
                        i += 2;
                    }
                    else
                    {
                        i += 4;
                        *var_24_1 = 0xa;
                        var_24_1 += 2;
                    }
                }
                
                var_38_1 = (var_24_1 - lpMultiByteStr);
            }
            else
            {
                if ((lpNumberOfBytesRead == 0 || *lpMultiByteStr != 0xa))
                    *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) &= 0xfb;
                else
                    *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) |= 4;
                
                void* var_2c_1 = lpMultiByteStr;
                void* i_1 = var_2c_1;
                
                while (i_1 < (lpMultiByteStr + var_38_1))
                {
                    if (*i_1 == 0x1a)
                    {
                        if ((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 0x40) != 0)
                        {
                            int32_t ecx_73;
                            ecx_73 = *i_1;
                            *var_2c_1 = ecx_73;
                            var_2c_1 += 1;
                            void* var_c_1 = (i_1 + 1);
                        }
                        else
                            *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) |= 2;
                        
                        break;
                    }
                    
                    if (*i_1 != 0xd)
                    {
                        int32_t edx_83;
                        edx_83 = *i_1;
                        *var_2c_1 = edx_83;
                        var_2c_1 += 1;
                        i_1 += 1;
                    }
                    else if (i_1 >= ((lpMultiByteStr + var_38_1) - 1))
                    {
                        i_1 += 1;
                        enum WIN32_ERROR var_28_2 = NO_ERROR;
                        uint8_t lpBuffer_2;
                        
                        if (ReadFile(&data_10049260[(arg1 >> 5)][((arg1 & 0x1f) * 0x10)], &lpBuffer_2, 1, &lpNumberOfBytesRead, nullptr) == 0)
                            var_28_2 = GetLastError();
                        
                        if ((var_28_2 == NO_ERROR && lpNumberOfBytesRead != 0))
                        {
                            if ((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 0x48) == 0)
                            {
                                if ((var_2c_1 == lpMultiByteStr && lpBuffer_2 == 0xa))
                                {
                                    *var_2c_1 = 0xa;
                                    var_2c_1 += 1;
                                    continue;
                                }
                                
                                uint32_t eax_116;
                                int32_t edx_100;
                                eax_116 = sub_10027320(arg1, 0xffffffff, 0xffffffff, FILE_CURRENT);
                                uint32_t var_44_1 = eax_116;
                                int32_t var_40_1 = edx_100;
                                
                                if (lpBuffer_2 == 0xa)
                                    continue;
                                else
                                {
                                    *var_2c_1 = 0xd;
                                    var_2c_1 += 1;
                                    continue;
                                }
                            }
                            else if (lpBuffer_2 != 0xa)
                            {
                                *var_2c_1 = 0xd;
                                var_2c_1 += 1;
                                int32_t eax_114;
                                eax_114 = lpBuffer_2;
                                *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 5) = eax_114;
                                continue;
                            }
                            else
                            {
                                *var_2c_1 = 0xa;
                                var_2c_1 += 1;
                                continue;
                            }
                        }
                        
                        *var_2c_1 = 0xd;
                        var_2c_1 += 1;
                    }
                    else if (*(i_1 + 1) != 0xa)
                    {
                        int32_t eax_97;
                        eax_97 = *i_1;
                        *var_2c_1 = eax_97;
                        var_2c_1 += 1;
                        i_1 += 1;
                    }
                    else
                    {
                        i_1 += 2;
                        *var_2c_1 = 0xa;
                        var_2c_1 += 1;
                    }
                }
                
                var_38_1 = (var_2c_1 - lpMultiByteStr);
                
                if ((var_19_1 == 1 && var_38_1 != 0))
                {
                    void* var_2c_2 = (var_2c_1 - 1);
                    
                    if ((*var_2c_2 & 0x80) != 0)
                    {
                        int32_t var_60_1 = 1;
                        
                        while (*(*var_2c_2 + 0x10044d10) == 0)
                        {
                            if (var_60_1 > 4)
                                break;
                            
                            if (var_2c_2 < lpMultiByteStr)
                                break;
                            
                            var_2c_2 -= 1;
                            var_60_1 += 1;
                        }
                        
                        int32_t edx_110 = *(*var_2c_2 + 0x10044d10);
                        
                        if (edx_110 != 0)
                        {
                            if ((edx_110 + 1) == var_60_1)
                                var_2c_2 += var_60_1;
                            else if ((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 0x48) == 0)
                            {
                                int32_t eax_143;
                                int32_t edx_124;
                                edx_124 = HIGHD(-(var_60_1));
                                eax_143 = LOWD(-(var_60_1));
                                uint32_t eax_144;
                                int32_t edx_125;
                                eax_144 = sub_10027320(arg1, eax_143, edx_124, FILE_CURRENT);
                                uint32_t var_44_2 = eax_144;
                                int32_t var_40_2 = edx_125;
                            }
                            else
                            {
                                void* eax_132;
                                eax_132 = *var_2c_2;
                                *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 5) = eax_132;
                                void* var_2c_3 = (var_2c_2 + 1);
                                
                                if (var_60_1 >= 2)
                                {
                                    void* edx_118;
                                    edx_118 = *var_2c_3;
                                    *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x25) = edx_118;
                                    var_2c_3 += 1;
                                }
                                
                                if (var_60_1 == 3)
                                {
                                    void* ecx_124;
                                    ecx_124 = *var_2c_3;
                                    *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x26) = ecx_124;
                                    var_2c_3 += 1;
                                }
                                
                                var_2c_2 = (var_2c_3 - var_60_1);
                            }
                            
                            goto label_10028acc;
                        }
                        
                        *sub_1000eca0() = 0x2a;
                        var_10 = 0xffffffff;
                    }
                    else
                    {
                        var_2c_2 += 1;
                    label_10028acc:
                        var_38_1 = MultiByteToWideChar(0xfde9, 0, lpMultiByteStr, (var_2c_2 - lpMultiByteStr), arg2, (var_8 >> 1));
                        
                        if (var_38_1 != 0)
                        {
                            int32_t edx_129;
                            edx_129 = var_38_1 != (var_2c_2 - lpMultiByteStr);
                            *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x30) = edx_129;
                            var_38_1 <<= 1;
                        }
                        else
                        {
                            ___acrt_errno_map_os_error(GetLastError());
                            var_10 = 0xffffffff;
                        }
                    }
                }
            }
        }
    }
    
    if (lpMultiByteStr != arg2)
        __mktime32(lpMultiByteStr);
    
    if (var_10 != 0xfffffffe)
        return var_10;
    
    return var_38_1;
}

int32_t sub_10028eb0(PWSTR arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t* arg5, int32_t arg6)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10042198;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_3c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_40 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_24 = 0;
    int32_t eax_2;
    eax_2 = arg5 != 0;
    
    if ((eax_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x9c, nullptr, u"(pfh != NULL)") == 1))
        breakpoint();
    
    int32_t result;
    
    if (eax_2 != 0)
    {
        *arg5 = 0xffffffff;
        int32_t eax_5;
        eax_5 = arg1 != 0;
        
        if ((eax_5 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x9e, nullptr, u"(path != NULL)") == 1))
            breakpoint();
        
        if (eax_5 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(path != NULL)", u"_wsopen_helper", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x9e, 0);
            result = 0x16;
        }
        else if (arg6 == 0)
        {
        label_1002903f:
            int32_t var_8_1 = 0;
            int32_t var_44_1 = arg6;
            int32_t result_1 = sub_10029100(&var_24, arg5, arg1, arg2, arg3, arg4);
            int32_t var_8_2 = 0xfffffffe;
            sub_1002907b(&__saved_ebp);
            
            if (result_1 != 0)
                *arg5 = 0xffffffff;
            
            result = result_1;
        }
        else
        {
            int32_t edx_3 = (arg4 & 0xfffffe7f);
            int32_t edx_4 = -(edx_3);
            int32_t edx_5 = (edx_4 - edx_4);
            
            if ((edx_5 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xa1, nullptr, u"((pmode & (~(_S_IREAD | _S_IWRIT…") == 1))
                breakpoint();
            
            if (edx_5 != 0xffffffff)
                goto label_1002903f;
            
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"((pmode & (~(_S_IREAD | _S_IWRIT…", u"_wsopen_helper", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xa1, 0);
            result = 0x16;
        }
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"(pfh != NULL)", u"_wsopen_helper", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x9c, 0);
        result = 0x16;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

void sub_1002907b(void* arg1 @ ebp)
{
    if (*(arg1 - 0x20) != 0)
    {
        if (*(arg1 - 0x1c) != 0)
            *((&data_10049260[(**(arg1 + 0x18) >> 5)] + ((**(arg1 + 0x18) & 0x1f) << 6)) + 4) &= 0xfe;
        
        __unlock_fhandle(**(arg1 + 0x18));
    }
}

int32_t sub_10029100(int32_t* arg1, int32_t* arg2, PWSTR arg3, int32_t arg4, int32_t arg5, int32_t arg6)
{
    int32_t var_3c = 0;
    char var_15 = 0;
    int32_t result = 0;
    int32_t lpSecurityAttributes = 0xc;
    int32_t var_2c = 0;
    char var_5;
    
    if ((arg4 & 0x80) == 0)
    {
        int32_t var_28_1 = 1;
        var_5 = 0;
    }
    else
    {
        int32_t var_28 = 0;
        var_5 = 0x10;
    }
    
    sub_1000b4b0(sub_10030410(&var_3c), u"_get_fmode(&fmode)", u"_tsopen_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xe8, 0);
    
    if ((arg4 & 0x8000) == 0)
    {
        if ((arg4 & 0x74000) != 0)
            var_5 |= 0x80;
        else if (var_3c != 0x8000)
            var_5 |= 0x80;
    }
    
    int32_t eax_6 = (arg4 & 3);
    uint32_t dwDesiredAccess;
    
    if (eax_6 == 0)
        dwDesiredAccess = 0x80000000;
    else if (eax_6 == 1)
    {
        if (((arg4 & 8) == 0 || (arg4 & 0x70000) == 0))
            dwDesiredAccess = 0x40000000;
        else
            dwDesiredAccess = 0xc0000000;
    }
    else if (eax_6 == 2)
        dwDesiredAccess = 0xc0000000;
    else
    {
        *sub_1000ecd0() = 0;
        *arg2 = 0xffffffff;
        int32_t var_74_1 = 0;
        
        if ((var_74_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x10f, nullptr, u"( "Invalid open flag" , 0 )") == 1))
            breakpoint();
        
        if (var_74_1 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"( "Invalid open flag" , 0 )", u"_tsopen_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x10f, 0);
            return 0x16;
        }
    }
    
    enum FILE_SHARE_MODE dwShareMode;
    
    if ((arg5 - 0x10) > 0x70)
    {
    label_10029312:
        *sub_1000ecd0() = 0;
        *arg2 = 0xffffffff;
        int32_t var_7c_1 = 0;
        
        if ((var_7c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x132, nullptr, u"( "Invalid sharing flag" , 0 )") == 1))
            breakpoint();
        
        if (var_7c_1 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"( "Invalid sharing flag" , 0 )", u"_tsopen_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x132, 0);
            return 0x16;
        }
    }
    else
        switch (arg5)
        {
            case 0x10:
            {
                dwShareMode = FILE_SHARE_NONE;
                break;
            }
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
            case 0x19:
            case 0x1a:
            case 0x1b:
            case 0x1c:
            case 0x1d:
            case 0x1e:
            case 0x1f:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2a:
            case 0x2b:
            case 0x2c:
            case 0x2d:
            case 0x2e:
            case 0x2f:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
            case 0x38:
            case 0x39:
            case 0x3a:
            case 0x3b:
            case 0x3c:
            case 0x3d:
            case 0x3e:
            case 0x3f:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4a:
            case 0x4b:
            case 0x4c:
            case 0x4d:
            case 0x4e:
            case 0x4f:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x58:
            case 0x59:
            case 0x5a:
            case 0x5b:
            case 0x5c:
            case 0x5d:
            case 0x5e:
            case 0x5f:
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6a:
            case 0x6b:
            case 0x6c:
            case 0x6d:
            case 0x6e:
            case 0x6f:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78:
            case 0x79:
            case 0x7a:
            case 0x7b:
            case 0x7c:
            case 0x7d:
            case 0x7e:
            case 0x7f:
            {
                goto label_10029312;
            }
            case 0x20:
            {
                dwShareMode = FILE_SHARE_READ;
                break;
            }
            case 0x30:
            {
                dwShareMode = FILE_SHARE_WRITE;
                break;
            }
            case 0x40:
            {
                dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
                break;
            }
            case 0x80:
            {
                if (dwDesiredAccess != 0x80000000)
                    dwShareMode = FILE_SHARE_NONE;
                else
                    dwShareMode = FILE_SHARE_READ;
                break;
            }
        }
    
    int32_t eax_17 = (arg4 & 0x700);
    enum FILE_CREATION_DISPOSITION dwCreationDisposition;
    
    if (eax_17 > 0x400)
    {
        if (eax_17 == 0x500)
            dwCreationDisposition = CREATE_NEW;
        else if (eax_17 == 0x600)
            dwCreationDisposition = TRUNCATE_EXISTING;
        else if (eax_17 == 0x700)
            dwCreationDisposition = CREATE_NEW;
        else
        {
        label_10029444:
            *sub_1000ecd0() = 0;
            *arg2 = 0xffffffff;
            int32_t var_84_1 = 0;
            
            if ((var_84_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x154, nullptr, u"( "Invalid open flag" , 0 )") == 1))
                breakpoint();
            
            if (var_84_1 == 0)
            {
                *sub_1000eca0() = 0x16;
                sub_1000c310(u"( "Invalid open flag" , 0 )", u"_tsopen_nolock", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x154, 0);
                return 0x16;
            }
        }
    }
    else if (eax_17 == 0x400)
        dwCreationDisposition = OPEN_EXISTING;
    else if (eax_17 > 0x200)
    {
        if (eax_17 != 0x300)
            goto label_10029444;
        
        dwCreationDisposition = CREATE_ALWAYS;
    }
    else if (eax_17 == 0x200)
        dwCreationDisposition = TRUNCATE_EXISTING;
    else if (eax_17 == 0)
        dwCreationDisposition = OPEN_EXISTING;
    else
    {
        if (eax_17 != 0x100)
            goto label_10029444;
        
        dwCreationDisposition = OPEN_ALWAYS;
    }
    
    enum FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
    
    if (((arg4 & 0x100) != 0 && ((!(data_10045ad4) & arg6) & 0x80) == 0))
        dwFlagsAndAttributes = FILE_ATTRIBUTE_READONLY;
    
    if ((arg4 & 0x40) != 0)
    {
        dwFlagsAndAttributes |= FILE_FLAG_DELETE_ON_CLOSE;
        dwDesiredAccess |= 0x10000;
        dwShareMode |= FILE_SHARE_DELETE;
    }
    
    if ((arg4 & 0x1000) != 0)
        dwFlagsAndAttributes |= FILE_ATTRIBUTE_TEMPORARY;
    
    if ((arg4 & 0x20) != 0)
        dwFlagsAndAttributes |= FILE_FLAG_SEQUENTIAL_SCAN;
    else if ((arg4 & 0x10) != 0)
        dwFlagsAndAttributes |= FILE_FLAG_RANDOM_ACCESS;
    
    *arg2 = sub_1002a6c0();
    
    if (*arg2 == 0xffffffff)
    {
        *sub_1000ecd0() = 0;
        *arg2 = 0xffffffff;
        *sub_1000eca0() = 0x18;
        return *sub_1000eca0();
    }
    
    *arg1 = 1;
    HANDLE var_24_1 = CreateFileW(arg3, dwDesiredAccess, dwShareMode, &lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, nullptr);
    
    if (var_24_1 == 0xffffffff)
    {
        if (((dwDesiredAccess & 0xc0000000) != 0xc0000000 || (arg4 & 1) == 0))
        {
            *((&data_10049260[(*arg2 >> 5)] + ((*arg2 & 0x1f) << 6)) + 4) &= 0xfe;
            ___acrt_errno_map_os_error(GetLastError());
            return *sub_1000eca0();
        }
        
        dwDesiredAccess &= 0x7fffffff;
        var_24_1 = CreateFileW(arg3, dwDesiredAccess, dwShareMode, &lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, nullptr);
        
        if (var_24_1 == 0xffffffff)
        {
            *((&data_10049260[(*arg2 >> 5)] + ((*arg2 & 0x1f) << 6)) + 4) &= 0xfe;
            ___acrt_errno_map_os_error(GetLastError());
            return *sub_1000eca0();
        }
    }
    
    enum FILE_TYPE eax_68 = GetFileType(var_24_1);
    
    if (eax_68 == FILE_TYPE_UNKNOWN)
    {
        int32_t var_50_1 = 0;
        *((&data_10049260[(*arg2 >> 5)] + ((*arg2 & 0x1f) << 6)) + 4) &= 0xfe;
        enum WIN32_ERROR eax_72 = GetLastError();
        ___acrt_errno_map_os_error(eax_72);
        CloseHandle(var_24_1);
        
        if (eax_72 == NO_ERROR)
            *sub_1000eca0() = 0xd;
        
        return *sub_1000eca0();
    }
    
    if (eax_68 == FILE_TYPE_CHAR)
        var_5 |= 0x40;
    else if (eax_68 == FILE_TYPE_PIPE)
        var_5 |= 8;
    
    __set_osfhnd(*arg2, var_24_1);
    char edx_41 = (var_5 | 1);
    int32_t* edx_42;
    edx_42 = edx_41;
    *((&data_10049260[(*arg2 >> 5)] + ((*arg2 & 0x1f) << 6)) + 4) = edx_42;
    int32_t* edx_43;
    edx_43 = *((&data_10049260[(*arg2 >> 5)] + ((*arg2 & 0x1f) << 6)) + 0x24);
    edx_43 &= 0x80;
    *((&data_10049260[(*arg2 >> 5)] + ((*arg2 & 0x1f) << 6)) + 0x24) = edx_43;
    
    if (((edx_41 & 0x48) == 0 && ((edx_41 & 0x80) != 0 && (arg4 & 2) != 0)))
    {
        uint32_t eax_95 = sub_1001c200(*arg2, 0xffffffff, FILE_END);
        
        if (eax_95 != 0xffffffff)
        {
            int16_t var_38 = 0;
            
            if ((sub_10027f60(*arg2, &var_38, 1) == 0 && var_38 == 0x1a))
            {
                int32_t eax_102;
                int32_t edx_49;
                edx_49 = HIGHD(eax_95);
                eax_102 = LOWD(eax_95);
                
                if (sub_1002ff10(*arg2, eax_102, edx_49) == 0xffffffff)
                {
                    sub_1001be70(*arg2);
                    return *sub_1000eca0();
                }
            }
            
            if (sub_1001c200(*arg2, 0, FILE_BEGIN) == 0xffffffff)
            {
                sub_1001be70(*arg2);
                return *sub_1000eca0();
            }
        }
        else if (*sub_1000ecd0() != 0x83)
        {
            sub_1001be70(*arg2);
            return *sub_1000eca0();
        }
    }
    
    if ((edx_41 & 0x80) != 0)
    {
        if ((arg4 & 0x74000) == 0)
        {
            if ((var_3c & 0x74000) != 0)
                arg4 |= (var_3c & 0x74000);
            else
                arg4 |= 0x4000;
        }
        
        if (((arg4 & 0x74000) == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x22c, nullptr, u"(oflag & (_O_TEXT | _O_WTEXT | _…") == 1))
            breakpoint();
        
        int32_t edx_59 = (arg4 & 0x74000);
        
        if (edx_59 > 0x20000)
        {
            if (edx_59 == 0x24000)
                var_15 = 2;
            else if ((edx_59 == 0x40000 || edx_59 == 0x44000))
                var_15 = 1;
        }
        else if (edx_59 == 0x20000)
            var_15 = 2;
        else if (edx_59 == 0x4000)
            var_15 = 0;
        else if (((edx_59 == 0x10000 || edx_59 == 0x14000) && (arg4 & 0x301) == 0x301))
            var_15 = 2;
        
        if ((arg4 & 0x70000) != 0)
        {
            int32_t var_5c = 0;
            int32_t var_58_1 = 0;
            int32_t var_60_1 = 0;
            int32_t edx_61;
            
            if ((edx_41 & 0x40) == 0)
            {
                int32_t eax_119 = (dwDesiredAccess & 0xc0000000);
                
                if (eax_119 == 0x40000000)
                {
                    if ((dwCreationDisposition - 1) <= 4)
                        switch (dwCreationDisposition)
                        {
                            case CREATE_NEW:
                            case CREATE_ALWAYS:
                            case TRUNCATE_EXISTING:
                            {
                                var_58_1 = 1;
                                break;
                            }
                            case OPEN_EXISTING:
                            case OPEN_ALWAYS:
                            {
                                uint32_t eax_121;
                                eax_121 = sub_10027320(*arg2, 0, 0, FILE_END);
                                
                                if ((eax_121 | edx_61) == 0)
                                    var_58_1 = 1;
                                else
                                {
                                    uint32_t eax_124;
                                    eax_124 = sub_10027320(*arg2, 0, 0, FILE_BEGIN);
                                    
                                    if ((eax_124 & edx_61) == 0xffffffff)
                                    {
                                        sub_1001be70(*arg2);
                                        return *sub_1000eca0();
                                    }
                                }
                                break;
                            }
                        }
                }
                else if (eax_119 == 0x80000000)
                    var_60_1 = 1;
                else if ((eax_119 == 0xc0000000 && (dwCreationDisposition - 1) <= 4))
                    switch (dwCreationDisposition)
                    {
                        case CREATE_NEW:
                        case CREATE_ALWAYS:
                        case TRUNCATE_EXISTING:
                        {
                            var_58_1 = 1;
                            break;
                        }
                        case OPEN_EXISTING:
                        case OPEN_ALWAYS:
                        {
                            uint32_t eax_130;
                            eax_130 = sub_10027320(*arg2, 0, 0, FILE_END);
                            
                            if ((eax_130 | edx_61) == 0)
                                var_58_1 = 1;
                            else
                            {
                                uint32_t eax_133;
                                eax_133 = sub_10027320(*arg2, 0, 0, FILE_BEGIN);
                                
                                if ((eax_133 & edx_61) == 0xffffffff)
                                {
                                    sub_1001be70(*arg2);
                                    return *sub_1000eca0();
                                }
                                
                                var_60_1 = 1;
                            }
                            break;
                        }
                    }
            }
            
            if (var_60_1 != 0)
            {
                int32_t eax_139;
                eax_139 = sub_10027f60(*arg2, &var_5c, 3);
                
                if ((eax_139 > 0 && var_58_1 == 1))
                {
                    int32_t eax_140;
                    eax_140 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2a1, nullptr, u"0 && "Internal Error"");
                    
                    if (eax_140 == 1)
                        breakpoint();
                    
                    var_58_1 = 0;
                }
                
                if (eax_139 == 0xffffffff)
                {
                    sub_1001be70(*arg2);
                    return *sub_1000eca0();
                }
                
                if (eax_139 == 2)
                {
                label_10029ce0:
                    
                    if (var_5c == 0xfffe)
                    {
                        sub_1001be70(*arg2);
                        
                        if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2b5, nullptr, u"0 && "Only UTF-16 little endian …") == 1)
                            breakpoint();
                        
                        *sub_1000eca0() = 0x16;
                        return 0x16;
                    }
                    
                    if (var_5c != 0xfeff)
                        goto label_10029d89;
                    
                    uint32_t eax_149;
                    eax_149 = sub_1001c200(*arg2, 2, FILE_BEGIN);
                    
                    if (eax_149 == 0xffffffff)
                    {
                        sub_1001be70(*arg2);
                        return *sub_1000eca0();
                    }
                    
                    var_15 = 2;
                }
                else if (eax_139 == 3)
                {
                    if (var_5c != 0xbfbbef)
                        goto label_10029ce0;
                    
                    var_15 = 1;
                }
                else
                {
                label_10029d89:
                    uint32_t eax_153;
                    eax_153 = sub_1001c200(*arg2, 0, FILE_BEGIN);
                    
                    if (eax_153 == 0xffffffff)
                    {
                        sub_1001be70(*arg2);
                        return *sub_1000eca0();
                    }
                }
            }
            
            if (var_58_1 != 0)
            {
                int32_t i = 0;
                int32_t var_64_1 = 0;
                var_5c = 0;
                edx_61 = var_15;
                char var_bc_1 = edx_61;
                
                if (var_bc_1 == 1)
                {
                    var_5c = 0xbfbbef;
                    var_64_1 = 3;
                }
                else if (var_bc_1 == 2)
                {
                    var_5c = 0xfeff;
                    var_64_1 = 2;
                }
                
                int32_t eax_158;
                
                for (; var_64_1 > i; i += eax_158)
                {
                    int32_t var_6c_1 = 0;
                    int32_t __saved_ebp;
                    eax_158 = sub_1001aef0(*arg2, ((&__saved_ebp + i) - 0x58), (var_64_1 - i));
                    
                    if (eax_158 == 0xffffffff)
                    {
                        sub_1001be70(*arg2);
                        return *sub_1000eca0();
                    }
                }
            }
        }
    }
    
    int32_t* eax_163;
    eax_163 = var_15;
    eax_163 &= 0x7f;
    int32_t ecx_93;
    ecx_93 = *((&data_10049260[(*arg2 >> 5)] + ((*arg2 & 0x1f) << 6)) + 0x24);
    ecx_93 &= 0x80;
    ecx_93 |= eax_163;
    *((&data_10049260[(*arg2 >> 5)] + ((*arg2 & 0x1f) << 6)) + 0x24) = ecx_93;
    int32_t ecx_95 = (arg4 & 0x10000);
    int32_t ecx_96 = -(ecx_95);
    int32_t edx_91;
    edx_91 = *((&data_10049260[(*arg2 >> 5)] + ((*arg2 & 0x1f) << 6)) + 0x24);
    edx_91 &= 0x7f;
    edx_91 |= ((-((ecx_96 - ecx_96)) & 1) << 7);
    *((&data_10049260[(*arg2 >> 5)] + ((*arg2 & 0x1f) << 6)) + 0x24) = edx_91;
    
    if (((edx_41 & 0x48) == 0 && (arg4 & 8) != 0))
        *((&data_10049260[(*arg2 >> 5)] + ((*arg2 & 0x1f) << 6)) + 4) |= 0x20;
    
    if (((dwDesiredAccess & 0xc0000000) == 0xc0000000 && (arg4 & 1) != 0))
    {
        CloseHandle(var_24_1);
        HANDLE eax_185 = CreateFileW(arg3, (dwDesiredAccess & 0x7fffffff), dwShareMode, &lpSecurityAttributes, OPEN_EXISTING, dwFlagsAndAttributes, nullptr);
        
        if (eax_185 == 0xffffffff)
        {
            ___acrt_errno_map_os_error(GetLastError());
            *((&data_10049260[(*arg2 >> 5)] + ((*arg2 & 0x1f) << 6)) + 4) &= 0xfe;
            __free_osfhnd(*arg2);
            return *sub_1000eca0();
        }
        
        *(((*arg2 & 0x1f) << 6) + &data_10049260[(*arg2 >> 5)]) = eax_185;
    }
    
    return result;
}

int32_t __sopen_s(int32_t* arg1, PWSTR arg2, int32_t arg3, int32_t arg4, int32_t arg5)
{
    return sub_10028eb0(arg2, arg3, arg4, arg5, arg1, 1);
}

uint32_t sub_1002a140(int16_t* arg1, int16_t* arg2, int32_t arg3, void** arg4)
{
    uint32_t result = 0;
    
    if (arg3 != 0)
    {
        int32_t eax_1;
        eax_1 = arg1 != 0;
        
        if ((eax_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3d, nullptr, u"first != NULL") == 1))
            breakpoint();
        
        if (eax_1 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"first != NULL", u"_wcsnicmp_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3d, 0);
            return 0x7fffffff;
        }
        
        int32_t edx_1;
        edx_1 = arg2 != 0;
        
        if ((edx_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3e, nullptr, u"last != NULL") == 1))
            breakpoint();
        
        if (edx_1 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"last != NULL", u"_wcsnicmp_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3e, 0);
            return 0x7fffffff;
        }
        
        void var_20;
        _LocaleUpdate::_LocaleUpdate(&var_20, arg4);
        int16_t var_c_1;
        int16_t var_8_1;
        
        if (*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_20) + 0x14) != 0)
        {
            do
            {
                void** eax_17 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_20);
                var_8_1 = sub_10024720(*arg1, eax_17);
                void** eax_20 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_20);
                var_c_1 = sub_10024720(*arg2, eax_20);
                arg1 = &arg1[1];
                arg2 = &arg2[1];
                bool cond:0_1 = arg3 == 1;
                arg3 -= 1;
                
                if (cond:0_1)
                    break;
                
                if (var_8_1 == 0)
                    break;
            } while (var_8_1 == var_c_1);
        }
        else
        {
            do
            {
                int16_t var_2c_1;
                
                if ((*arg1 < 0x41 || *arg1 > 0x5a))
                    var_2c_1 = *arg1;
                else
                    var_2c_1 = (*arg1 + 0x20);
                
                int16_t* edx_2;
                edx_2 = var_2c_1;
                var_8_1 = edx_2;
                int16_t var_30_1;
                
                if ((*arg2 < 0x41 || *arg2 > 0x5a))
                    var_30_1 = *arg2;
                else
                    var_30_1 = (*arg2 + 0x20);
                
                edx_2 = var_30_1;
                var_c_1 = edx_2;
                arg1 = &arg1[1];
                arg2 = &arg2[1];
                bool cond:1_1 = arg3 == 1;
                arg3 -= 1;
                
                if (cond:1_1)
                    break;
                
                if (var_8_1 == 0)
                    break;
            } while (var_8_1 == var_c_1);
        }
        
        result = (var_8_1 - var_c_1);
        _LocaleUpdate::~_LocaleUpdate(&var_20);
    }
    
    return result;
}

uint32_t sub_1002a370(int16_t* arg1, int16_t* arg2, int32_t arg3)
{
    if (data_10045ca8 != 0)
        return sub_1002a140(arg1, arg2, arg3, nullptr);
    
    if (arg3 == 0)
        return 0;
    
    int16_t* eax_1;
    eax_1 = arg1 != 0;
    
    if ((eax_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x6d, nullptr, u"first != NULL") == 1))
        breakpoint();
    
    if (eax_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"first != NULL", u"_wcsnicmp", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x6d, 0);
        return 0x7fffffff;
    }
    
    int32_t edx_1;
    edx_1 = arg2 != 0;
    
    if ((edx_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x6e, nullptr, u"last != NULL") == 1))
        breakpoint();
    
    if (edx_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"last != NULL", u"_wcsnicmp", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x6e, 0);
        return 0x7fffffff;
    }
    
    int16_t var_c_1;
    int16_t var_8_1;
    
    do
    {
        int16_t var_1c_1;
        
        if ((*arg1 < 0x41 || *arg1 > 0x5a))
            var_1c_1 = *arg1;
        else
            var_1c_1 = (*arg1 + 0x20);
        
        eax_1 = var_1c_1;
        var_8_1 = eax_1;
        int16_t var_20_1;
        
        if ((*arg2 < 0x41 || *arg2 > 0x5a))
            var_20_1 = *arg2;
        else
            var_20_1 = (*arg2 + 0x20);
        
        eax_1 = var_20_1;
        var_c_1 = eax_1;
        arg1 = &arg1[1];
        arg2 = &arg2[1];
        bool cond:0_1 = arg3 == 1;
        arg3 -= 1;
        
        if (cond:0_1)
            break;
        
        if (var_8_1 == 0)
            break;
    } while (var_8_1 == var_c_1);
    
    return (var_8_1 - var_c_1);
}

uint32_t _wcsncmp(int16_t* arg1, int16_t* arg2, int32_t arg3)
{
    if (arg3 == 0)
        return 0;
    
    while (true)
    {
        bool cond:0_1 = arg3 == 1;
        arg3 -= 1;
        
        if (((cond:0_1 || *arg1 == 0) || *arg1 != *arg2))
            return (*arg1 - *arg2);
        
        arg1 = &arg1[1];
        arg2 = &arg2[1];
    }
}

int32_t sub_1002a588(int32_t arg1)
{
    int32_t ebp;
    int32_t var_4 = ebp;
    int32_t result = RtlUnwind(arg1, &data_1002a5a0, nullptr, nullptr);
    var_4;
    return result;
}

int32_t __unwind_handler(int32_t arg1, int32_t arg2, int32_t* arg3, void* arg4)
{
    if ((*(arg1 + 4) & 6) == 0)
        return 1;
    
    void* eax_2 = sub_1000ac70((*(arg4 - 4) ^ arg4));
    *(eax_2 + 0x10);
    __local_unwind2(*(eax_2 + 0x24), *(eax_2 + 0x28));
    *arg3 = arg2;
    return 3;
}

void* __local_unwind2(void* arg1, int32_t arg2)
{
    int32_t ebp;
    int32_t var_10 = ebp;
    void* var_14 = arg1;
    int32_t var_18 = 0xfffffffe;
    int32_t (* var_1c)(int32_t arg1, int32_t arg2, int32_t* arg3, void* arg4) = __unwind_handler;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t var_24 = (__security_cookie ^ &ExceptionList);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    
    while (true)
    {
        int32_t ebx_1 = *(arg1 + 8);
        int32_t esi_1 = *(arg1 + 0xc);
        
        if (esi_1 == 0xffffffff)
        {
            fsbase->NtTib.ExceptionList = ExceptionList;
            return arg1;
        }
        
        if ((arg2 != 0xffffffff && esi_1 <= arg2))
        {
            fsbase->NtTib.ExceptionList = ExceptionList;
            return arg1;
        }
        
        int32_t esi_2 = (esi_1 * 3);
        int32_t ecx_1 = *(ebx_1 + (esi_2 << 2));
        int32_t var_18_1 = ecx_1;
        *(arg1 + 0xc) = ecx_1;
        
        if (*((ebx_1 + (esi_2 << 2)) + 4) == 0)
        {
            __NLG_Notify(*((ebx_1 + (esi_2 << 2)) + 8), ebp, 0x101);
            *((ebx_1 + (esi_2 << 2)) + 8);
            __NLG_Call();
        }
    }
}

int32_t __abnormal_termination()
{
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    
    if ((ExceptionList->Handler == __unwind_handler && *(ExceptionList + 8) == *(*(ExceptionList + 0xc) + 0xc)))
        return 1;
    
    return 0;
}

int32_t __convention("regparm") __NLG_Notify1(int32_t arg1, int32_t, int32_t arg3, int32_t arg4 @ ebp)
{
    int32_t var_8 = arg3;
    data_10044e18 = arg3;
    data_10044e14 = arg1;
    data_10044e1c = arg4;
    int32_t var_c = arg4;
    int32_t var_10 = arg3;
    return arg1;
}

int32_t __stdcall __NLG_Notify(int32_t arg1 @ eax, int32_t arg2 @ ebp, int32_t arg3)
{
    data_10044e18 = arg3;
    data_10044e14 = arg1;
    data_10044e1c = arg2;
    int32_t var_c = arg2;
    int32_t var_10 = arg3;
    return arg1;
}

int32_t __NLG_Call()
{
    int32_t eax;
    return eax();
}

int32_t sub_1002a6c0()
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_38 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x100421b8 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_3c = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result_1 = 0xffffffff;
    int32_t var_24 = 0;
    int32_t result;
    
    if (sub_10013830(0xb) != 0)
    {
        __lock(0xb);
        int32_t var_8_1 = 0;
        
        for (int32_t i = 0; i < 0x40; i += 1)
        {
            if (&data_10049260[i] == 0)
            {
                void* j = sub_10010b10(0x20, 0x40, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x90);
                
                if (j != 0)
                {
                    &data_10049260[i] = j;
                    data_10049258 += 0x20;
                    
                    for (; j < (&data_10049260[i] + 0x800); j += 0x40)
                    {
                        *(j + 4) = 0;
                        *j = 0xffffffff;
                        *(j + 5) = 0xa;
                        *(j + 8) = 0;
                    }
                    
                    result_1 = (i << 5);
                    *((&data_10049260[(result_1 >> 5)] + ((result_1 & 0x1f) << 6)) + 4) = 1;
                    
                    if (sub_1002aca0(result_1) == 0)
                        result_1 = 0xffffffff;
                }
                
                break;
            }
            
            for (void* j_1 = &data_10049260[i]; j_1 < (&data_10049260[i] + 0x800); j_1 += 0x40)
            {
                if ((*(j_1 + 4) & 1) == 0)
                {
                    if (*(j_1 + 8) == 0)
                    {
                        __lock(0xa);
                        int32_t var_8_2 = 1;
                        
                        if (*(j_1 + 8) == 0)
                        {
                            if (`eh vector constructor iterator'((j_1 + 0xc), 0xfa0) != 0)
                                *(j_1 + 8) += 1;
                            else
                                var_24 = 1;
                        }
                        
                        int32_t var_8_3 = 0;
                        sub_1002a7f5();
                    }
                    
                    if (var_24 != 0)
                    {
                    label_1002a831:
                        
                        if (var_24 == 0)
                        {
                            *(j_1 + 4) = 1;
                            *j_1 = 0xffffffff;
                            result_1 = ((i << 5) + ((j_1 - &data_10049260[i]) >> 6));
                            break;
                        }
                    }
                    else
                    {
                        EnterCriticalSection((j_1 + 0xc));
                        
                        if ((*(j_1 + 4) & 1) == 0)
                            goto label_1002a831;
                        
                        LeaveCriticalSection((j_1 + 0xc));
                    }
                }
            }
            
            if (result_1 != 0xffffffff)
                break;
        }
        
        int32_t var_8_4 = 0xfffffffe;
        sub_1002a94d();
        result = result_1;
    }
    else
        result = 0xffffffff;
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1002a7f5()
{
    return __unlock(0xa);
}

int32_t sub_1002a94d()
{
    return __unlock(0xb);
}

int32_t __set_osfhnd(int32_t arg1, HANDLE arg2)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if ((arg1 < 0 || (arg1 >= data_10049258 || *(((arg1 & 0x1f) << 6) + &data_10049260[(arg1 >> 5)]) != 0xffffffff)))
    {
        *sub_1000eca0() = 9;
        *sub_1000ecd0() = 0;
        return 0xffffffff;
    }
    
    if (data_10045614 == 1)
    {
        if (arg1 == 0)
            SetStdHandle(STD_INPUT_HANDLE, arg2);
        else if (arg1 == 1)
            SetStdHandle(STD_OUTPUT_HANDLE, arg2);
        else if (arg1 == 2)
            SetStdHandle(STD_ERROR_HANDLE, arg2);
    }
    
    *(((arg1 & 0x1f) << 6) + &data_10049260[(arg1 >> 5)]) = arg2;
    return 0;
}

int32_t __free_osfhnd(int32_t arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if ((arg1 < 0 || (arg1 >= data_10049258 || ((*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 1) == 0 || *(((arg1 & 0x1f) << 6) + &data_10049260[(arg1 >> 5)]) == 0xffffffff))))
    {
        *sub_1000eca0() = 9;
        *sub_1000ecd0() = 0;
        return 0xffffffff;
    }
    
    if (data_10045614 == 1)
    {
        if (arg1 == 0)
            SetStdHandle(STD_INPUT_HANDLE, nullptr);
        else if (arg1 == 1)
            SetStdHandle(STD_OUTPUT_HANDLE, nullptr);
        else if (arg1 == 2)
            SetStdHandle(STD_ERROR_HANDLE, nullptr);
    }
    
    *(((arg1 & 0x1f) << 6) + &data_10049260[(arg1 >> 5)]) = 0xffffffff;
    return 0;
}

int32_t sub_1002ab30(int32_t arg1)
{
    if (arg1 == 0xfffffffe)
    {
        *sub_1000ecd0() = 0;
        *sub_1000eca0() = 9;
        return 0xffffffff;
    }
    
    int32_t var_10_1;
    
    if ((arg1 < 0 || arg1 >= data_10049258))
        var_10_1 = 0;
    else
        var_10_1 = 1;
    
    if ((var_10_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13a, nullptr, u"(fh >= 0 && (unsigned)fh < (unsi…") == 1))
        breakpoint();
    
    if (var_10_1 == 0)
    {
        *sub_1000ecd0() = 0;
        *sub_1000eca0() = 9;
        sub_1000c310(u"(fh >= 0 && (unsigned)fh < (unsi…", u"_get_osfhandle", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13a, 0);
        return 0xffffffff;
    }
    
    int32_t eax_11 = (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 1);
    int32_t eax_12 = -(eax_11);
    int32_t eax_14 = -((eax_12 - eax_12));
    
    if ((eax_14 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13b, nullptr, u"(_osfile(fh) & FOPEN)") == 1))
        breakpoint();
    
    if (eax_14 != 0)
        return *(((arg1 & 0x1f) << 6) + &data_10049260[(arg1 >> 5)]);
    
    *sub_1000ecd0() = 0;
    *sub_1000eca0() = 9;
    sub_1000c310(u"(_osfile(fh) & FOPEN)", u"_get_osfhandle", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x13b, 0);
    return 0xffffffff;
}

int32_t sub_1002aca0(int32_t arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (0x100421e0 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_34 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void* ecx_3 = (((arg1 & 0x1f) << 6) + &data_10049260[(arg1 >> 5)]);
    int32_t result = 1;
    
    if (*(ecx_3 + 8) == 0)
    {
        __lock(0xa);
        int32_t var_8_1 = 0;
        
        if (*(ecx_3 + 8) == 0)
        {
            if (`eh vector constructor iterator'((ecx_3 + 0xc), 0xfa0) == 0)
                result = 0;
            
            *(ecx_3 + 8) += 1;
        }
        
        int32_t var_8_2 = 0xfffffffe;
        sub_1002ad51();
    }
    
    if (result != 0)
        EnterCriticalSection(((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0xc));
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1002ad51()
{
    return __unlock(0xa);
}

int32_t __unlock_fhandle(int32_t arg1)
{
    return LeaveCriticalSection(((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0xc));
}

int32_t sub_1002add0()
{
    int32_t __saved_ebp;
    BOOL var_10 = (__security_cookie ^ &__saved_ebp);
    
    if (data_10044e20 == 0)
        goto label_1002ae5e;
    
    if (data_10044f48 == 0xfffffffe)
        ___initconout();
    
    void lpNumberOfCharsWritten;
    
    if (data_10044f48 != 0xffffffff)
    {
        if (WriteConsoleW(data_10044f48, &arg_4, 1, &lpNumberOfCharsWritten, nullptr) != 0)
        {
            data_10044e20 = 1;
        label_1002ae5e:
            BOOL eax_1;
            
            if (data_10044e20 != 0)
                eax_1 = arg_4;
            else
            {
                void var_18;
                int32_t nNumberOfCharsToWrite = WideCharToMultiByte(GetConsoleOutputCP(), 0, &arg_4, 1, &var_18, 5, nullptr, nullptr);
                
                if ((data_10044f48 != 0xffffffff && WriteConsoleA(data_10044f48, &var_18, nNumberOfCharsToWrite, &lpNumberOfCharsWritten, nullptr) != 0))
                    eax_1 = arg_4;
            }
        }
        else if ((data_10044e20 == 2 && GetLastError() == 0x78))
        {
            data_10044e20 = 0;
            goto label_1002ae5e;
        }
    }
    return sub_1000ac70((var_10 ^ &__saved_ebp));
}

int32_t sub_1002aed0(char arg1)
{
    return sub_1002aef0(nullptr, arg1, 0, 4);
}

int32_t sub_1002aef0(void** arg1, char arg2, int32_t arg3, int32_t arg4)
{
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = __ehhandler$___std_fs_get_file_id@8;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_ebp;
    int32_t var_30 = (__security_cookie ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void var_20;
    _LocaleUpdate::_LocaleUpdate(&var_20, arg1);
    int32_t var_8_1 = 0;
    arg2 = arg2;
    int32_t ecx_4 = (*((*(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_20) + 4) + arg2) + 0x1d) & arg4);
    int32_t var_28_1;
    
    if (ecx_4 == 0)
    {
        if (arg3 == 0)
            var_28_1 = 0;
        else
            var_28_1 = (*(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_20) + 0xc8) + (arg2 << 1)) & arg3);
    }
    
    int32_t result;
    
    if ((ecx_4 != 0 || var_28_1 != 0))
        result = 1;
    else
        result = 0;
    
    int32_t var_8_2 = 0xffffffff;
    _LocaleUpdate::~_LocaleUpdate(&var_20);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t __convention("regparm") sub_1002afc0(int32_t arg1, int32_t* arg2, char* arg3, int32_t arg4, void** arg5)
{
    if ((arg3 == 0 && arg4 > 0))
    {
        if (arg2 != 0)
            *arg2 = 0;
        
        return 0;
    }
    
    if (arg2 != 0)
        *arg2 = 0xffffffff;
    
    int32_t eax_1 = (arg1 - arg1);
    
    if ((eax_1 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x4a, nullptr, u"sizeInBytes <= INT_MAX") == 1))
        breakpoint();
    
    if (eax_1 == 0xffffffff)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"sizeInBytes <= INT_MAX", u"_wctomb_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x4a, 0);
        return 0x16;
    }
    
    void var_14;
    _LocaleUpdate::_LocaleUpdate(&var_14, arg5);
    void* eax_7 = *_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14);
    
    if (*(eax_7 + 0x14) == 0)
    {
        if (lpWideCharStr <= 0xff)
        {
            if (arg3 != 0)
            {
                int32_t eax_12 = -((eax_7 - eax_7));
                
                if ((eax_12 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5d, nullptr, u"sizeInBytes > 0") == 1))
                    breakpoint();
                
                if (eax_12 == 0)
                {
                    *sub_1000eca0() = 0x22;
                    sub_1000c310(u"sizeInBytes > 0", u"_wctomb_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5d, 0);
                    _LocaleUpdate::~_LocaleUpdate(&var_14);
                    return 0x22;
                }
                
                eax_12 = lpWideCharStr;
                *arg3 = eax_12;
            }
            
            if (arg2 != 0)
                *arg2 = 1;
            
            _LocaleUpdate::~_LocaleUpdate(&var_14);
            return 0;
        }
        
        if ((arg3 != 0 && arg4 > 0))
            sub_1000fae0(arg3, 0, arg4);
        
        *sub_1000eca0() = 0x2a;
        int32_t ecx_5 = *sub_1000eca0();
        _LocaleUpdate::~_LocaleUpdate(&var_14);
        return ecx_5;
    }
    
    BOOL lpUsedDefaultChar = 0;
    int32_t eax_17 = WideCharToMultiByte(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14) + 4), 0, &lpWideCharStr, 1, arg3, arg4, nullptr, &lpUsedDefaultChar);
    
    if ((eax_17 != 0 && lpUsedDefaultChar == 0))
    {
        if (arg2 != 0)
            *arg2 = eax_17;
        
        _LocaleUpdate::~_LocaleUpdate(&var_14);
        return 0;
    }
    
    if ((eax_17 == 0 && GetLastError() == ERROR_INSUFFICIENT_BUFFER))
    {
        if ((arg3 != 0 && arg4 > 0))
            sub_1000fae0(arg3, 0, arg4);
        
        int32_t var_44_1 = 0;
        
        if ((var_44_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x7b, nullptr, u"("Buffer too small", 0)") == 1))
            breakpoint();
        
        if (var_44_1 == 0)
        {
            *sub_1000eca0() = 0x22;
            sub_1000c310(u"("Buffer too small", 0)", u"_wctomb_s_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x7b, 0);
            _LocaleUpdate::~_LocaleUpdate(&var_14);
            return 0x22;
        }
    }
    
    *sub_1000eca0() = 0x2a;
    int32_t ecx_14 = *sub_1000eca0();
    _LocaleUpdate::~_LocaleUpdate(&var_14);
    return ecx_14;
}

void* sub_1002b171(int32_t* arg1 @ ebp)
{
    void* result = _LocaleUpdate::~_LocaleUpdate(&arg1[-4]);
    *arg1;
    return result;
}

int32_t _wctomb_s(int32_t arg1, int32_t* arg2, char* arg3, int16_t arg4)
{
    int32_t var_8 = 0;
    uint32_t var_c = arg4;
    char* var_10 = arg3;
    return sub_1002afc0(arg1, arg2, arg3, arg1, arg2);
}

int32_t sub_1002b2f0(void* arg1, int32_t* arg2, int32_t arg3)
{
    if (data_10045ca8 != 0)
        return sub_1002b340(nullptr, arg1, arg2, arg3, 0);
    
    return sub_1002b340(&data_10044c20, arg1, arg2, arg3, 0);
}

int32_t sub_1002b340(void** arg1, void* arg2, int32_t* arg3, int32_t arg4, int32_t arg5)
{
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = sub_10034608;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_ebp;
    int32_t var_5c = (__security_cookie ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void var_30;
    _LocaleUpdate::_LocaleUpdate(&var_30, arg1);
    int32_t var_8_1 = 0;
    
    if (arg3 != 0)
        *arg3 = arg2;
    
    int32_t eax_4;
    eax_4 = arg2 != 0;
    
    if ((eax_4 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5e, nullptr, u"nptr != NULL") == 1))
        breakpoint();
    
    int32_t result;
    
    if (eax_4 != 0)
    {
        int32_t var_50_1;
        
        if ((arg4 == 0 || (arg4 >= 2 && arg4 <= 0x24)))
            var_50_1 = 1;
        else
            var_50_1 = 0;
        
        if ((var_50_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5f, nullptr, u"ibase == 0 || (2 <= ibase && iba…") == 1))
            breakpoint();
        
        if (var_50_1 != 0)
        {
            char* var_14_1 = arg2;
            int32_t result_1 = 0;
            eax_4 = *var_14_1;
            char var_1d_1 = eax_4;
            void* var_14_2 = &var_14_1[1];
            int32_t eax_11;
            
            while (true)
            {
                int32_t eax_7 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_30);
                void* edx_4;
                
                if (eax_7 != 0)
                    edx_4 = *_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_30);
                
                int32_t var_54_1;
                
                if ((eax_7 == 0 || *(edx_4 + 0xac) <= 1))
                    var_54_1 = sub_10024350(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_30), var_1d_1, 8);
                else
                    var_54_1 = sub_10024400(var_1d_1, 8, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_30));
                
                if (var_54_1 == 0)
                    break;
                
                eax_11 = *var_14_2;
                var_1d_1 = eax_11;
                var_14_2 += 1;
            }
            
            if (var_1d_1 == 0x2d)
            {
                arg5 |= 2;
                int32_t edx_6;
                edx_6 = *var_14_2;
                var_1d_1 = edx_6;
                var_14_2 += 1;
            }
            else if (var_1d_1 == 0x2b)
            {
                eax_11 = *var_14_2;
                var_1d_1 = eax_11;
                var_14_2 += 1;
            }
            
            if (((arg4 < 0 || arg4 == 1) || arg4 > 0x24))
            {
                if (arg3 != 0)
                    *arg3 = arg2;
                
                int32_t var_8_4 = 0xffffffff;
                _LocaleUpdate::~_LocaleUpdate(&var_30);
                result = 0;
            }
            else
            {
                if (arg4 == 0)
                {
                    if (var_1d_1 != 0x30)
                        arg4 = 0xa;
                    else if ((*var_14_2 == 0x78 || *var_14_2 == 0x58))
                        arg4 = 0x10;
                    else
                        arg4 = 8;
                }
                
                if (arg4 == 0)
                {
                    if (var_1d_1 != 0x30)
                        arg4 = 0xa;
                    else if ((*var_14_2 == 0x78 || *var_14_2 == 0x58))
                        arg4 = 0x10;
                    else
                        arg4 = 8;
                }
                
                if ((arg4 == 0x10 && (var_1d_1 == 0x30 && (*var_14_2 == 0x78 || *var_14_2 == 0x58))))
                {
                    void* eax_21;
                    eax_21 = *(var_14_2 + 1);
                    var_1d_1 = eax_21;
                    var_14_2 += 2;
                }
                
                uint32_t temp0_1 = (COMBINE(0, 0xffffffff) / arg4);
                
                while (true)
                {
                    int32_t var_18_1;
                    
                    if (sub_10024350(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_30), var_1d_1, 4) == 0)
                    {
                        if (sub_10024350(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_30), var_1d_1, 0x103) == 0)
                            break;
                        
                        int32_t var_58_1;
                        
                        if ((var_1d_1 < 0x61 || var_1d_1 > 0x7a))
                            var_58_1 = var_1d_1;
                        else
                            var_58_1 = (var_1d_1 - 0x20);
                        
                        var_18_1 = (var_58_1 - 0x37);
                    }
                    else
                        var_18_1 = (var_1d_1 - 0x30);
                    
                    if (var_18_1 >= arg4)
                        break;
                    
                    arg5 |= 8;
                    
                    if ((result_1 < temp0_1 || (result_1 == temp0_1 && var_18_1 <= (COMBINE(0, 0xffffffff) % arg4))))
                        result_1 = ((result_1 * arg4) + var_18_1);
                    else
                    {
                        arg5 |= 4;
                        
                        if (arg3 == 0)
                            break;
                    }
                    
                    int32_t edx_21;
                    edx_21 = *var_14_2;
                    var_1d_1 = edx_21;
                    var_14_2 += 1;
                }
                
                void* var_14_4 = (var_14_2 - 1);
                
                if ((arg5 & 8) == 0)
                {
                    if (arg3 != 0)
                        var_14_4 = arg2;
                    
                    result_1 = 0;
                }
                else if ((arg5 & 4) != 0)
                {
                label_1002b7a9:
                    *sub_1000eca0() = 0x22;
                    
                    if ((arg5 & 1) != 0)
                        result_1 = 0xffffffff;
                    else if ((arg5 & 2) == 0)
                        result_1 = 0x7fffffff;
                    else
                        result_1 = 0x80000000;
                }
                else if ((arg5 & 1) == 0)
                {
                    if (((arg5 & 2) != 0 && result_1 > 0x80000000))
                        goto label_1002b7a9;
                    
                    if (((arg5 & 2) == 0 && result_1 > 0x7fffffff))
                        goto label_1002b7a9;
                }
                
                if (arg3 != 0)
                    *arg3 = var_14_4;
                
                if ((arg5 & 2) != 0)
                    result_1 = -(result_1);
                
                int32_t var_8_5 = 0xffffffff;
                _LocaleUpdate::~_LocaleUpdate(&var_30);
                result = result_1;
            }
        }
        else
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"ibase == 0 || (2 <= ibase && iba…", u"strtoxl", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5f, 0);
            int32_t var_8_3 = 0xffffffff;
            _LocaleUpdate::~_LocaleUpdate(&var_30);
            result = 0;
        }
    }
    else
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"nptr != NULL", u"strtoxl", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x5e, 0);
        int32_t var_8_2 = 0xffffffff;
        _LocaleUpdate::~_LocaleUpdate(&var_30);
        result = 0;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t _JumpToContinuation(int32_t arg1, void* arg2)
{
    void* var_8 = (arg2 + 0xc);
    TEB* fsbase;
    fsbase->NtTib.ExceptionList = fsbase->NtTib.ExceptionList->Next;
    *(arg2 - 4);
    /* jump -> arg1 */
}

int32_t sub_1002b860(int32_t arg1, void* const arg2)
{
    void* const temp0 = arg2;
    arg2 = __return_addr;
    /* jump -> temp0 */
}

EXCEPTION_RECORD* __stdcall sub_1002b870(int32_t arg1, EXCEPTION_RECORD* arg2)
{
    int32_t edi;
    int32_t var_18 = edi;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    RtlUnwind(arg1, &data_1002b89f, arg2, nullptr);
    arg2->ExceptionFlags &= 0xfffffffd;
    ExceptionList->Next = fsbase->NtTib.ExceptionList;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg2;
}

int32_t __convention("regparm") sub_1002b8d0(int32_t* arg1, int32_t* arg2, int32_t* arg3, int32_t arg4, void* arg5)
{
    return sub_10030510(arg2, arg3, arg4, arg5, arg1, 0, 0, 0);
}

int32_t sub_1002b910(int32_t arg1, int32_t arg2, int32_t* arg3, int32_t arg4, int32_t arg5)
{
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = nullptr;
    int32_t (* var_18)(int32_t* arg1, void* arg2, int32_t arg3) = sub_1002b980;
    int32_t var_14 = (__security_cookie ^ &ExceptionList);
    int32_t var_10 = arg2;
    int32_t var_c = arg1;
    int32_t var_8 = (arg4 + 1);
    TEB* fsbase;
    ExceptionList = fsbase->NtTib.ExceptionList;
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t result = __CallSettingFrame@12(arg3, arg3, arg1, arg5);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1002b980(int32_t* arg1, void* arg2, int32_t arg3)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    sub_1000ac70((*(arg2 + 8) ^ arg2));
    return sub_10030510(arg1, *(arg2 + 0x10), arg3, nullptr, *(arg2 + 0xc), *(arg2 + 0x14), arg2, 0);
}

int32_t sub_1002b9d0(int32_t* arg1, int32_t* arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6)
{
    if (arg1 == 0x123)
    {
        *arg2 = 0x1002ba8e;
        return 1;
    }
    
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = nullptr;
    int32_t (__convention("regparm")* var_28_1)(int32_t arg1, int32_t arg2, int32_t arg3, EXCEPTION_RECORD* arg4, void* arg5, int32_t arg6) = sub_1002bac0;
    int32_t var_24_1 = (__security_cookie ^ &ExceptionList);
    int32_t var_20_1 = arg4;
    int32_t* var_1c_1 = arg2;
    int32_t var_18_1 = arg5;
    int32_t var_14_1 = arg6;
    int32_t var_10_1 = 0;
    int32_t var_c_1 = 0;
    int32_t var_8_1 = 0;
    int32_t __saved_ebx;
    int32_t* var_10_2 = &__saved_ebx;
    int32_t __saved_ebp;
    int32_t* var_c_2 = &__saved_ebp;
    TEB* fsbase;
    ExceptionList = fsbase->NtTib.ExceptionList;
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_3c_1 = 1;
    int32_t* var_38 = arg1;
    int32_t var_34_1 = arg3;
    int32_t edx_3 = *(__getptd() + 0x80);
    edx_3(*arg1, &var_38);
    
    if (var_8_1 == 0)
        fsbase->NtTib.ExceptionList = ExceptionList;
    else
    {
        struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList_1 = ExceptionList;
        ExceptionList_1->Next = fsbase->NtTib.ExceptionList->Next;
        fsbase->NtTib.ExceptionList = ExceptionList_1;
    }
    
    return 0;
}

int32_t __convention("regparm") sub_1002bac0(int32_t arg1, int32_t arg2, int32_t arg3, EXCEPTION_RECORD* arg4, void* arg5, int32_t arg6)
{
    int32_t var_8 = arg3;
    sub_1000ac70((*(arg5 + 8) ^ arg5));
    
    if ((arg4->ExceptionFlags & 0x66) != 0)
    {
        *(arg5 + 0x24) = 1;
        return 1;
    }
    
    sub_10030510(arg4, *(arg5 + 0x10), arg6, nullptr, *(arg5 + 0xc), *(arg5 + 0x14), *(arg5 + 0x18), 1);
    
    if (*(arg5 + 0x24) == 0)
        sub_1002b870(arg5, arg4);
    
    int32_t var_10_2 = 0;
    sub_1002b9d0(0x123, &var_8, 0, 0, 0, 0);
    *(arg5 + 0x1c);
    *(arg5 + 0x20);
    /* jump -> var_8 */
}

int32_t sub_1002bb70(void* arg1, int32_t arg2, int32_t arg3, int32_t* arg4, int32_t* arg5)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    void* eax = arg1;
    int32_t ecx_1 = *(eax + 0x10);
    int32_t esi = *(eax + 0xc);
    int32_t edi;
    int32_t var_14 = edi;
    int32_t edi_1 = esi;
    int32_t ebx = esi;
    
    if (arg2 >= 0)
    {
        do
        {
            if (esi == 0xffffffff)
                sub_10016230();
            
            esi -= 1;
            int32_t edx_1 = (esi * 5);
            
            if (*((ecx_1 + (edx_1 << 2)) + 4) >= arg3)
            {
                if (esi == 0xffffffff)
                    goto label_1002bbb7;
            }
            else if ((arg3 <= *((ecx_1 + (edx_1 << 2)) + 8) || esi == 0xffffffff))
            {
            label_1002bbb7:
                arg2 -= 1;
                edi_1 = ebx;
                ebx = esi;
            }
        } while (arg2 >= 0);
        
        eax = arg1;
    }
    
    *arg4 = (esi + 1);
    *arg5 = edi_1;
    
    if ((edi_1 > *(eax + 0xc) || (esi + 1) > edi_1))
        sub_10016230();
    
    return (ecx_1 + ((esi + 1) * 0x14));
}

int32_t* sub_1002bbf0(int32_t* arg1, int32_t arg2)
{
    *arg1 = arg2;
    arg1[1] = *(__getptd() + 0x98);
    *(__getptd() + 0x98) = arg1;
    return arg1;
}

int32_t __IsExceptionObjectToBeDestroyed(int32_t arg1)
{
    for (int32_t* i = *(__getptd() + 0x98); i != 0; i = i[1])
    {
        if (*i == arg1)
            return 0;
    }
    
    return 1;
}

void* __FindAndUnlinkFrame(void* arg1)
{
    if (arg1 == *(__getptd() + 0x98))
    {
        void* eax_1 = __getptd();
        *(eax_1 + 0x98) = *(arg1 + 4);
        return eax_1;
    }
    
    void* eax_3 = *(__getptd() + 0x98);
    
    while (*(eax_3 + 4) != 0)
    {
        void* ecx_2 = *(eax_3 + 4);
        
        if (arg1 == ecx_2)
        {
            *(eax_3 + 4) = *(arg1 + 4);
            return eax_3;
        }
        
        eax_3 = ecx_2;
    }
    
    /* tailcall */
    return sub_10016230();
}

int32_t sub_1002bcb0(void** arg1, uint32_t arg2, uint32_t arg3, char* arg4, PSTR arg5, int32_t arg6, uint32_t arg7, int32_t arg8, int32_t arg9)
{
    void var_14;
    _LocaleUpdate::_LocaleUpdate(&var_14, arg1);
    int32_t var_1c_1 = arg9;
    int32_t result = sub_1002bd10(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14), arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    _LocaleUpdate::~_LocaleUpdate(&var_14);
    return result;
}

int32_t sub_1002bd10(int32_t* arg1, uint32_t arg2, uint32_t arg3, char* arg4, PSTR arg5, int32_t arg6, uint32_t arg7, int32_t arg8)
{
    if (data_10046038 == 0)
    {
        if (LCMapStringW(0, 0x100, &data_1003e2d0, 1, nullptr, 0) == 0)
        {
            if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                data_10046038 = 2;
        }
        else
            data_10046038 = 1;
    }
    
    if (arg_14 > 0)
    {
        int32_t eax_4 = sub_1002c2b0(arg4, arg_14);
        
        if (eax_4 >= arg_14)
            arg_14 = eax_4;
        else
            arg_14 = (eax_4 + 1);
    }
    
    if ((data_10046038 == 2 || data_10046038 == 0))
    {
        char* lpSrcStr = nullptr;
        int32_t* lpDestStr = nullptr;
        int32_t var_20_1 = 0;
        
        if (arg2 == 0)
            arg2 = *(*arg1 + 0x14);
        
        if (arg7 == 0)
            arg7 = *(*arg1 + 4);
        
        uint32_t eax_9 = sub_10031a20(arg2);
        
        if (eax_9 != 0xffffffff)
        {
            int32_t cchDest_1;
            
            if (eax_9 == arg7)
                cchDest_1 = LCMapStringA(arg2, arg3, arg4, arg_14, arg5, arg6);
            else
            {
                lpSrcStr = sub_10031a80(arg7, eax_9, arg4, &arg_14, nullptr, 0);
                
                if (lpSrcStr == 0)
                    return 0;
                
                int32_t cchDest = LCMapStringA(arg2, arg3, lpSrcStr, arg_14, nullptr, 0);
                
                if (cchDest != 0)
                {
                    int32_t* lpDestStr_1;
                    
                    if ((cchDest <= 0 || cchDest > 0xffffffe0))
                        lpDestStr_1 = nullptr;
                    else
                        lpDestStr_1 = __MarkAllocaS(_malloc((cchDest + 8)), 0xdddd);
                    
                    lpDestStr = lpDestStr_1;
                    
                    if (lpDestStr != 0)
                    {
                        sub_1000fae0(lpDestStr, 0, cchDest);
                        cchDest = LCMapStringA(arg2, arg3, lpSrcStr, arg_14, lpDestStr, cchDest);
                        
                        if (cchDest != 0)
                        {
                            var_20_1 = sub_10031a80(eax_9, arg7, lpDestStr, &cchDest, arg5, arg6);
                            
                            if (var_20_1 != 0)
                                cchDest_1 = cchDest;
                            else
                                cchDest_1 = 0;
                        }
                        else
                            cchDest_1 = 0;
                    }
                    else
                        cchDest_1 = 0;
                }
                else
                    cchDest_1 = 0;
                
                if (lpDestStr != 0)
                    sub_1002c240(lpDestStr);
            }
            
            if (lpSrcStr != 0)
                sub_10011340(lpSrcStr, 2);
            
            if ((var_20_1 != 0 && arg5 != var_20_1))
                sub_10011340(var_20_1, 2);
            
            return cchDest_1;
        }
        
        return 0;
    }
    
    if (data_10046038 != 1)
        return 0;
    
    int32_t var_28_1 = 0;
    int32_t var_2c_1 = 0;
    wchar16* var_24_1 = nullptr;
    
    if (arg7 == 0)
        arg7 = *(*arg1 + 4);
    
    int32_t ecx_17;
    ecx_17 = arg8 != 0;
    int32_t eax_33 = MultiByteToWideChar(arg7, ((ecx_17 << 3) + 1), arg4, arg_14, nullptr, 0);
    
    if (eax_33 == 0)
        return 0;
    
    wchar16* var_3c_1;
    
    if ((eax_33 <= 0 || (COMBINE(0, 0xffffffe0) / eax_33) < 2))
        var_3c_1 = nullptr;
    else
        var_3c_1 = __MarkAllocaS(_malloc(((eax_33 * 2) + 8)), 0xdddd);
    
    if (var_3c_1 == 0)
        return 0;
    
    if (MultiByteToWideChar(arg7, MB_PRECOMPOSED, arg4, arg_14, var_3c_1, eax_33) != 0)
    {
        var_28_1 = LCMapStringW(arg2, arg3, var_3c_1, eax_33, nullptr, 0);
        
        if (var_28_1 != 0)
        {
            if ((arg3 & 0x400) == 0)
            {
                int32_t* var_40_1;
                
                if ((var_28_1 <= 0 || (COMBINE(0, 0xffffffe0) / var_28_1) < 2))
                    var_40_1 = nullptr;
                else
                    var_40_1 = __MarkAllocaS(_malloc(((var_28_1 * 2) + 8)), 0xdddd);
                
                var_24_1 = var_40_1;
                
                if ((var_24_1 != 0 && LCMapStringW(arg2, arg3, var_3c_1, eax_33, var_24_1, var_28_1) != 0))
                {
                    if (arg6 != 0)
                        var_28_1 = WideCharToMultiByte(arg7, 0, var_24_1, var_28_1, arg5, arg6, nullptr, nullptr);
                    else
                        var_28_1 = WideCharToMultiByte(arg7, 0, var_24_1, var_28_1, nullptr, 0, nullptr, nullptr);
                }
            }
            else
                LCMapStringW(arg2, arg3, var_3c_1, eax_33, arg5, arg6);
        }
    }
    
    if (var_24_1 != 0)
        sub_1002c240(var_24_1);
    
    sub_1002c240(var_3c_1);
    return var_28_1;
}

int32_t* __MarkAllocaS(int32_t* arg1, int32_t arg2)
{
    if (arg1 == 0)
        return arg1;
    
    *arg1 = arg2;
    return &arg1[2];
}

void sub_1002c240(int32_t* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if (arg1 != 0)
    {
        int32_t edx_1 = *(arg1 - 8);
        
        if (edx_1 == 0xdddd)
            __mktime32((arg1 - 8));
        else if ((edx_1 != 0xcccc && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x109, nullptr, u"("Corrupted pointer passed to _f…") == 1))
            breakpoint();
    }
}

int32_t sub_1002c2b0(char* arg1, int32_t arg2)
{
    int32_t var_c = arg2;
    char* var_8 = arg1;
    
    while (true)
    {
        int32_t edx_1 = var_c;
        var_c -= 1;
        
        if ((edx_1 == 0 || *var_8 == 0))
            return ((arg2 - var_c) - 1);
        
        var_8 = &var_8[1];
    }
}

BOOL sub_1002c300(void** arg1, uint32_t arg2, uint8_t* arg3, uint16_t* arg4, uint32_t arg5, uint32_t arg6, int32_t arg7, int32_t arg8)
{
    void var_14;
    _LocaleUpdate::_LocaleUpdate(&var_14, arg1);
    int32_t var_1c_1 = arg8;
    BOOL result = sub_1002c360(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14), arg2, arg3, arg4, arg5, arg6, arg7);
    _LocaleUpdate::~_LocaleUpdate(&var_14);
    return result;
}

BOOL sub_1002c360(int32_t* arg1, uint32_t arg2, uint8_t* arg3, uint16_t* arg4, uint32_t arg5, uint32_t arg6, int32_t arg7)
{
    void lpCharType;
    
    if (data_1004603c == 0)
    {
        if (GetStringTypeW(1, &data_1003e2d0, 1, &lpCharType) == 0)
        {
            if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                data_1004603c = 2;
        }
        else
            data_1004603c = 1;
    }
    
    if ((data_1004603c == 2 || data_1004603c == 0))
    {
        uint8_t* var_c_1 = nullptr;
        
        if (arg6 == 0)
            arg6 = *(*arg1 + 0x14);
        
        if (arg5 == 0)
            arg5 = *(*arg1 + 4);
        
        uint32_t eax_5 = sub_10031a20(arg6);
        
        if (eax_5 != 0xffffffff)
        {
            if (eax_5 != arg5)
            {
                var_c_1 = sub_10031a80(arg5, eax_5, arg3, &arg_10, nullptr, 0);
                
                if (var_c_1 == 0)
                    return 0;
                
                arg3 = var_c_1;
            }
            
            BOOL eax_11 = GetStringTypeA(arg6, arg2, arg3, arg_10, arg4);
            
            if (var_c_1 != 0)
                sub_10011340(var_c_1, 2);
            
            return eax_11;
        }
        
        return 0;
    }
    
    if (data_1004603c != 1)
        return 0;
    
    BOOL var_18_1 = 0;
    
    if (arg5 == 0)
        arg5 = *(*arg1 + 4);
    
    int32_t ecx_9;
    ecx_9 = arg7 != 0;
    int32_t cchWideChar = MultiByteToWideChar(arg5, ((ecx_9 << 3) + 1), arg3, arg_10, nullptr, 0);
    
    if (cchWideChar == 0)
        return 0;
    
    char* var_28_1;
    
    if ((cchWideChar <= 0 || cchWideChar > 0x7ffffff0))
        var_28_1 = nullptr;
    else
        var_28_1 = __MarkAllocaS(_malloc(((cchWideChar * 2) + 8)), 0xdddd);
    
    if (var_28_1 == 0)
        return 0;
    
    sub_1000fae0(var_28_1, 0, (cchWideChar << 1));
    int32_t cchSrc = MultiByteToWideChar(arg5, MB_PRECOMPOSED, arg3, arg_10, var_28_1, cchWideChar);
    
    if (cchSrc != 0)
        var_18_1 = GetStringTypeW(arg2, var_28_1, cchSrc, arg4);
    
    sub_1002c240(var_28_1);
    return var_18_1;
}

int32_t sub_1002c590()
{
    void* eax = __getptd();
    void* var_8 = *(eax + 0x6c);
    
    if ((var_8 != data_10044c18 && (*(eax + 0x70) & data_10044b34) == 0))
        var_8 = sub_10022be0();
    
    return *(var_8 + 0xc8);
}

int32_t sub_1002c5e0(void* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    void* var_8_1;
    
    if (*(arg1 + 0x20) == 0)
        var_8_1 = &data_10044e30;
    else
    {
        var_8_1 = sub_10010b10(1, 0xb8, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x40);
        
        if (var_8_1 == 0)
            return 1;
        
        if (sub_1002c6d0(var_8_1, arg1) != 0)
        {
            sub_1002cd00(var_8_1);
            sub_10011340(var_8_1, 2);
            return 1;
        }
        
        *(var_8_1 + 0xb4) = 1;
    }
    
    if (((*(arg1 + 0xd4) != 0x10044e30 && (InterlockedDecrement((*(arg1 + 0xd4) + 0xb4)) == 0 && *(*(arg1 + 0xd4) + 0xb4) <= 0)) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x50, nullptr, u"ploci->lc_time_curr->refcount > …") == 1))
        breakpoint();
    
    *(arg1 + 0xd4) = var_8_1;
    return 0;
}

int32_t sub_1002c6d0(char** arg1, void* arg2)
{
    uint32_t ecx = *(arg2 + 0x42);
    uint32_t eax_1 = *(arg2 + 0x44);
    
    if (arg1 == 0)
        return 0xffffffff;
    
    void* var_10 = arg2;
    int32_t var_c_1 = 0;
    int32_t eax_5 = (sub_10026ce0(&var_10, 1, ecx, 0x31, &arg1[1]) | 0);
    int32_t eax_8 = (sub_10026ce0(&var_10, 1, ecx, 0x32, &arg1[2]) | eax_5);
    int32_t eax_11 = (sub_10026ce0(&var_10, 1, ecx, 0x33, &arg1[3]) | eax_8);
    int32_t eax_14 = (sub_10026ce0(&var_10, 1, ecx, 0x34, &arg1[4]) | eax_11);
    int32_t eax_17 = (sub_10026ce0(&var_10, 1, ecx, 0x35, &arg1[5]) | eax_14);
    int32_t eax_20 = (sub_10026ce0(&var_10, 1, ecx, 0x36, &arg1[6]) | eax_17);
    int32_t eax_23 = (sub_10026ce0(&var_10, 1, ecx, 0x37, arg1) | eax_20);
    int32_t eax_26 = (sub_10026ce0(&var_10, 1, ecx, 0x2a, &arg1[8]) | eax_23);
    int32_t eax_29 = (sub_10026ce0(&var_10, 1, ecx, 0x2b, &arg1[9]) | eax_26);
    int32_t eax_32 = (sub_10026ce0(&var_10, 1, ecx, 0x2c, &arg1[0xa]) | eax_29);
    int32_t eax_35 = (sub_10026ce0(&var_10, 1, ecx, 0x2d, &arg1[0xb]) | eax_32);
    int32_t eax_38 = (sub_10026ce0(&var_10, 1, ecx, 0x2e, &arg1[0xc]) | eax_35);
    int32_t eax_41 = (sub_10026ce0(&var_10, 1, ecx, 0x2f, &arg1[0xd]) | eax_38);
    int32_t eax_44 = (sub_10026ce0(&var_10, 1, ecx, 0x30, &arg1[7]) | eax_41);
    int32_t eax_47 = (sub_10026ce0(&var_10, 1, ecx, 0x44, &arg1[0xe]) | eax_44);
    int32_t eax_50 = (sub_10026ce0(&var_10, 1, ecx, 0x45, &arg1[0xf]) | eax_47);
    int32_t eax_53 = (sub_10026ce0(&var_10, 1, ecx, 0x46, &arg1[0x10]) | eax_50);
    int32_t eax_56 = (sub_10026ce0(&var_10, 1, ecx, 0x47, &arg1[0x11]) | eax_53);
    int32_t eax_59 = (sub_10026ce0(&var_10, 1, ecx, 0x48, &arg1[0x12]) | eax_56);
    int32_t eax_62 = (sub_10026ce0(&var_10, 1, ecx, 0x49, &arg1[0x13]) | eax_59);
    int32_t eax_65 = (sub_10026ce0(&var_10, 1, ecx, 0x4a, &arg1[0x14]) | eax_62);
    int32_t eax_68 = (sub_10026ce0(&var_10, 1, ecx, 0x4b, &arg1[0x15]) | eax_65);
    int32_t eax_71 = (sub_10026ce0(&var_10, 1, ecx, 0x4c, &arg1[0x16]) | eax_68);
    int32_t eax_74 = (sub_10026ce0(&var_10, 1, ecx, 0x4d, &arg1[0x17]) | eax_71);
    int32_t eax_77 = (sub_10026ce0(&var_10, 1, ecx, 0x4e, &arg1[0x18]) | eax_74);
    int32_t eax_80 = (sub_10026ce0(&var_10, 1, ecx, 0x4f, &arg1[0x19]) | eax_77);
    int32_t eax_83 = (sub_10026ce0(&var_10, 1, ecx, 0x38, &arg1[0x1a]) | eax_80);
    int32_t eax_86 = (sub_10026ce0(&var_10, 1, ecx, 0x39, &arg1[0x1b]) | eax_83);
    int32_t eax_89 = (sub_10026ce0(&var_10, 1, ecx, 0x3a, &arg1[0x1c]) | eax_86);
    int32_t eax_92 = (sub_10026ce0(&var_10, 1, ecx, 0x3b, &arg1[0x1d]) | eax_89);
    int32_t eax_95 = (sub_10026ce0(&var_10, 1, ecx, 0x3c, &arg1[0x1e]) | eax_92);
    int32_t eax_98 = (sub_10026ce0(&var_10, 1, ecx, 0x3d, &arg1[0x1f]) | eax_95);
    int32_t eax_101 = (sub_10026ce0(&var_10, 1, ecx, 0x3e, &arg1[0x20]) | eax_98);
    int32_t eax_104 = (sub_10026ce0(&var_10, 1, ecx, 0x3f, &arg1[0x21]) | eax_101);
    int32_t eax_107 = (sub_10026ce0(&var_10, 1, ecx, 0x40, &arg1[0x22]) | eax_104);
    int32_t eax_110 = (sub_10026ce0(&var_10, 1, ecx, 0x41, &arg1[0x23]) | eax_107);
    int32_t eax_113 = (sub_10026ce0(&var_10, 1, ecx, 0x42, &arg1[0x24]) | eax_110);
    int32_t eax_116 = (sub_10026ce0(&var_10, 1, ecx, 0x43, &arg1[0x25]) | eax_113);
    int32_t eax_119 = (sub_10026ce0(&var_10, 1, ecx, 0x28, &arg1[0x26]) | eax_116);
    int32_t eax_122 = (sub_10026ce0(&var_10, 1, ecx, 0x29, &arg1[0x27]) | eax_119);
    int32_t eax_125 = (sub_10026ce0(&var_10, 1, eax_1, 0x1f, &arg1[0x28]) | eax_122);
    int32_t eax_128 = (sub_10026ce0(&var_10, 1, eax_1, 0x20, &arg1[0x29]) | eax_125);
    int32_t eax_131 = (sub_10026ce0(&var_10, 1, eax_1, 0x1003, &arg1[0x2a]) | eax_128);
    int32_t result = (sub_10026ce0(&var_10, 0, eax_1, 0x1009, &arg1[0x2c]) | eax_131);
    arg1[0x2b] = eax_1;
    return result;
}

void sub_1002cd00(int32_t* arg1)
{
    if (arg1 != 0)
    {
        sub_10011340(arg1[1], 2);
        sub_10011340(arg1[2], 2);
        sub_10011340(arg1[3], 2);
        sub_10011340(arg1[4], 2);
        sub_10011340(arg1[5], 2);
        sub_10011340(arg1[6], 2);
        sub_10011340(*arg1, 2);
        sub_10011340(arg1[8], 2);
        sub_10011340(arg1[9], 2);
        sub_10011340(arg1[0xa], 2);
        sub_10011340(arg1[0xb], 2);
        sub_10011340(arg1[0xc], 2);
        sub_10011340(arg1[0xd], 2);
        sub_10011340(arg1[7], 2);
        sub_10011340(arg1[0xe], 2);
        sub_10011340(arg1[0xf], 2);
        sub_10011340(arg1[0x10], 2);
        sub_10011340(arg1[0x11], 2);
        sub_10011340(arg1[0x12], 2);
        sub_10011340(arg1[0x13], 2);
        sub_10011340(arg1[0x14], 2);
        sub_10011340(arg1[0x15], 2);
        sub_10011340(arg1[0x16], 2);
        sub_10011340(arg1[0x17], 2);
        sub_10011340(arg1[0x18], 2);
        sub_10011340(arg1[0x19], 2);
        sub_10011340(arg1[0x1a], 2);
        sub_10011340(arg1[0x1b], 2);
        sub_10011340(arg1[0x1c], 2);
        sub_10011340(arg1[0x1d], 2);
        sub_10011340(arg1[0x1e], 2);
        sub_10011340(arg1[0x1f], 2);
        sub_10011340(arg1[0x20], 2);
        sub_10011340(arg1[0x21], 2);
        sub_10011340(arg1[0x22], 2);
        sub_10011340(arg1[0x23], 2);
        sub_10011340(arg1[0x24], 2);
        sub_10011340(arg1[0x25], 2);
        sub_10011340(arg1[0x26], 2);
        sub_10011340(arg1[0x27], 2);
        sub_10011340(arg1[0x28], 2);
        sub_10011340(arg1[0x29], 2);
        sub_10011340(arg1[0x2a], 2);
    }
}

int32_t sub_1002d010(void* arg1)
{
    int32_t edi;
    int32_t var_28 = edi;
    int32_t var_c = 0;
    void* var_14 = arg1;
    int32_t var_10 = 0;
    void* var_20;
    void* var_18_1;
    void* var_c_1;
    
    if ((*(arg1 + 0x1c) != 0 || *(arg1 + 0x18) != 0))
    {
        var_20 = sub_10010b10(1, 0x30, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x65);
        
        if (var_20 == 0)
            return 1;
        
        __builtin_memcpy(var_20, *(arg1 + 0xbc), 0xc);
        var_18_1 = __malloc_dbg(4, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x71);
        
        if (var_18_1 == 0)
        {
            sub_10011340(var_20, 2);
            return 1;
        }
        
        *var_18_1 = 0;
        
        if (*(arg1 + 0x1c) == 0)
        {
            var_c_1 = nullptr;
            *var_20 = data_10044ef0;
            *(var_20 + 4) = data_10044ef4;
            *(var_20 + 8) = data_10044ef8;
        }
        else
        {
            var_c_1 = __malloc_dbg(4, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x7d);
            
            if (var_c_1 == 0)
            {
                sub_10011340(var_20, 2);
                sub_10011340(var_18_1, 2);
                return 1;
            }
            
            *var_c_1 = 0;
            uint32_t edx_4 = *(arg1 + 0x3e);
            int32_t eax_10 = (sub_10026ce0(&var_14, 1, edx_4, 0xe, var_20) | 0);
            int32_t eax_14 = (sub_10026ce0(&var_14, 1, edx_4, 0xf, (var_20 + 4)) | eax_10);
            int32_t eax_18 = (sub_10026ce0(&var_14, 1, edx_4, 0x10, (var_20 + 8)) | eax_14);
            int32_t var_1c_3 = eax_18;
            
            if (eax_18 != 0)
            {
                sub_1002d370(var_20);
                sub_10011340(var_20, 2);
                sub_10011340(var_18_1, 2);
                return 0xffffffff;
            }
            
            _fix_grouping(*(var_20 + 8));
        }
        
        *var_18_1 = 1;
        
        if (var_c_1 != 0)
            *var_c_1 = 1;
    }
    else
    {
        var_c_1 = nullptr;
        var_18_1 = nullptr;
        var_20 = &data_10044ef0;
    }
    
    if (((*(arg1 + 0xb4) != 0 && (InterlockedDecrement(*(arg1 + 0xb4)) == 0 && *(arg1 + 0xb4) <= 0)) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xbc, nullptr, u"ploci->lconv_num_refcount > 0") == 1))
        breakpoint();
    
    if ((*(arg1 + 0xb0) != 0 && InterlockedDecrement(*(arg1 + 0xb0)) == 0))
    {
        sub_10011340(*(arg1 + 0xb0), 2);
        sub_10011340(*(arg1 + 0xbc), 2);
    }
    
    *(arg1 + 0xb4) = var_c_1;
    *(arg1 + 0xb0) = var_18_1;
    *(arg1 + 0xbc) = var_20;
    return 0;
}

char* _fix_grouping(char* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    while (*arg1 != 0)
    {
        if ((*arg1 >= 0x30 && *arg1 <= 0x39))
        {
            *arg1 -= 0x30;
            arg1 = &arg1[1];
            continue;
        }
        
        if (*arg1 != 0x3b)
            arg1 = &arg1[1];
        else
        {
            char* var_8_1 = arg1;
            
            do
            {
                char* eax_6;
                eax_6 = var_8_1[1];
                *var_8_1 = eax_6;
                var_8_1 = &var_8_1[1];
            } while (*var_8_1 != 0);
        }
    }
    
    return arg1;
}

void sub_1002d370(int32_t* arg1)
{
    if (arg1 != 0)
    {
        if (*arg1 != data_10044ef0)
            sub_10011340(*arg1, 2);
        
        if (arg1[1] != data_10044ef4)
            sub_10011340(arg1[1], 2);
        
        if (arg1[2] != data_10044ef8)
            sub_10011340(arg1[2], 2);
    }
}

int32_t sub_1002d3e0(void* arg1)
{
    int32_t edi;
    int32_t var_28 = edi;
    void* var_20 = nullptr;
    void* var_10 = arg1;
    int32_t var_c = 0;
    void* var_1c;
    void* var_14_1;
    
    if ((*(arg1 + 0x18) != 0 || *(arg1 + 0x1c) != 0))
    {
        var_1c = sub_10010b10(1, 0x30, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x53);
        
        if (var_1c == 0)
            return 1;
        
        var_14_1 = __malloc_dbg(4, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x59);
        
        if (var_14_1 == 0)
        {
            sub_10011340(var_1c, 2);
            return 1;
        }
        
        *var_14_1 = 0;
        
        if (*(arg1 + 0x18) == 0)
            __builtin_memcpy(var_1c, 0x10044ef0, 0xc);
        else
        {
            var_20 = __malloc_dbg(4, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x65);
            
            if (var_20 == 0)
            {
                sub_10011340(var_1c, 2);
                sub_10011340(var_14_1, 2);
                return 1;
            }
            
            *var_20 = 0;
            uint32_t ecx_3 = *(arg1 + 0x38);
            int32_t eax_10 = (sub_10026ce0(&var_10, 1, ecx_3, 0x15, (var_1c + 0xc)) | 0);
            int32_t eax_13 = (sub_10026ce0(&var_10, 1, ecx_3, 0x14, (var_1c + 0x10)) | eax_10);
            int32_t eax_16 = (sub_10026ce0(&var_10, 1, ecx_3, 0x16, (var_1c + 0x14)) | eax_13);
            int32_t eax_19 = (sub_10026ce0(&var_10, 1, ecx_3, 0x17, (var_1c + 0x18)) | eax_16);
            int32_t eax_22 = (sub_10026ce0(&var_10, 1, ecx_3, 0x18, (var_1c + 0x1c)) | eax_19);
            int32_t eax_25 = (sub_10026ce0(&var_10, 1, ecx_3, 0x50, (var_1c + 0x20)) | eax_22);
            int32_t eax_28 = (sub_10026ce0(&var_10, 1, ecx_3, 0x51, (var_1c + 0x24)) | eax_25);
            int32_t eax_31 = (sub_10026ce0(&var_10, 0, ecx_3, 0x1a, (var_1c + 0x28)) | eax_28);
            int32_t eax_34 = (sub_10026ce0(&var_10, 0, ecx_3, 0x19, (var_1c + 0x29)) | eax_31);
            int32_t eax_37 = (sub_10026ce0(&var_10, 0, ecx_3, 0x54, (var_1c + 0x2a)) | eax_34);
            int32_t eax_40 = (sub_10026ce0(&var_10, 0, ecx_3, 0x55, (var_1c + 0x2b)) | eax_37);
            int32_t eax_43 = (sub_10026ce0(&var_10, 0, ecx_3, 0x56, (var_1c + 0x2c)) | eax_40);
            int32_t eax_46 = (sub_10026ce0(&var_10, 0, ecx_3, 0x57, (var_1c + 0x2d)) | eax_43);
            int32_t eax_49 = (sub_10026ce0(&var_10, 0, ecx_3, 0x52, (var_1c + 0x2e)) | eax_46);
            int32_t eax_52 = (sub_10026ce0(&var_10, 0, ecx_3, 0x53, (var_1c + 0x2f)) | eax_49);
            int32_t var_18_15 = eax_52;
            
            if (eax_52 != 0)
            {
                sub_1002d860(var_1c);
                sub_10011340(var_1c, 2);
                sub_10011340(var_14_1, 2);
                sub_10011340(var_20, 2);
                return 1;
            }
            
            _fix_grouping(*(var_1c + 0x1c));
        }
        
        *var_1c = **(arg1 + 0xbc);
        *(var_1c + 4) = *(*(arg1 + 0xbc) + 4);
        *(var_1c + 8) = *(*(arg1 + 0xbc) + 8);
        *var_14_1 = 1;
        
        if (var_20 != 0)
            *var_20 = 1;
    }
    else
    {
        var_20 = nullptr;
        var_14_1 = nullptr;
        var_1c = &data_10044ef0;
    }
    
    if (((*(arg1 + 0xb8) != 0 && (InterlockedDecrement(*(arg1 + 0xb8)) == 0 && *(arg1 + 0xb8) <= 0)) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xc4, nullptr, u"ploci->lconv_mon_refcount > 0") == 1))
        breakpoint();
    
    if ((*(arg1 + 0xb0) != 0 && InterlockedDecrement(*(arg1 + 0xb0)) == 0))
    {
        sub_10011340(*(arg1 + 0xbc), 2);
        sub_10011340(*(arg1 + 0xb0), 2);
    }
    
    *(arg1 + 0xb8) = var_20;
    *(arg1 + 0xb0) = var_14_1;
    *(arg1 + 0xbc) = var_1c;
    return 0;
}

void sub_1002d860(void* arg1)
{
    if (arg1 != 0)
    {
        if (*(arg1 + 0xc) != data_10044efc)
            sub_10011340(*(arg1 + 0xc), 2);
        
        if (*(arg1 + 0x10) != data_10044f00)
            sub_10011340(*(arg1 + 0x10), 2);
        
        if (*(arg1 + 0x14) != data_10044f04)
            sub_10011340(*(arg1 + 0x14), 2);
        
        if (*(arg1 + 0x18) != data_10044f08)
            sub_10011340(*(arg1 + 0x18), 2);
        
        if (*(arg1 + 0x1c) != data_10044f0c)
            sub_10011340(*(arg1 + 0x1c), 2);
        
        if (*(arg1 + 0x20) != data_10044f10)
            sub_10011340(*(arg1 + 0x20), 2);
        
        if (*(arg1 + 0x24) != data_10044f14)
            sub_10011340(*(arg1 + 0x24), 2);
    }
}

int32_t sub_1002d950(void* arg1)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    void* var_34 = nullptr;
    void* var_38 = nullptr;
    void* var_3c = nullptr;
    void* var_44 = nullptr;
    void* var_10 = nullptr;
    void* var_30 = arg1;
    int32_t var_2c = 0;
    
    if (*(arg1 + 0x14) == 0)
    {
        if (((*(arg1 + 0xc0) != 0 && (InterlockedDecrement(*(arg1 + 0xc0)) == 0 && *(arg1 + 0xc0) <= 0)) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xe5, nullptr, u"ploci->ctype1_refcount > 0") == 1))
            breakpoint();
        
        *(arg1 + 0xc0) = 0;
        *(arg1 + 0xc4) = 0;
        *(arg1 + 0xc8) = u"         (((((                  …";
        *(arg1 + 0xcc) = 0x1003e918;
        *(arg1 + 0xd0) = 0x1003ea98;
        *(arg1 + 0xac) = 1;
    }
    else if (*(arg1 + 4) != 0)
    {
    label_1002d9e6:
        var_34 = __malloc_dbg(4, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x5e);
        var_38 = sub_10010b10(0x180, 2, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x62);
        var_3c = sub_10010b10(0x180, 1, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x64);
        var_44 = sub_10010b10(0x180, 1, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x66);
        var_10 = sub_10010b10(0x101, 1, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x68);
        
        if (((((var_34 == 0 || var_38 == 0) || var_10 == 0) || var_3c == 0) || var_44 == 0))
            goto label_1002ddfb;
        
        *var_34 = 0;
        void* var_8_1 = var_10;
        
        for (int32_t i = 0; i < 0x100; i += 1)
        {
            void* edx_3;
            edx_3 = i;
            *var_8_1 = edx_3;
            var_8_1 += 1;
        }
        
        int32_t lpCPInfo;
        
        if ((GetCPInfo(*(arg1 + 4), &lpCPInfo) == 0 || lpCPInfo > 5))
            goto label_1002ddfb;
        
        uint32_t ecx_4 = lpCPInfo;
        void var_22;
        
        if (ecx_4 > 1)
        {
            void* var_8_2 = &var_22;
            
            while (*var_8_2 != 0)
            {
                if (*(var_8_2 + 1) == 0)
                    break;
                
                for (uint32_t i_1 = *var_8_2; i_1 <= *(var_8_2 + 1); i_1 += 1)
                    *(var_10 + i_1) = 0x20;
                
                var_8_2 += 2;
            }
        }
        
        if (sub_1002c300(nullptr, 1, var_10, 0x100, (var_38 + 0x100), *(arg1 + 4), 0, 0) == 0)
            goto label_1002ddfb;
        
        if (sub_1002bcb0(nullptr, *(arg1 + 0x14), 0x100, (var_10 + 1), 0xff, (var_3c + 0x81), 0xff, *(arg1 + 4), 0) == 0)
            goto label_1002ddfb;
        
        if (sub_1002bcb0(nullptr, *(arg1 + 0x14), 0x200, (var_10 + 1), 0xff, (var_44 + 0x81), 0xff, *(arg1 + 4), 0) == 0)
            goto label_1002ddfb;
        
        *(var_38 + 0xfe) = 0;
        *(var_3c + 0x7f) = 0;
        *(var_44 + 0x7f) = 0;
        *(var_3c + 0x80) = 0;
        *(var_44 + 0x80) = 0;
        
        if (ecx_4 > 1)
        {
            void* var_8_3 = &var_22;
            
            while (*var_8_3 != 0)
            {
                if (*(var_8_3 + 1) == 0)
                    break;
                
                for (uint32_t i_2 = *var_8_3; i_2 <= *(var_8_3 + 1); i_2 += 1)
                    *((var_38 + (i_2 << 1)) + 0x100) = 0x8000;
                
                var_8_3 += 2;
            }
        }
        
        sub_10013c90(var_38, (var_38 + 0x200), 0xfe, var_44, ecx_4, var_3c, var_38, var_34);
        sub_10013c90(var_3c, (var_3c + 0x100), 0x7f);
        sub_10013c90(var_44, (var_44 + 0x100), 0x7f);
        
        if ((*(arg1 + 0xc0) != 0 && InterlockedDecrement(*(arg1 + 0xc0)) == 0))
        {
            if (sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xc5, nullptr, 0) == 1)
                breakpoint();
            
            sub_10011340((*(arg1 + 0xc4) - 0xfe), 2);
            sub_10011340((*(arg1 + 0xcc) - 0x80), 2);
            sub_10011340((*(arg1 + 0xd0) - 0x80), 2);
            sub_10011340(*(arg1 + 0xc0), 2);
        }
        
        *var_34 = 1;
        *(arg1 + 0xc0) = var_34;
        *(arg1 + 0xc8) = (var_38 + 0x100);
        *(arg1 + 0xc4) = (var_38 + 0xfe);
        *(arg1 + 0xcc) = (var_3c + 0x80);
        *(arg1 + 0xd0) = (var_44 + 0x80);
        *(arg1 + 0xac) = ecx_4;
        sub_10011340(var_10, 2);
    }
    else
    {
        if (sub_10026ce0(&var_30, 0, *(arg1 + 0x30), 0x1004, (arg1 + 4)) == 0)
            goto label_1002d9e6;
        
    label_1002ddfb:
        sub_10011340(var_34, 2);
        sub_10011340(var_38, 2);
        sub_10011340(var_3c, 2);
        sub_10011340(var_44, 2);
        sub_10011340(var_10, 2);
    }
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t sub_1002df00()
{
    void* eax = __getptd();
    void* var_8 = *(eax + 0x6c);
    
    if ((var_8 != data_10044c18 && (*(eax + 0x70) & data_10044b34) == 0))
        var_8 = sub_10022be0();
    
    return *(var_8 + 4);
}

void* sub_1002df50()
{
    void* eax = __getptd();
    void* var_8 = *(eax + 0x6c);
    
    if ((var_8 != data_10044c18 && (*(eax + 0x70) & data_10044b34) == 0))
        var_8 = sub_10022be0();
    
    return (var_8 + 0xc);
}

int32_t _reg() __pure
{
    return 0;
}

int32_t sub_1002dfb0(char* arg1, void* arg2, char* arg3, int32_t arg4)
{
    if ((arg4 == 0 && (arg1 == 0 && arg2 == 0)))
        return 0;
    
    int32_t var_1c_1;
    
    if ((arg1 == 0 || arg2 <= 0))
        var_1c_1 = 0;
    else
        var_1c_1 = 1;
    
    if ((var_1c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x18, nullptr, u"((_Dst)) != NULL && ((_SizeInByt…") == 1))
        breakpoint();
    
    if (var_1c_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"((_Dst)) != NULL && ((_SizeInByt…", u"strncpy_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x18, 0);
        return 0x16;
    }
    
    if (arg4 == 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            void* var_20_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_20_1 = (arg2 - 1);
            else
                var_20_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, var_20_1);
        }
        
        return 0;
    }
    
    if (arg3 == 0)
    {
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            void* var_24_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_24_1 = (arg2 - 1);
            else
                var_24_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, var_24_1);
        }
        
        int32_t edx_7;
        edx_7 = arg3 != 0;
        
        if ((edx_7 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x1f, nullptr, u"(((_Src))) != NULL") == 1))
            breakpoint();
        
        if (edx_7 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"(((_Src))) != NULL", u"strncpy_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x1f, 0);
            return 0x16;
        }
    }
    
    char* var_8_1 = arg1;
    void* var_c_1 = arg2;
    
    if (arg4 != 0xffffffff)
    {
        if (((__CrtGetReportHook() != 0 && arg4 >= arg2) && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x2b, nullptr, u"Buffer is too small") == 1))
            breakpoint();
        
        bool cond:2_1;
        
        do
        {
            int32_t eax_16;
            eax_16 = *arg3;
            *var_8_1 = eax_16;
            int32_t edx_12 = *var_8_1;
            var_8_1 = &var_8_1[1];
            arg3 = &arg3[1];
            
            if (edx_12 == 0)
                break;
            
            bool cond:1_1 = var_c_1 == 1;
            var_c_1 -= 1;
            
            if (cond:1_1)
                break;
            
            cond:2_1 = arg4 == 1;
            arg4 -= 1;
        } while (!(cond:2_1));
        
        if (arg4 == 0)
            *var_8_1 = 0;
    }
    else
    {
        bool cond:0_1;
        
        do
        {
            void* edx_8;
            edx_8 = *arg3;
            *var_8_1 = edx_8;
            int32_t ecx_9 = *var_8_1;
            var_8_1 = &var_8_1[1];
            arg3 = &arg3[1];
            
            if (ecx_9 == 0)
                break;
            
            cond:0_1 = var_c_1 == 1;
            var_c_1 -= 1;
        } while (!(cond:0_1));
    }
    
    if (var_c_1 == 0)
    {
        if (arg4 == 0xffffffff)
        {
            *((arg1 + arg2) - 1) = 0;
            return 0x50;
        }
        
        *arg1 = 0;
        
        if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && arg2 > 1)))
        {
            void* var_28_1;
            
            if (data_100441c4 >= (arg2 - 1))
                var_28_1 = (arg2 - 1);
            else
                var_28_1 = data_100441c4;
            
            sub_1000fae0(&arg1[1], 0xfe, var_28_1);
        }
        
        int32_t var_2c_1 = 0;
        
        if ((var_2c_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3e, nullptr, u"(L"Buffer is too small" && 0)") == 1))
            breakpoint();
        
        if (var_2c_1 == 0)
        {
            *sub_1000eca0() = 0x22;
            sub_1000c310(u"(L"Buffer is too small" && 0)", u"strncpy_s", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3e, 0);
            return 0x22;
        }
    }
    
    if ((arg2 != 0xffffffff && (arg2 != 0x7fffffff && ((arg2 - var_c_1) + 1) < arg2)))
    {
        void* var_30_1;
        
        if (data_100441c4 >= (arg2 - ((arg2 - var_c_1) + 1)))
            var_30_1 = (arg2 - ((arg2 - var_c_1) + 1));
        else
            var_30_1 = data_100441c4;
        
        sub_1000fae0(((arg1 + (arg2 - var_c_1)) + 1), 0xfe, var_30_1);
    }
    
    return 0;
}

int32_t sub_1002e3a0(char* arg1, char* arg2)
{
    int32_t s;
    __builtin_memset(&s, 0, 0x20);
    char* edx = arg2;
    int32_t eax;
    
    while (true)
    {
        eax = *edx;
        eax = eax;
        
        if (eax == 0)
            break;
        
        edx = &edx[1];
        s |= (1 << (eax % 0x20));
    }
    
    char* esi = arg1;
    int32_t result = 0xffffffff;
    
    do
    {
        result += 1;
        eax = *esi;
        eax = eax;
        
        if (eax == 0)
            break;
        
        esi = &esi[1];
    } while (!((TEST_BITD(s, eax))));
    
    return result;
}

uint32_t sub_1002e3f0(void* arg1, char* arg2, int32_t arg3)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t i = 0;
    
    if (arg3 == 0)
        return 0;
    
    if (arg3 >= 4)
    {
        for (; i < (arg3 - 4); i += 4)
        {
            arg1 += 4;
            arg2 = &arg2[4];
            
            if ((*(arg1 - 4) == 0 || *(arg1 - 4) != arg2[0xfffffffc]))
                return (*(arg1 - 4) - arg2[0xfffffffc]);
            
            if ((*(arg1 - 3) == 0 || *(arg1 - 3) != arg2[0xfffffffd]))
                return (*(arg1 - 3) - arg2[0xfffffffd]);
            
            if ((*(arg1 - 2) == 0 || *(arg1 - 2) != arg2[0xfffffffe]))
                return (*(arg1 - 2) - arg2[0xfffffffe]);
            
            if ((*(arg1 - 1) == 0 || *(arg1 - 1) != arg2[0xffffffff]))
                return (*(arg1 - 1) - arg2[0xffffffff]);
        }
    }
    
    for (; i < arg3; i += 1)
    {
        if ((*arg1 == 0 || *arg1 != *arg2))
            return (*arg1 - *arg2);
        
        arg1 += 1;
        arg2 = &arg2[1];
    }
    
    return 0;
}

void* sub_1002e570(char* arg1, char* arg2)
{
    int32_t s;
    __builtin_memset(&s, 0, 0x20);
    char* edx = arg2;
    void* result;
    
    while (true)
    {
        result = *edx;
        result = result;
        
        if (result == 0)
            break;
        
        edx = &edx[1];
        s |= (1 << (result % 0x20));
    }
    
    char* esi = arg1;
    
    do
    {
        result = *esi;
        result = result;
        
        if (result == 0)
            return result;
        
        esi = &esi[1];
    } while (!((TEST_BITD(s, result))));
    
    return &esi[0xffffffff];
}

int32_t sub_1002e5b0(void* arg1, int16_t* arg2, char* arg3)
{
    void* eax_1 = (__getptd() + 0x9c);
    
    if (arg1 != 0)
    {
        *eax_1 = arg1;
        *(eax_1 + 4) = (arg1 + 0x40);
        
        if ((*(eax_1 + 4) != 0 && **(eax_1 + 4) != 0))
            sub_1002e860(0x1003f748, 0x16, (eax_1 + 4));
        
        *(eax_1 + 8) = 0;
        
        if ((*eax_1 != 0 && **eax_1 != 0))
        {
            if ((*(eax_1 + 4) == 0 || **(eax_1 + 4) == 0))
                sub_1002edf0(eax_1);
            else
                sub_1002e8f0(eax_1);
            
            if ((*(eax_1 + 8) == 0 && sub_1002e860(0x1003f540, 0x40, eax_1) != 0))
            {
                if ((*(eax_1 + 4) == 0 || **(eax_1 + 4) == 0))
                    sub_1002edf0(eax_1);
                else
                    sub_1002e8f0(eax_1);
            }
        }
        else if ((*(eax_1 + 4) == 0 || **(eax_1 + 4) == 0))
            sub_1002f160(eax_1);
        else
            sub_1002f010(eax_1);
    }
    else
        sub_1002f160(eax_1);
    
    if (*(eax_1 + 8) == 0)
        return 0;
    
    int32_t* var_10_1;
    
    if (arg1 == 0)
        var_10_1 = nullptr;
    else
        var_10_1 = (arg1 + 0x80);
    
    int32_t eax_20 = sub_1002f1a0(var_10_1, eax_1);
    
    if (((eax_20 != 0 && (eax_20 != 0xfde8 && eax_20 != 0xfde9)) && IsValidCodePage(eax_20) != 0))
    {
        if (IsValidLocale(*(eax_1 + 0x18), LCID_INSTALLED) == 0)
            return 0;
        
        if (arg2 != 0)
        {
            *arg2 = *(eax_1 + 0x18);
            arg2[1] = *(eax_1 + 0x1c);
            void* ecx_16;
            ecx_16 = eax_20;
            arg2[2] = ecx_16;
        }
        
        if (arg3 != 0)
        {
            if (*arg2 != 0x814)
            {
                if (GetLocaleInfoA(*(eax_1 + 0x18), 0x1001, arg3, 0x40) == 0)
                    return 0;
            }
            else
                sub_1000b4b0(sub_10010280(arg3, 0x40, "Norwegian-Nynorsk"), u"strcpy_s(lpOutStr->szLanguage, (…", u"__get_qualified_locale", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x131, 0);
            
            if (GetLocaleInfoA(*(eax_1 + 0x1c), 0x1002, &arg3[0x40], 0x40) == 0)
                return 0;
            
            sub_10025890(eax_20, &arg3[0x80], 0x10, 0xa);
        }
        
        return 1;
    }
    
    return 0;
}

int32_t sub_1002e860(int32_t arg1, int32_t arg2, int32_t* arg3)
{
    uint32_t var_10 = 1;
    int32_t var_c = 0;
    
    while (var_c <= arg2)
    {
        if (var_10 == 0)
            break;
        
        int32_t eax_4;
        int32_t edx_1;
        edx_1 = HIGHD((var_c + arg2));
        eax_4 = LOWD((var_c + arg2));
        int32_t eax_6 = ((eax_4 - edx_1) >> 1);
        var_10 = sub_10031f00(*arg3, *(arg1 + (eax_6 << 3)));
        
        if (var_10 == 0)
            *arg3 = ((arg1 + (eax_6 << 3)) + 4);
        else if (var_10 >= 0)
            var_c = (eax_6 + 1);
        else
            arg2 = (eax_6 - 1);
    }
    
    int32_t result;
    result = var_10 == 0;
    return result;
}

int32_t* sub_1002e8f0(int32_t* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t edx;
    edx = _strlen(*arg1) == 3;
    arg1[4] = edx;
    int32_t ecx_3;
    ecx_3 = _strlen(arg1[1]) == 3;
    arg1[5] = ecx_3;
    arg1[6] = 0;
    int32_t var_8_1;
    
    if (arg1[4] == 0)
        var_8_1 = sub_1002f3e0(*arg1);
    else
        var_8_1 = 2;
    
    arg1[3] = var_8_1;
    EnumSystemLocalesA(sub_1002e9b0, 1);
    int32_t* result;
    
    if ((arg1[2] & 0x100) != 0)
        result = (arg1[2] & 0x200);
    
    if ((((arg1[2] & 0x100) == 0 || result == 0) || (arg1[2] & 7) == 0))
    {
        result = arg1;
        result[2] = 0;
    }
    
    return result;
}

int32_t __stdcall sub_1002e9b0(char* arg1)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    void* eax_3 = (__getptd() + 0x9c);
    uint32_t Locale = sub_1002f360(arg1);
    int32_t eax_5 = *(eax_3 + 0x14);
    int32_t eax_6 = -(eax_5);
    void lpLCData;
    
    if (GetLocaleInfoA(Locale, (((eax_6 - eax_6) & 0xfffff005) + 0x1002), &lpLCData, 0x78) != 0)
    {
        if (sub_10031f00(*(eax_3 + 4), &lpLCData) != 0)
        {
        label_1002ebcc:
            
            if ((*(eax_3 + 8) & 0x300) == 0x300)
                *(eax_3 + 8);
            else
            {
                int32_t ecx_19 = *(eax_3 + 0x10);
                int32_t ecx_20 = -(ecx_19);
                
                if (GetLocaleInfoA(Locale, (((ecx_20 - ecx_20) & 0xfffff002) + 0x1001), &lpLCData, 0x78) != 0)
                {
                    if (sub_10031f00(*eax_3, &lpLCData) == 0)
                    {
                        *(eax_3 + 8) |= 0x200;
                        
                        if (*(eax_3 + 0x10) == 0)
                        {
                            void* eax_45;
                            
                            if (*(eax_3 + 0xc) != 0)
                                eax_45 = _strlen(*eax_3);
                            
                            if ((*(eax_3 + 0xc) == 0 || eax_45 != *(eax_3 + 0xc)))
                            {
                                *(eax_3 + 8) |= 0x100;
                                
                                if (*(eax_3 + 0x18) == 0)
                                    *(eax_3 + 0x18) = Locale;
                            }
                            else if (sub_1002f2c0(Locale, 1, eax_3) != 0)
                            {
                                *(eax_3 + 8) |= 0x100;
                                
                                if (*(eax_3 + 0x18) == 0)
                                    *(eax_3 + 0x18) = Locale;
                            }
                        }
                        else
                        {
                            *(eax_3 + 8) |= 0x100;
                            
                            if (*(eax_3 + 0x18) == 0)
                                *(eax_3 + 0x18) = Locale;
                        }
                    }
                    else if ((((*(eax_3 + 0x10) == 0 && *(eax_3 + 0xc) != 0) && sub_10031f00(*eax_3, &lpLCData) == 0) && sub_1002f2c0(Locale, 0, eax_3) != 0))
                    {
                        *(eax_3 + 8) |= 0x100;
                        
                        if (*(eax_3 + 0x18) == 0)
                            *(eax_3 + 0x18) = Locale;
                    }
                    
                    *(eax_3 + 8);
                }
                else
                    *(eax_3 + 8) = 0;
            }
        }
        else
        {
            int32_t edx_3 = *(eax_3 + 0x10);
            int32_t edx_4 = -(edx_3);
            
            if (GetLocaleInfoA(Locale, (((edx_4 - edx_4) & 0xfffff002) + 0x1001), &lpLCData, 0x78) != 0)
            {
                if (sub_10031f00(*eax_3, &lpLCData) == 0)
                {
                    *(eax_3 + 8) |= 0x304;
                    *(eax_3 + 0x1c) = Locale;
                    *(eax_3 + 0x18) = Locale;
                }
                else if ((*(eax_3 + 8) & 2) == 0)
                {
                    uint32_t eax_24;
                    
                    if (*(eax_3 + 0xc) != 0)
                        eax_24 = sub_10032250(*eax_3, &lpLCData, *(eax_3 + 0xc));
                    
                    if ((*(eax_3 + 0xc) != 0 && eax_24 == 0))
                    {
                        *(eax_3 + 8) |= 2;
                        *(eax_3 + 0x1c) = Locale;
                        
                        if (_strlen(*eax_3) == *(eax_3 + 0xc))
                            *(eax_3 + 0x18) = Locale;
                    }
                    else if (((*(eax_3 + 8) & 1) == 0 && sub_1002f270(Locale) != 0))
                    {
                        *(eax_3 + 8) |= 1;
                        *(eax_3 + 0x1c) = Locale;
                    }
                }
                
                goto label_1002ebcc;
            }
            
            *(eax_3 + 8) = 0;
        }
    }
    else
        *(eax_3 + 8) = 0;
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t* sub_1002edf0(int32_t* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t edx;
    edx = _strlen(*arg1) == 3;
    arg1[4] = edx;
    int32_t var_8_1;
    
    if (arg1[4] == 0)
        var_8_1 = sub_1002f3e0(*arg1);
    else
        var_8_1 = 2;
    
    arg1[3] = var_8_1;
    EnumSystemLocalesA(sub_1002ee70, 1);
    
    if ((arg1[2] & 4) == 0)
        arg1[2] = 0;
    
    return arg1;
}

int32_t __stdcall sub_1002ee70(char* arg1)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    void* eax_3 = (__getptd() + 0x9c);
    uint32_t Locale = sub_1002f360(arg1);
    int32_t eax_5 = *(eax_3 + 0x10);
    int32_t eax_6 = -(eax_5);
    void lpLCData;
    
    if (GetLocaleInfoA(Locale, (((eax_6 - eax_6) & 0xfffff002) + 0x1001), &lpLCData, 0x78) != 0)
    {
        if (sub_10031f00(*eax_3, &lpLCData) == 0)
        {
            int32_t eax_14;
            
            if (*(eax_3 + 0x10) == 0)
                eax_14 = sub_1002f2c0(Locale, 1, eax_3);
            
            if ((*(eax_3 + 0x10) != 0 || eax_14 != 0))
            {
                *(eax_3 + 0x1c) = Locale;
                *(eax_3 + 0x18) = Locale;
                *(eax_3 + 8) |= 4;
            }
        }
        else if ((((*(eax_3 + 0x10) == 0 && *(eax_3 + 0xc) != 0) && sub_10031f00(*eax_3, &lpLCData) == 0) && sub_1002f2c0(Locale, 0, eax_3) != 0))
        {
            *(eax_3 + 0x1c) = Locale;
            *(eax_3 + 0x18) = Locale;
            *(eax_3 + 8) |= 4;
        }
        
        *(eax_3 + 8);
    }
    else
        *(eax_3 + 8) = 0;
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

BOOL sub_1002f010(BOOL arg1)
{
    int32_t edx;
    edx = _strlen(*(arg1 + 4)) == 3;
    *(arg1 + 0x14) = edx;
    BOOL result = EnumSystemLocalesA(sub_1002f060, 1);
    
    if ((*(arg1 + 8) & 4) == 0)
    {
        result = arg1;
        *(result + 8) = 0;
    }
    
    return result;
}

int32_t __stdcall sub_1002f060(char* arg1)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    void* eax_3 = (__getptd() + 0x9c);
    uint32_t Locale = sub_1002f360(arg1);
    int32_t eax_5 = *(eax_3 + 0x14);
    int32_t eax_6 = -(eax_5);
    void lpLCData;
    
    if (GetLocaleInfoA(Locale, (((eax_6 - eax_6) & 0xfffff005) + 0x1002), &lpLCData, 0x78) != 0)
    {
        if ((sub_10031f00(*(eax_3 + 4), &lpLCData) == 0 && sub_1002f270(Locale) != 0))
        {
            *(eax_3 + 0x1c) = Locale;
            *(eax_3 + 0x18) = Locale;
            *(eax_3 + 8) |= 4;
        }
        
        *(eax_3 + 8);
    }
    else
        *(eax_3 + 8) = 0;
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

void* sub_1002f160(void* arg1)
{
    *(arg1 + 8) |= 0x104;
    *(arg1 + 0x1c) = GetUserDefaultLCID();
    *(arg1 + 0x18) = *(arg1 + 0x1c);
    return arg1;
}

int32_t sub_1002f1a0(int32_t* arg1, void* arg2)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    void lpLCData;
    
    if ((arg1 == 0 || *arg1 == 0))
    {
    label_1002f1e9:
        
        if (GetLocaleInfoA(*(arg2 + 0x1c), 0x1004, &lpLCData, 8) != 0)
        {
            if (sub_10013c00(&lpLCData, &data_1003f9b0) != 0)
                sub_1002f6b0(&lpLCData);
            else
                GetACP();
        }
    }
    else
    {
        if (sub_10013c00(arg1, &data_1003f9b4) == 0)
            goto label_1002f1e9;
        
        if (sub_10013c00(arg1, &data_1003f9ac) != 0)
            sub_1002f6b0(arg1);
        else if (GetLocaleInfoA(*(arg2 + 0x1c), 0xb, &lpLCData, 8) != 0)
            sub_1002f6b0(&lpLCData);
    }
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t sub_1002f270(int16_t arg1)
{
    int32_t var_8 = 0;
    
    while (true)
    {
        if (var_8 >= 0xa)
            return 1;
        
        if (arg1 == *((var_8 << 1) + &data_1003f800))
            break;
        
        var_8 += 1;
    }
    
    return 0;
}

int32_t sub_1002f2c0(int16_t arg1, int32_t arg2, int32_t* arg3)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    void lpLCData;
    ((GetLocaleInfoA(((arg1 & 0x3ff) | 0x400), 1, &lpLCData, 0x78) != 0 && (arg1 != sub_1002f360(&lpLCData) && arg2 != 0)) && sub_1002f3e0(*arg3) == _strlen(*arg3));
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t sub_1002f360(char* arg1)
{
    int32_t result = 0;
    
    while (true)
    {
        int32_t ecx;
        ecx = *arg1;
        char var_9_1 = ecx;
        arg1 = &arg1[1];
        
        if (var_9_1 == 0)
            break;
        
        if ((var_9_1 >= 0x61 && var_9_1 <= 0x66))
            var_9_1 -= 0x27;
        else if ((var_9_1 >= 0x41 && var_9_1 <= 0x46))
            var_9_1 -= 7;
        
        result = (((result << 4) + var_9_1) - 0x30);
    }
    
    return result;
}

int32_t sub_1002f3e0(char* arg1)
{
    int32_t result = 0;
    char var_9 = *arg1;
    arg1 = &arg1[1];
    
    while (true)
    {
        if ((var_9 < 0x41 || var_9 > 0x5a))
        {
            if (var_9 < 0x61)
                break;
            
            if (var_9 > 0x7a)
                break;
        }
        
        result += 1;
        int32_t eax_1;
        eax_1 = *arg1;
        var_9 = eax_1;
        arg1 = &arg1[1];
    }
    
    return result;
}

int32_t sub_1002f450(void** arg1, uint32_t arg2, int16_t* arg3, int32_t arg4, PWSTR arg5, int32_t arg6, int32_t arg7, int32_t arg8)
{
    void var_14;
    _LocaleUpdate::_LocaleUpdate(&var_14, arg1);
    int32_t var_1c_1 = arg8;
    int32_t var_20 = arg7;
    int32_t result = sub_1002f4b0(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14), arg2, arg3, arg4, arg5, arg6);
    _LocaleUpdate::~_LocaleUpdate(&var_14);
    return result;
}

int32_t sub_1002f4b0(uint32_t arg1, uint32_t arg2, int16_t* arg3, int32_t arg4, PWSTR arg5, int32_t arg6)
{
    if (arg4 > 0)
        arg4 = sub_1002f4f0(arg3, arg4);
    
    return LCMapStringW(arg1, arg2, arg3, arg4, arg5, arg6);
}

int32_t sub_1002f4f0(int16_t* arg1, int32_t arg2)
{
    int32_t var_c = arg2;
    int16_t* var_8 = arg1;
    
    while (true)
    {
        int32_t edx_1 = var_c;
        var_c -= 1;
        
        if ((edx_1 == 0 || *var_8 == 0))
            return ((arg2 - var_c) - 1);
        
        var_8 = &var_8[1];
    }
}

uint32_t sub_1002f540(int16_t arg1, int16_t arg2, void** arg3)
{
    int16_t var_8;
    
    if (arg1 == 0xffff)
        var_8 = 0;
    else if (arg1 >= 0x100)
    {
        void var_18;
        _LocaleUpdate::_LocaleUpdate(&var_18, arg3);
        int32_t eax_4 = *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_18) + 0x14);
        int32_t edx_5 = *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_18) + 4);
        
        if (sub_100323e0(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_18), 1, &arg1, 1, &var_8, edx_5, eax_4) == 0)
            var_8 = 0;
        
        _LocaleUpdate::~_LocaleUpdate(&var_18);
    }
    else
        var_8 = (**&data_10044e28[arg1] & arg2);
    
    return (var_8 & arg2);
}

int32_t sub_1002f5f0(int32_t arg1)
{
    int32_t result = 0;
    
    if (arg1 < 0)
    {
    label_1002f644:
        int32_t var_14_1 = 0;
        
        if ((var_14_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x39, nullptr, u"("Invalid error_mode", 0)") == 1))
            breakpoint();
        
        if (var_14_1 == 0)
        {
            *sub_1000eca0() = 0x16;
            sub_1000c310(u"("Invalid error_mode", 0)", u"_set_error_mode", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x39, 0);
            return 0xffffffff;
        }
    }
    else
    {
        if (arg1 > 2)
        {
            if (arg1 == 3)
                return data_10045610;
            
            goto label_1002f644;
        }
        
        result = data_10045610;
        data_10045610 = arg1;
    }
    
    return result;
}

int32_t sub_1002f6b0(void* arg1)
{
    return sub_1002b2f0(arg1, nullptr, 0xa);
}

int32_t __convention("regparm") __allshl(int32_t arg1, int32_t arg2, char arg3) __pure
{
    if (arg3 >= 0x40)
        return 0;
    
    if (arg3 >= 0x20)
        return 0;
    
    return (arg1 << arg3);
}

int32_t sub_1002f6f0()
{
    return sub_10015620(2);
}

int32_t sub_1002f710(int32_t arg1, void** arg2)
{
    void var_14;
    _LocaleUpdate::_LocaleUpdate(&var_14, arg2);
    int32_t eax_1 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14);
    void* ecx_3;
    
    if (eax_1 != 0)
        ecx_3 = *_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14);
    
    int32_t result;
    
    if ((eax_1 == 0 || *(ecx_3 + 0xac) <= 1))
        result = sub_10024350(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14), arg1, 1);
    else
        result = sub_10024400(arg1, 1, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14));
    
    _LocaleUpdate::~_LocaleUpdate(&var_14);
    return result;
}

int32_t _isupper(int32_t arg1)
{
    if (data_10045ca8 != 0)
        return sub_1002f710(arg1, nullptr);
    
    return sub_10024300(arg1, 1);
}

int32_t sub_1002f7c0(int32_t arg1, void** arg2)
{
    void var_14;
    _LocaleUpdate::_LocaleUpdate(&var_14, arg2);
    int32_t eax_1 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14);
    void* ecx_3;
    
    if (eax_1 != 0)
        ecx_3 = *_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14);
    
    int32_t result;
    
    if ((eax_1 == 0 || *(ecx_3 + 0xac) <= 1))
        result = sub_10024350(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14), arg1, 2);
    else
        result = sub_10024400(arg1, 2, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14));
    
    _LocaleUpdate::~_LocaleUpdate(&var_14);
    return result;
}

int32_t _islower(int32_t arg1)
{
    if (data_10045ca8 != 0)
        return sub_1002f7c0(arg1, nullptr);
    
    return sub_10024300(arg1, 2);
}

int32_t sub_1002f870(int32_t arg1, void** arg2)
{
    void var_14;
    _LocaleUpdate::_LocaleUpdate(&var_14, arg2);
    int32_t eax_1 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14);
    void* ecx_3;
    
    if (eax_1 != 0)
        ecx_3 = *_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14);
    
    int32_t result;
    
    if ((eax_1 == 0 || *(ecx_3 + 0xac) <= 1))
        result = sub_10024350(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14), arg1, 4);
    else
        result = sub_10024400(arg1, 4, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14));
    
    _LocaleUpdate::~_LocaleUpdate(&var_14);
    return result;
}

int32_t _isdigit(int32_t arg1)
{
    if (data_10045ca8 != 0)
        return sub_1002f870(arg1, nullptr);
    
    return sub_10024300(arg1, 4);
}

int32_t sub_1002f920(void** arg1, uint32_t arg2, wchar16* arg3, int32_t arg4, int32_t arg5, int32_t arg6)
{
    void var_14;
    _LocaleUpdate::_LocaleUpdate(&var_14, arg1);
    int32_t var_1c_1 = arg6;
    int32_t var_20 = arg5;
    int32_t result = sub_1002f970(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14), arg2, arg3, arg4);
    _LocaleUpdate::~_LocaleUpdate(&var_14);
    return result;
}

int32_t sub_1002f970(uint32_t arg1, uint32_t arg2, wchar16* arg3, int32_t arg4)
{
    return GetLocaleInfoW(arg1, arg2, arg3, arg4);
}

int32_t sub_1002f990(void** arg1, uint32_t arg2, uint32_t arg3, PSTR arg4, int32_t arg5, uint32_t arg6)
{
    void var_14;
    _LocaleUpdate::_LocaleUpdate(&var_14, arg1);
    int32_t result = sub_1002f9e0(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14), arg2, arg3, arg4, arg5, arg6);
    _LocaleUpdate::~_LocaleUpdate(&var_14);
    return result;
}

int32_t sub_1002f9e0(int32_t* arg1, uint32_t arg2, uint32_t arg3, PSTR arg4, int32_t arg5, uint32_t arg6)
{
    if (data_10046044 == 0)
    {
        if (GetLocaleInfoW(0, 1, nullptr, 0) == 0)
        {
            if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                data_10046044 = 2;
        }
        else
            data_10046044 = 1;
    }
    
    if ((data_10046044 == 2 || data_10046044 == 0))
        return GetLocaleInfoA(arg2, arg3, arg4, arg5);
    
    if (data_10046044 != 1)
        return 0;
    
    int32_t result = 0;
    
    if (arg6 == 0)
        arg6 = *(*arg1 + 4);
    
    int32_t cchData = GetLocaleInfoW(arg2, arg3, nullptr, 0);
    
    if (cchData == 0)
        return 0;
    
    int32_t* var_14_1;
    
    if ((cchData <= 0 || (COMBINE(0, 0xffffffe0) / cchData) < 2))
        var_14_1 = nullptr;
    else
        var_14_1 = __MarkAllocaS(_malloc(((cchData * 2) + 8)), 0xdddd);
    
    wchar16* var_10_1 = var_14_1;
    
    if (var_10_1 == 0)
        return 0;
    
    if (GetLocaleInfoW(arg2, arg3, var_10_1, cchData) != 0)
    {
        if (arg5 != 0)
            result = WideCharToMultiByte(arg6, 0, var_10_1, 0xffffffff, arg4, arg5, nullptr, nullptr);
        else
            result = WideCharToMultiByte(arg6, 0, var_10_1, 0xffffffff, nullptr, 0, nullptr, nullptr);
    }
    
    sub_1002c240(var_10_1);
    return result;
}

int32_t sub_1002fb70()
{
    if (IsDebuggerPresent() == 0)
        return 0;
    
    DebuggerProbe(0x1004);
    /* no return */
}

void DebuggerProbe(int32_t arg1) __noreturn
{
    int32_t ebp;
    int32_t var_4 = ebp;
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10042258;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_44 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t var_48 = (__security_cookie_1 ^ &var_4);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_1c = &var_48;
    char var_1d = 0;
    int32_t lpArguments = 0x1001;
    int32_t var_34 = arg1;
    char* var_30 = &var_1d;
    int32_t var_8_1 = 0;
    RaiseException(0x406d1388, 0, 6, &lpArguments);
    /* no return */
}

uint32_t sub_1002fc0a(int32_t* arg1 @ ebp)
{
    int32_t* esp_4 = arg1[-6];
    arg1[-1] = 0xfffffffe;
    TEB* fsbase;
    fsbase->NtTib.ExceptionList = arg1[-4];
    *esp_4;
    esp_4[1];
    esp_4[2];
    esp_4[3];
    *arg1;
    return *(arg1 - 0x19);
}

uint32_t sub_1002fc30(int16_t arg1, int32_t* arg2)
{
    if ((arg2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x64, nullptr, u"str != NULL") == 1))
        breakpoint();
    
    PWSTR eax_2 = sub_10019e20(arg2);
    
    if ((arg2[3] & 0x82) == 0)
    {
        *sub_1000eca0() = 9;
        arg2[3] |= 0x20;
        return 0xffff;
    }
    
    if ((arg2[3] & 0x40) != 0)
    {
        *sub_1000eca0() = 0x22;
        arg2[3] |= 0x20;
        return 0xffff;
    }
    
    if ((arg2[3] & 1) != 0)
    {
        arg2[1] = 0;
        
        if ((arg2[3] & 0x10) == 0)
        {
            arg2[3] |= 0x20;
            return 0xffff;
        }
        
        *arg2 = arg2[2];
        arg2[3] &= 0xfffffffe;
    }
    
    arg2[3] |= 2;
    arg2[3] &= 0xffffffef;
    arg2[1] = 0;
    int32_t var_10_1 = 0;
    
    if ((arg2[3] & 0x10c) == 0)
    {
        if ((arg2 == 0x10044350 || arg2 == 0x10044370))
        {
            if (sub_10027410(eax_2) == 0)
                sub_10019ea0(arg2);
        }
        else
            sub_10019ea0(arg2);
    }
    
    uint32_t var_8_1;
    
    if ((arg2[3] & 0x108) == 0)
    {
        var_8_1 = 2;
        int16_t var_18 = arg1;
        var_10_1 = sub_1001aef0(eax_2, &var_18, var_8_1);
    }
    else
    {
        arg2[2];
        
        if (((*arg2 - arg2[2]) < 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xa0, nullptr, u"("inconsistent IOB fields", stre…") == 1))
            breakpoint();
        
        var_8_1 = (*arg2 - arg2[2]);
        *arg2 = (arg2[2] + 2);
        arg2[1] = (arg2[6] - 2);
        
        if (var_8_1 <= 0)
        {
            void* var_1c_1;
            
            if ((eax_2 == 0xffffffff || eax_2 == 0xfffffffe))
                var_1c_1 = &data_100445b0;
            else
                var_1c_1 = (((eax_2 & 0x1f) << 6) + &data_10049260[(eax_2 >> 5)]);
            
            if ((*(var_1c_1 + 4) & 0x20) != 0)
            {
                uint32_t eax_32;
                int32_t edx_27;
                eax_32 = sub_100270d0(eax_2, 0, 0, FILE_END);
                
                if ((eax_32 & edx_27) == 0xffffffff)
                {
                    arg2[3] |= 0x20;
                    return 0xffff;
                }
            }
        }
        else
            var_10_1 = sub_1001aef0(eax_2, arg2[2], var_8_1);
        
        *arg2[2] = arg1;
    }
    
    if (var_10_1 == var_8_1)
        return arg1;
    
    arg2[3] |= 0x20;
    return 0xffff;
}

int32_t sub_1002ff10(PWSTR arg1, int32_t arg2, int32_t arg3)
{
    uint32_t var_c = 0;
    int32_t var_8 = 0;
    int32_t var_38 = 0;
    uint32_t eax_1;
    int32_t edx;
    eax_1 = sub_10027320(arg1, 0, 0, FILE_CURRENT);
    
    if ((eax_1 & edx) != 0xffffffff)
    {
        uint32_t eax_2;
        int32_t edx_2;
        eax_2 = sub_10027320(arg1, 0, 0, FILE_END);
        
        if ((eax_2 & edx_2) != 0xffffffff)
        {
            bool c_1 = arg2 < eax_2;
            bool s_1 = (arg3 - edx_2) < 0;
            bool o_1 = /* bool o_1 = unimplemented  {sbb edx, dword [ebp-0x2c]} */;
            uint32_t var_1c_1 = (arg2 - eax_2);
            int32_t var_18_1 = (arg3 - edx_2);
            
            if ((!(s_1) && (((arg3 - edx_2) != 0 && s_1 == o_1) || var_1c_1 > 0)))
            {
                char* lpMem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x1000);
                
                if (lpMem != 0)
                {
                    int32_t eax_10 = __setmode_nolock(arg1, 0x8000);
                    
                    while (true)
                    {
                        uint32_t var_40_1;
                        
                        if ((var_18_1 < 0 || (var_18_1 <= 0 && var_1c_1 < 0x1000)))
                            var_40_1 = var_1c_1;
                        else
                            var_40_1 = 0x1000;
                        
                        uint32_t var_10_1 = var_40_1;
                        uint32_t var_44_1;
                        
                        if ((var_18_1 < 0 || (var_18_1 <= 0 && var_1c_1 < 0x1000)))
                            var_44_1 = var_1c_1;
                        else
                            var_44_1 = 0x1000;
                        
                        int32_t eax_13 = sub_1001b120(arg1, lpMem, var_44_1);
                        
                        if (eax_13 == 0xffffffff)
                        {
                            if (*sub_1000ecd0() == 5)
                            {
                                *sub_1000eca0() = 0xd;
                                int32_t var_38_2 = 0xd;
                            }
                            
                            uint32_t eax_17;
                            int32_t edx_7;
                            edx_7 = HIGHD(eax_13);
                            eax_17 = LOWD(eax_13);
                            var_c = eax_17;
                            var_8 = edx_7;
                            break;
                        }
                        
                        int32_t eax_19;
                        int32_t edx_8;
                        edx_8 = HIGHD(eax_13);
                        eax_19 = LOWD(eax_13);
                        int32_t eax_21 = (var_18_1 - edx_8);
                        var_1c_1 -= eax_19;
                        var_18_1 = eax_21;
                        
                        if (var_18_1 <= 0)
                        {
                            if (var_18_1 < 0)
                                break;
                            
                            if (var_1c_1 <= 0)
                                break;
                        }
                    }
                    
                    __setmode_nolock(arg1, eax_10);
                    HeapFree(GetProcessHeap(), HEAP_NONE, lpMem);
                }
                else
                {
                    *sub_1000eca0() = 0xc;
                    int32_t var_38_1 = 0xc;
                    var_c = 0xffffffff;
                    var_8 = 0xffffffff;
                }
            }
            else if ((var_18_1 <= 0 && (var_18_1 < 0 || var_1c_1 < 0)))
            {
                uint32_t eax_25;
                int32_t edx_11;
                eax_25 = sub_10027320(arg1, arg2, arg3, FILE_BEGIN);
                var_c = eax_25;
                var_8 = edx_11;
                
                if ((var_c & var_8) != 0xffffffff)
                {
                    BOOL eax_27 = SetEndOfFile(sub_1002ab30(arg1));
                    int32_t eax_28 = -(eax_27);
                    uint32_t eax_32;
                    int32_t edx_13;
                    edx_13 = HIGHD((-((eax_28 - eax_28)) - 1));
                    eax_32 = LOWD((-((eax_28 - eax_28)) - 1));
                    var_c = eax_32;
                    var_8 = edx_13;
                    
                    if ((var_c & var_8) == 0xffffffff)
                    {
                        *sub_1000eca0() = 0xd;
                        int32_t var_38_3 = 0xd;
                        *sub_1000ecd0() = GetLastError();
                    }
                }
            }
            
            if ((var_c & var_8) != 0xffffffff)
            {
                uint32_t eax_39;
                int32_t edx_15;
                eax_39 = sub_10027320(arg1, eax_1, edx, FILE_BEGIN);
                
                if ((eax_39 & edx_15) != 0xffffffff)
                    return 0;
            }
        }
    }
    
    return *sub_1000eca0();
}

int32_t __setmode_nolock(int32_t arg1, int32_t arg2)
{
    int32_t eax_3 = (*((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) & 0x80);
    int32_t ecx_4;
    ecx_4 = *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x24);
    ecx_4 <<= 1;
    ecx_4 s>>= 1;
    
    if (arg2 == 0x10000)
        goto label_100303a3;
    
    if (arg2 == 0x4000)
    {
        *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) |= 0x80;
        int32_t edx_16;
        edx_16 = *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x24);
        edx_16 &= 0x80;
        *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x24) = edx_16;
    }
    else if (arg2 == 0x8000)
        *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) &= 0x7f;
    
    if (arg2 == 0x20000)
    {
    label_100303a3:
        *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) |= 0x80;
        int32_t ecx_34;
        ecx_34 = *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x24);
        ecx_34 &= 0x80;
        ecx_34 |= 2;
        *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x24) = ecx_34;
    }
    else if (arg2 == 0x40000)
    {
        *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 4) |= 0x80;
        int32_t eax_25;
        eax_25 = *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x24);
        eax_25 &= 0x80;
        eax_25 |= 1;
        *((&data_10049260[(arg1 >> 5)] + ((arg1 & 0x1f) << 6)) + 0x24) = eax_25;
    }
    
    if (eax_3 == 0)
        return 0x8000;
    
    if (ecx_4 != 0)
        return 0x10000;
    
    return 0x4000;
}

int32_t sub_10030410(int32_t* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t eax;
    eax = arg1 != 0;
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0xa0, nullptr, u"(pMode != NULL)") == 1))
        breakpoint();
    
    if (eax != 0)
    {
        *arg1 = data_10046114;
        return 0;
    }
    
    *sub_1000eca0() = 0x16;
    sub_1000c310(u"(pMode != NULL)", u"_get_fmode", u"f:\dd\vctools\crt_bld\self_x86\c…", 0xa0, 0);
    return 0x16;
}

HANDLE ___initconout()
{
    HANDLE result = CreateFileA("CONOUT$", 0x40000000, FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, SECURITY_ANONYMOUS, nullptr);
    data_10044f48 = result;
    return result;
}

void ___termconout()
{
    if ((data_10044f48 != 0xffffffff && data_10044f48 != 0xfffffffe))
        CloseHandle(data_10044f48);
    
    if ((data_10044f44 != 0xffffffff && data_10044f44 != 0xfffffffe))
        CloseHandle(data_10044f44);
}

int32_t sub_10030510(int32_t* arg1, int32_t* arg2, int32_t arg3, void* arg4, int32_t* arg5, int32_t arg6, int32_t arg7, char arg8)
{
    if ((*(__getptd() + 0x20c) == 0 && (*arg1 != 0xe06d7363 && (*arg1 != 0x80000026 && ((*arg5 & 0x1fffffff) >= 0x19930522 && (arg5[8] & 1) != 0)))))
        return 1;
    
    if ((arg1[1] & 0x66) != 0)
    {
        if ((arg5[1] != 0 && arg6 == 0))
        {
            int32_t var_10_1 = 0xffffffff;
            sub_10030e70(arg2, arg4, arg5);
        }
        
        return 1;
    }
    
    if (arg5[3] != 0)
    {
    label_100305ec:
        
        if ((*arg1 == 0xe06d7363 && (arg1[4] >= 3 && arg1[5] > 0x19930522)))
        {
            int32_t eax_10 = *(arg1[7] + 8);
            
            if (eax_10 != 0)
                return eax_10(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        }
        
        sub_10030670(arg1, arg2, arg3, arg4, arg5, arg8, arg6, arg7);
    }
    else if (((*arg5 & 0x1fffffff) >= 0x19930521 && arg5[7] != 0))
        goto label_100305ec;
    
    return 1;
}

void* sub_10030670(EXCEPTION_RECORD* arg1, int32_t* arg2, int32_t arg3, void* arg4, int32_t* arg5, char arg6, int32_t arg7, int32_t arg8)
{
    char var_9 = 0;
    char var_a = 0;
    int32_t var_48;
    
    if (arg5[1] > 0x80)
        var_48 = arg2[2];
    else
        var_48 = arg2[2];
    
    if ((var_48 < 0xffffffff || var_48 >= arg5[1]))
        sub_10016230();
    
    void* result;
    
    if ((*arg1 != 0xe06d7363 || arg1->NumberParameters != 3))
    {
    label_1003086f:
        
        if (((arg1->ExceptionCode == 0xe06d7363 && arg1->NumberParameters == 3) && ((arg1->ExceptionInformation[0] == 0x19930520 || arg1->ExceptionInformation[0] == 0x19930521) || arg1->ExceptionInformation[0] == 0x19930522)))
        {
            if (arg5[3] > 0)
            {
                int32_t var_18;
                int32_t var_14;
                int32_t* var_1c_1 = sub_1002bb70(arg5, arg7, var_48, &var_14, &var_18);
                
                while (var_14 < var_18)
                {
                    if ((*var_1c_1 <= var_48 && var_48 <= var_1c_1[1]))
                    {
                        int32_t* var_24_1 = var_1c_1[4];
                        int32_t var_20_1 = var_1c_1[3];
                    label_100308fe:
                        
                        if (var_20_1 > 0)
                        {
                            int32_t** var_2c_1 = (*(arg1->ExceptionInformation[2] + 0xc) + 4);
                            int32_t var_28_1 = **(arg1->ExceptionInformation[2] + 0xc);
                            
                            while (true)
                            {
                                if (var_28_1 <= 0)
                                {
                                    var_20_1 -= 1;
                                    var_24_1 = &var_24_1[4];
                                    goto label_100308fe;
                                }
                                
                                int32_t* eax_32 = *var_2c_1;
                                
                                if (sub_10030d40(var_24_1, eax_32, arg1->ExceptionInformation[2]) != 0)
                                {
                                    var_a = 1;
                                    uint32_t var_4c_8 = var_9;
                                    sub_10030ff0(arg1, arg2, arg3, arg4, arg5, var_24_1, eax_32, var_1c_1, arg7, arg8);
                                    break;
                                }
                                
                                var_28_1 -= 1;
                                var_2c_1 = &var_2c_1[1];
                            }
                        }
                    }
                    
                    var_14 += 1;
                    var_1c_1 = &var_1c_1[5];
                }
            }
            
            if (arg6 != 0)
            {
                int32_t var_4c_9 = 1;
                sub_10031730(arg1);
            }
            
            if (((var_a == 0 && ((*arg5 & 0x1fffffff) >= 0x19930521 && arg5[7] != 0)) && IsInExceptionSpec(arg1, arg5[7]) == 0))
            {
                int32_t var_38_1 = *(__getptd() + 0x88);
                int32_t var_34_1 = *(__getptd() + 0x8c);
                *(__getptd() + 0x88) = arg1;
                *(__getptd() + 0x8c) = arg3;
                
                if (arg8 != 0)
                    sub_1002b870(arg8, arg1);
                else
                    sub_1002b870(arg2, arg1);
                
                int32_t var_4c_13 = 0xffffffff;
                sub_10030e70(arg2, arg4, arg5);
                int32_t var_4c_14 = arg5[7];
                sub_100318f0();
                *(__getptd() + 0x88) = arg1;
                *(__getptd() + 0x8c) = arg3;
            }
        }
        else if (arg5[3] > 0)
        {
            if (arg6 != 0)
                sub_10016180();
            else
                sub_10030bc0(arg1, arg2, arg3, arg4, arg5, var_48, arg7, arg8);
        }
        
        result = __getptd();
        
        if (*(result + 0x94) != 0)
            return sub_10016230();
    }
    else
    {
        if ((arg1->ExceptionInformation[0] != 0x19930520 && arg1->ExceptionInformation[0] != 0x19930521))
        {
            if ((arg1->ExceptionInformation[0] != 0x19930522 || arg1->ExceptionInformation[2] != 0))
                goto label_1003086f;
            
            goto label_10030718;
        }
        
        if (arg1->ExceptionInformation[2] != 0)
            goto label_1003086f;
        
    label_10030718:
        result = __getptd();
        
        if (*(result + 0x88) != 0)
        {
            arg1 = *(__getptd() + 0x88);
            arg3 = *(__getptd() + 0x8c);
            var_9 = 1;
            int32_t var_4c_1 = 1;
            
            if (_ValidateRead(arg1) == 0)
                sub_10016230();
            
            if ((arg1->ExceptionCode == 0xe06d7363 && (arg1->NumberParameters == 3 && (((arg1->ExceptionInformation[0] == 0x19930520 || arg1->ExceptionInformation[0] == 0x19930521) || arg1->ExceptionInformation[0] == 0x19930522) && arg1->ExceptionInformation[2] == 0))))
                sub_10016230();
            
            if (*(__getptd() + 0x94) != 0)
            {
                int32_t* eax_13 = *(__getptd() + 0x94);
                *(__getptd() + 0x94) = 0;
                
                if (IsInExceptionSpec(arg1, eax_13) == 0)
                {
                    if (Is_bad_exception_allowed(eax_13) != 0)
                    {
                        int32_t var_4c_4 = 1;
                        sub_10031730(arg1);
                        char const* const var_4c_5 = "bad exception";
                        void var_44;
                        sub_10030b10(&var_44);
                        sub_1000ed00(&var_44, &data_10042274);
                        /* no return */
                    }
                    
                    sub_10016180();
                }
            }
            
            goto label_1003086f;
        }
    }
    
    return result;
}

int32_t* __fastcall sub_10030b10(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    sub_1000c090(arg1, &arg_4);
    *arg1 = 0x1003fe74;
    return arg1;
}

int32_t* __fastcall sub_10030b40(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    *arg1 = 0x1003fe74;
    return sub_1000c1f0(arg1);
}

int32_t* __thiscall sub_10030b60(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    sub_10030b40(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80(arg1);
    
    return arg1;
}

int32_t* __thiscall sub_10030b90(int32_t* arg1, void* arg2)
{
    int32_t* var_8 = arg1;
    sub_1000c150(arg1, arg2);
    *arg1 = 0x1003fe74;
    return arg1;
}

int32_t* sub_10030bc0(int32_t* arg1, int32_t* arg2, int32_t arg3, void* arg4, void* arg5, int32_t arg6, int32_t arg7, int32_t arg8)
{
    int32_t* result = arg1;
    
    if (*result != 0x80000003)
    {
        if (*(__getptd() + 0x80) == 0)
        {
        label_10030c3a:
            
            if (*(arg5 + 0xc) == 0)
                sub_10016230();
            
            int32_t var_10;
            int32_t* result_1;
            result = sub_1002bb70(arg5, arg7, arg6, &result_1, &var_10);
            int32_t* result_2 = result;
            
            while (result_1 < var_10)
            {
                if ((arg6 >= *result_2 && (arg6 <= result_2[1] && ((*((result_2[4] + ((result_2[3] - 1) << 4)) + 4) == 0 || *(*((result_2[4] + ((result_2[3] - 1) << 4)) + 4) + 8) == 0) && (result_2[4][((result_2[3] - 1) * 4)] & 0x40) == 0))))
                {
                    int32_t var_18_3 = 1;
                    sub_10030ff0(arg1, arg2, arg3, arg4, arg5, (((result_2[3] - 1) << 4) + result_2[4]), nullptr, result_2, arg7, arg8);
                }
                
                result = (result_1 + 1);
                result_1 = result;
                result_2 = &result_2[5];
            }
        }
        else
        {
            void* eax_1 = __getptd();
            int32_t eax_2 = __Getmonths();
            
            if ((*(eax_1 + 0x80) == eax_2 || *arg1 == 0xe0434f4d))
                goto label_10030c3a;
            
            int32_t var_18_1 = arg8;
            result = sub_1002b9d0(arg1, arg2, arg3, arg4, arg5, arg7);
            
            if (result == 0)
                goto label_10030c3a;
        }
    }
    
    return result;
}

int32_t sub_10030d40(int32_t* arg1, int32_t* arg2, int32_t* arg3)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if ((arg1[1] == 0 || *(arg1[1] + 8) == 0))
        return 1;
    
    if ((arg1[1] != arg2[1] && sub_10013c00((arg1[1] + 8), (arg2[1] + 8)) != 0))
        return 0;
    
    if ((((*arg2 & 2) == 0 || (*arg1 & 8) != 0) && (((*arg3 & 1) == 0 || (*arg1 & 1) != 0) && ((*arg3 & 2) == 0 || (*arg1 & 2) != 0))))
        return 1;
    
    return 0;
}

int32_t sub_10030df0(int32_t* arg1)
{
    int32_t eax_1 = **arg1;
    
    if (eax_1 == 0xe0434f4d)
        goto label_10030e30;
    
    if (eax_1 == 0xe06d7363)
    {
        *(__getptd() + 0x90) = 0;
        sub_10016180();
    label_10030e30:
        
        if (*(__getptd() + 0x90) > 0)
        {
            void* eax_5 = (__getptd() + 0x90);
            *eax_5 -= 1;
        }
    }
    
    return 0;
}

void* sub_10030e70(void* arg1, void* arg2, int32_t arg3)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x100422b0;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_3c = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_40 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_1c = &var_40;
    int32_t i_1;
    
    if (*(arg2 + 4) > 0x80)
        i_1 = *(arg1 + 8);
    else
        i_1 = *(arg1 + 8);
    
    int32_t i = i_1;
    void* eax_6 = (__getptd() + 0x90);
    *eax_6 += 1;
    int32_t var_8_1 = 0;
    int32_t i_2;
    
    for (; i != arg3; i = i_2)
    {
        if ((i <= 0xffffffff || i >= *(arg2 + 4)))
            sub_10016230();
        
        i_2 = *(*(arg2 + 8) + (i << 3));
        int32_t var_8_2 = 1;
        
        if (*((*(arg2 + 8) + (i << 3)) + 4) != 0)
        {
            *(arg1 + 8) = i_2;
            __CallSettingFrame@12(i, *((*(arg2 + 8) + (i << 3)) + 4), arg1, 0x103);
        }
        
        int32_t var_8_3 = 0;
    }
    
    int32_t var_8_4 = 0xfffffffe;
    $LN18(&__saved_ebp);
    
    if (i != arg3)
        sub_10016230();
    
    *(arg1 + 8) = i;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg1;
}

int32_t sub_10030f6d(void* arg1 @ ebp)
{
    sub_10030df0(*(arg1 - 0x14));
    return 0;
}

void* $LN18(void* arg1 @ ebp)
{
    void* result = __getptd();
    
    if (*(result + 0x90) > 0)
    {
        *(arg1 - 0x2c) = (__getptd() + 0x90);
        result = (**(arg1 - 0x2c) - 1);
        **(arg1 - 0x2c) = result;
    }
    
    return result;
}

int32_t sub_10030ff0(EXCEPTION_RECORD* arg1, int32_t* arg2, int32_t arg3, void* arg4, int32_t arg5, int32_t* arg6, int32_t* arg7, int32_t* arg8, int32_t arg9, int32_t arg10)
{
    if (arg7 != 0)
        sub_10031620(arg1, arg2, arg6, arg7);
    
    if (arg10 != 0)
        sub_1002b870(arg10, arg1);
    else
        sub_1002b870(arg2, arg1);
    
    int32_t var_10_4 = *arg8;
    sub_10030e70(arg2, arg4, arg5);
    arg2[2] = (arg8[1] + 1);
    int32_t result = sub_100310b0(arg1, arg2, arg3, arg5, arg6[3], arg9, 0x100);
    
    if (result == 0)
        return result;
    
    return _JumpToContinuation(result, arg2);
}

int32_t sub_100310b0(void* arg1, void* arg2, int32_t arg3, int32_t arg4, int32_t* arg5, int32_t arg6, int32_t arg7)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x100422d8;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_60 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_64 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_1c = &var_64;
    int32_t* var_34 = arg5;
    int32_t var_28 = 0;
    int32_t var_24 = *(arg2 - 4);
    void var_30;
    int32_t* var_20 = sub_1002bbf0(&var_30, *(arg1 + 0x18));
    int32_t var_3c = *(__getptd() + 0x88);
    int32_t var_38 = *(__getptd() + 0x8c);
    *(__getptd() + 0x88) = arg1;
    *(__getptd() + 0x8c) = arg3;
    int32_t var_8_1 = 0;
    int32_t var_50 = 1;
    int32_t var_8_2 = 1;
    int32_t result = sub_1002b910(arg2, arg4, arg5, arg6, arg7);
    int32_t var_8_3 = 0;
    int32_t var_8_4 = 0xfffffffe;
    int32_t var_50_1 = 0;
    sub_10031288(&__saved_ebp);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10031189(void* arg1 @ ebp)
{
    return ExFilterRethrow(*(arg1 - 0x14));
}

int32_t sub_10031196(int32_t* arg1 @ ebp)
{
    int32_t esp_10 = arg1[-6];
    *(__getptd() + 0x20c) = 0;
    arg1[-0x12] = *(arg1[5] + 8);
    
    if (*(arg1[5] + 4) > 0x80)
        arg1[-0x14] = *(arg1[3] + 8);
    else
        arg1[-0x14] = *(arg1[3] + 8);
    
    arg1[-0x11] = arg1[-0x14];
    arg1[-0x10] = *(arg1[5] + 0x10);
    arg1[-0xf] = 0;
    
    while (arg1[-0xf] < *(arg1[5] + 0xc))
    {
        if ((arg1[-0x11] > *((arg1[-0x10] + (arg1[-0xf] * 0x14)) + 4) && arg1[-0x11] <= *((arg1[-0x10] + (arg1[-0xf] * 0x14)) + 8)))
        {
            arg1[-0x11] = (*((arg1[-0x10] + (arg1[-0xf] * 0x14)) + 4) + 1);
            arg1[-0x11] = *(arg1[-0x12] + (arg1[-0x11] << 3));
            break;
        }
        
        arg1[-0xf] += 1;
    }
    
    *(esp_10 - 4) = arg1[-0x11];
    *(esp_10 - 8) = arg1[5];
    *(esp_10 - 0xc) = 0;
    *(esp_10 - 0x10) = arg1[3];
    sub_10030e70();
    arg1[-0xc] = 0;
    arg1[-1] = 0;
    arg1[-1] = 0xfffffffe;
    arg1[-0x13] = 0;
    sub_10031288(arg1);
    TEB* fsbase;
    fsbase->NtTib.ExceptionList = arg1[-4];
    *esp_10;
    *(esp_10 + 4);
    *(esp_10 + 8);
    *(esp_10 + 0xc);
    *arg1;
    return arg1[-0xc];
}

int32_t* sub_10031288(void* arg1 @ ebp)
{
    *(*(arg1 + 0xc) - 4) = *(arg1 - 0x20);
    __FindAndUnlinkFrame(*(arg1 - 0x1c));
    void* eax_1 = __getptd();
    *(eax_1 + 0x88) = *(arg1 - 0x38);
    void* eax_2 = __getptd();
    *(eax_2 + 0x8c) = *(arg1 - 0x34);
    int32_t* result = *(arg1 + 8);
    
    if ((*result == 0xe06d7363 && *(*(arg1 + 8) + 0x10) == 3))
    {
        if (*(*(arg1 + 8) + 0x14) != 0x19930520)
            result = *(arg1 + 8);
        
        if ((((*(*(arg1 + 8) + 0x14) == 0x19930520 || result[5] == 0x19930521) || *(*(arg1 + 8) + 0x14) == 0x19930522) && (*(arg1 - 0x24) == 0 && *(arg1 - 0x30) != 0)))
        {
            result = __IsExceptionObjectToBeDestroyed(*(*(arg1 + 8) + 0x18));
            
            if (result != 0)
            {
                int32_t var_4_2 = *(arg1 - 0x4c);
                return sub_10031730(*(arg1 + 8));
            }
        }
    }
    
    return result;
}

int32_t ExFilterRethrow(int32_t* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t* ecx_1 = *arg1;
    
    if ((*ecx_1 != 0xe06d7363 || (ecx_1[4] != 3 || (((ecx_1[5] != 0x19930520 && ecx_1[5] != 0x19930521) && ecx_1[5] != 0x19930522) || ecx_1[7] != 0))))
        return 0;
    
    *(__getptd() + 0x20c) = 1;
    return 1;
}

int32_t sub_100313b0(void* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10042300;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_34 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_1c = &var_34;
    int32_t result_1 = 0;
    int32_t result;
    
    if (((arg3[1] == 0 || *(arg3[1] + 8) == 0) || (arg3[2] == 0 && (*arg3 & 0x80000000) == 0)))
        result = 0;
    else
    {
        int32_t* var_24_1;
        
        if ((*arg3 & 0x80000000) == 0)
            var_24_1 = ((arg2 + arg3[2]) + 0xc);
        else
            var_24_1 = arg2;
        
        int32_t var_8_1 = 0;
        
        if ((*arg3 & 8) != 0)
        {
            int32_t var_38_1 = 1;
            int32_t eax_10 = _ValidateRead(*(arg1 + 0x18));
            int32_t eax_12;
            
            if (eax_10 != 0)
            {
                int32_t var_38_2 = 1;
                eax_12 = _ValidateRead(var_24_1);
            }
            
            if ((eax_10 == 0 || eax_12 == 0))
                sub_10016230();
            else
            {
                *var_24_1 = *(arg1 + 0x18);
                *var_24_1 = ___AdjustPointer(*var_24_1, &arg4[2]);
            }
        }
        else if ((*arg4 & 1) != 0)
        {
            int32_t var_38_4 = 1;
            int32_t eax_18 = _ValidateRead(*(arg1 + 0x18));
            int32_t eax_20;
            
            if (eax_18 != 0)
            {
                int32_t var_38_5 = 1;
                eax_20 = _ValidateRead(var_24_1);
            }
            
            if ((eax_18 == 0 || eax_20 == 0))
                sub_10016230();
            else
            {
                sub_10014000(var_24_1, *(arg1 + 0x18), arg4[5]);
                
                if ((arg4[5] == 4 && *var_24_1 != 0))
                    *var_24_1 = ___AdjustPointer(*var_24_1, &arg4[2]);
            }
        }
        else if (arg4[6] != 0)
        {
            int32_t var_38_11 = 1;
            
            if (_ValidateRead(*(arg1 + 0x18)) == 0)
                sub_10016230();
            else
            {
                int32_t var_38_12 = 1;
                
                if (_ValidateRead(var_24_1) == 0)
                    sub_10016230();
                else if (_ValidateRead(arg4[6]) == 0)
                    sub_10016230();
                else if ((*arg4 & 4) == 0)
                    result_1 = 1;
                else
                    result_1 = 2;
            }
        }
        else
        {
            int32_t var_38_8 = 1;
            int32_t eax_26 = _ValidateRead(*(arg1 + 0x18));
            int32_t eax_28;
            
            if (eax_26 != 0)
            {
                int32_t var_38_9 = 1;
                eax_28 = _ValidateRead(var_24_1);
            }
            
            if ((eax_26 == 0 || eax_28 == 0))
                sub_10016230();
            else
                sub_10014000(var_24_1, ___AdjustPointer(*(arg1 + 0x18), &arg4[2]), arg4[5]);
        }
        
        int32_t var_8_2 = 0xfffffffe;
        result = result_1;
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_100315f6() __pure
{
    return 1;
}

int32_t sub_10031620(void* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10042320;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t ebx;
    int32_t var_28 = ebx;
    int32_t esi;
    int32_t var_2c = esi;
    int32_t edi;
    int32_t var_30 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t* var_34 = (__security_cookie_1 ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_1c = &var_34;
    int32_t* var_20;
    
    if ((*arg3 & 0x80000000) == 0)
        var_20 = ((arg2 + arg3[2]) + 0xc);
    else
        var_20 = arg2;
    
    int32_t var_8_1 = 0;
    int32_t* var_38 = arg4;
    int32_t result = sub_100313b0(arg1, arg2, arg3, var_38);
    int32_t** esp = &var_34;
    
    if (result == 1)
    {
        var_38 = &arg4[2];
        var_38 = ___AdjustPointer(*(arg1 + 0x18), var_38);
        result = sub_1002b860(var_20, arg4[6], var_38);
        esp = &var_34;
    }
    else if (result == 2)
    {
        var_38 = 1;
        void* eax_10 = ___AdjustPointer(*(arg1 + 0x18), &arg4[2]);
        result = sub_1002b860(var_20, arg4[6], eax_10);
        esp = &var_38;
    }
    
    int32_t var_8_2 = 0xfffffffe;
    fsbase->NtTib.ExceptionList = ExceptionList;
    *esp;
    esp[1];
    esp[2];
    esp[3];
    return result;
}

int32_t sub_10031705() __pure
{
    return 1;
}

int32_t* sub_10031730(int32_t* arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x10042340;
    int32_t (* var_10)(int32_t* arg1, int32_t arg2, int32_t arg3) = sub_10013490;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t edi;
    int32_t var_28 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t* result = (__security_cookie_1 ^ &__saved_ebp);
    int32_t* result_1 = result;
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_1c = &result_1;
    
    if (arg1 != 0)
    {
        result = arg1;
        
        if ((*result == 0xe06d7363 && arg1[7] != 0))
        {
            result = arg1[7];
            
            if (result[1] != 0)
            {
                int32_t var_8_1 = 0;
                result = sub_1002b860(arg1[6], *(arg1[7] + 4));
                int32_t var_8_2 = 0xfffffffe;
            }
        }
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_100317b3(void* arg1 @ ebp)
{
    uint32_t eax_3 = *(arg1 + 0xc);
    int32_t eax = -(eax_3);
    return -((eax - eax));
}

void* ___AdjustPointer(int32_t* arg1, void* arg2)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    void* result = (arg1 + *arg2);
    
    if (*(arg2 + 4) < 0)
        return result;
    
    return ((result + *(*(arg1 + *(arg2 + 4)) + *(arg2 + 8))) + *(arg2 + 4));
}

int32_t IsInExceptionSpec(void* arg1, int32_t* arg2)
{
    if (arg2 == 0)
        sub_10016230();
    
    if (arg2 == 0)
        sub_10016180();
    
    char var_11 = 0;
    
    for (int32_t i = 0; i < *arg2; i += 1)
    {
        int32_t* var_c_1 = (*(*(arg1 + 0x1c) + 0xc) + 4);
        int32_t j = **(*(arg1 + 0x1c) + 0xc);
        
        while (j > 0)
        {
            if (sub_10030d40(((i << 4) + arg2[1]), *var_c_1, *(arg1 + 0x1c)) != 0)
            {
                var_11 = 1;
                break;
            }
            
            j -= 1;
            var_c_1 = &var_c_1[1];
        }
    }
    
    int32_t result;
    result = var_11;
    return result;
}

int32_t sub_100318f0()
{
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = __ehhandler$??_U@YAPAXIW4align_val_t@std@@ABUnothrow_t@1@@Z;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t ecx;
    int32_t var_14 = ecx;
    int32_t edi;
    int32_t var_20 = edi;
    int32_t __saved_ebp;
    int32_t var_24 = (__security_cookie ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_14_1 = &var_24;
    
    if (*(__getptd() + 0x94) != 0)
        sub_10016230();
    
    int32_t var_8_1 = 0;
    sub_10016200();
    int32_t var_8_2 = 0xffffffff;
    int32_t result = sub_10016180();
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

void sub_1003193e(void* arg1 @ ebp) __noreturn
{
    void* eax = __getptd();
    *(eax + 0x94) = *(arg1 + 8);
    sub_1000ed00(0, nullptr);
    /* no return */
}

uint32_t Is_bad_exception_allowed(int32_t* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    uint32_t var_8_1 = 0;
    uint32_t result;
    
    while (true)
    {
        if (var_8_1 >= *arg1)
        {
            result = 0;
            break;
        }
        
        if (sub_1000ace0(*((arg1[1] + (var_8_1 << 4)) + 4), &data_10044f50) != 0)
        {
            result = 1;
            break;
        }
        
        var_8_1 += 1;
    }
    
    return result;
}

int32_t __thiscall __CallSettingFrame@12(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    int32_t ebp;
    int32_t var_4 = ebp;
    int32_t ebx;
    int32_t var_c = ebx;
    int32_t* var_14 = &var_4;
    int32_t var_18 = arg4;
    int32_t edx;
    __NLG_Notify1(arg2, edx, arg4, (arg3 + 0xc));
    int32_t esi;
    int32_t var_18_1 = esi;
    int32_t edi;
    int32_t var_1c = edi;
    int32_t result;
    int32_t edx_1;
    result = arg2();
    int32_t ecx_1 = arg1[4];
    
    if (ecx_1 == 0x100)
        ecx_1 = 2;
    
    int32_t var_14_1 = ecx_1;
    __NLG_Notify1(result, edx_1, ecx_1, (arg3 + 0xc));
    *arg1;
    return result;
}

int32_t sub_10031a20(uint32_t arg1)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    char var_e = 0;
    void lpLCData;
    
    if (GetLocaleInfoA(arg1, 0x1004, &lpLCData, 6) != 0)
        int32_t var_8 = sub_1002f6b0(&lpLCData);
    else
        var_8 = 0xffffffff;
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

int32_t sub_10031a80(uint32_t arg1, uint32_t arg2, uint8_t* arg3, int32_t* arg4, PSTR arg5, int32_t arg6)
{
    int32_t __saved_ebp;
    int32_t eax_1 = (__security_cookie ^ &__saved_ebp);
    PSTR lpMultiByteStr = nullptr;
    int32_t cbMultiByte = *arg4;
    int32_t var_10 = 0;
    
    if (arg1 != arg2)
    {
        int32_t var_18_1 = 0;
        int32_t lpCPInfo;
        
        if (((GetCPInfo(arg1, &lpCPInfo) != 0 && lpCPInfo == 1) && (GetCPInfo(arg2, &lpCPInfo) != 0 && lpCPInfo == 1)))
            var_10 = 1;
        
        int32_t cbMultiByte_1;
        
        if (var_10 != 0)
        {
            if (cbMultiByte == 0xffffffff)
                cbMultiByte_1 = (_strlen(arg3) + 1);
            else
                cbMultiByte_1 = cbMultiByte;
        }
        
        if (var_10 != 0)
        {
        label_10031b57:
            int32_t* lpWideCharStr_1;
            
            if ((cbMultiByte_1 <= 0 || cbMultiByte_1 > 0x7ffffff0))
                lpWideCharStr_1 = nullptr;
            else
                lpWideCharStr_1 = __MarkAllocaS(_malloc(((cbMultiByte_1 * 2) + 8)), 0xdddd);
            
            wchar16* lpWideCharStr = lpWideCharStr_1;
            
            if (lpWideCharStr != 0)
            {
                sub_1000fae0(lpWideCharStr, 0, (cbMultiByte_1 << 1));
                
                if (MultiByteToWideChar(arg1, MB_PRECOMPOSED, arg3, cbMultiByte, lpWideCharStr, cbMultiByte_1) != 0)
                {
                    if (arg5 != 0)
                    {
                        if (WideCharToMultiByte(arg2, 0, lpWideCharStr, cbMultiByte_1, arg5, arg6, nullptr, nullptr) != 0)
                            lpMultiByteStr = arg5;
                    }
                    else if (var_10 != 0)
                    {
                    label_10031c48:
                        lpMultiByteStr = sub_10010b10(1, cbMultiByte_1, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x97);
                        
                        if (lpMultiByteStr != 0)
                        {
                            int32_t eax_26 = WideCharToMultiByte(arg2, 0, lpWideCharStr, cbMultiByte_1, lpMultiByteStr, cbMultiByte_1, nullptr, nullptr);
                            
                            if (eax_26 == 0)
                            {
                                sub_10011340(lpMultiByteStr, 2);
                                lpMultiByteStr = nullptr;
                            }
                            else if (cbMultiByte != 0xffffffff)
                                *arg4 = eax_26;
                        }
                    }
                    else
                    {
                        cbMultiByte_1 = WideCharToMultiByte(arg2, 0, lpWideCharStr, cbMultiByte_1, nullptr, 0, nullptr, nullptr);
                        
                        if (cbMultiByte_1 != 0)
                            goto label_10031c48;
                    }
                }
                
                if (lpWideCharStr != 0)
                    sub_1002c240(lpWideCharStr);
            }
        }
        else
        {
            cbMultiByte_1 = MultiByteToWideChar(arg1, MB_PRECOMPOSED, arg3, cbMultiByte, nullptr, 0);
            
            if (cbMultiByte_1 != 0)
                goto label_10031b57;
        }
    }
    
    return sub_1000ac70((eax_1 ^ &__saved_ebp));
}

uint32_t sub_10031cd0(char* arg1, char* arg2, void** arg3)
{
    void var_1c;
    _LocaleUpdate::_LocaleUpdate(&var_1c, arg3);
    int32_t ecx_1;
    ecx_1 = arg1 != 0;
    
    if ((ecx_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x34, nullptr, u"dst != NULL") == 1))
        breakpoint();
    
    if (ecx_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"dst != NULL", u"_stricmp_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x34, 0);
        _LocaleUpdate::~_LocaleUpdate(&var_1c);
        return 0x7fffffff;
    }
    
    int32_t eax_4;
    eax_4 = arg2 != 0;
    
    if ((eax_4 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x35, nullptr, u"src != NULL") == 1))
        breakpoint();
    
    if (eax_4 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"src != NULL", u"_stricmp_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x35, 0);
        _LocaleUpdate::~_LocaleUpdate(&var_1c);
        return 0x7fffffff;
    }
    
    if (*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_1c) + 0x14) == 0)
    {
        uint32_t result = sub_10031e80(arg1, arg2);
        _LocaleUpdate::~_LocaleUpdate(&var_1c);
        return result;
    }
    
    uint32_t eax_11;
    uint32_t eax_14;
    
    do
    {
        eax_11 = sub_10032490(*arg1, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_1c));
        arg1 = &arg1[1];
        eax_14 = sub_10032490(*arg2, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_1c));
        arg2 = &arg2[1];
        
        if (eax_11 == 0)
            break;
    } while (eax_11 == eax_14);
    
    _LocaleUpdate::~_LocaleUpdate(&var_1c);
    return (eax_11 - eax_14);
}

uint32_t sub_10031e80(char* arg1, char* arg2)
{
    uint32_t var_c_1;
    uint32_t var_8_1;
    
    do
    {
        var_8_1 = *arg1;
        arg1 = &arg1[1];
        
        if ((var_8_1 >= 0x41 && var_8_1 <= 0x5a))
            var_8_1 += 0x20;
        
        var_c_1 = *arg2;
        arg2 = &arg2[1];
        
        if ((var_c_1 >= 0x41 && var_c_1 <= 0x5a))
            var_c_1 += 0x20;
        
        if (var_8_1 == 0)
            break;
    } while (var_8_1 == var_c_1);
    
    return (var_8_1 - var_c_1);
}

uint32_t sub_10031f00(char* arg1, char* arg2)
{
    if (data_10045ca8 != 0)
        return sub_10031cd0(arg1, arg2, nullptr);
    
    int32_t eax;
    eax = arg1 != 0;
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x62, nullptr, u"dst != NULL") == 1))
        breakpoint();
    
    if (eax == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"dst != NULL", u"_stricmp", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x62, 0);
        return 0x7fffffff;
    }
    
    int32_t edx_1;
    edx_1 = arg2 != 0;
    
    if ((edx_1 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x63, nullptr, u"src != NULL") == 1))
        breakpoint();
    
    if (edx_1 != 0)
        return sub_10031e80(arg1, arg2);
    
    *sub_1000eca0() = 0x16;
    sub_1000c310(u"src != NULL", u"_stricmp", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x63, 0);
    return 0x7fffffff;
}

uint32_t sub_10032010(char* arg1, char* arg2, int32_t arg3, void** arg4)
{
    if (arg3 == 0)
        return 0;
    
    void var_1c;
    _LocaleUpdate::_LocaleUpdate(&var_1c, arg4);
    int32_t ecx_2;
    ecx_2 = arg1 != 0;
    
    if ((ecx_2 == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3b, nullptr, u"dst != NULL") == 1))
        breakpoint();
    
    if (ecx_2 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"dst != NULL", u"_strnicmp_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3b, 0);
        _LocaleUpdate::~_LocaleUpdate(&var_1c);
        return 0x7fffffff;
    }
    
    int32_t eax_4;
    eax_4 = arg2 != 0;
    int32_t var_24_1 = eax_4;
    
    if (var_24_1 == 0)
    {
        eax_4 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3c, nullptr, u"src != NULL");
        
        if (eax_4 == 1)
            breakpoint();
    }
    
    if (var_24_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"src != NULL", u"_strnicmp_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3c, 0);
        _LocaleUpdate::~_LocaleUpdate(&var_1c);
        return 0x7fffffff;
    }
    
    int32_t eax_6 = (eax_4 - eax_4);
    
    if ((eax_6 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3d, nullptr, u"count <= INT_MAX") == 1))
        breakpoint();
    
    if (eax_6 == 0xffffffff)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"count <= INT_MAX", u"_strnicmp_l", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x3d, 0);
        _LocaleUpdate::~_LocaleUpdate(&var_1c);
        return 0x7fffffff;
    }
    
    if (*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_1c) + 0x14) == 0)
    {
        uint32_t result = ___ascii_strnicmp(arg1, arg2, arg3);
        _LocaleUpdate::~_LocaleUpdate(&var_1c);
        return result;
    }
    
    uint32_t eax_14;
    uint32_t eax_19;
    
    do
    {
        eax_14 = sub_10032490(*arg1, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_1c));
        arg1 = &arg1[1];
        eax_19 = sub_10032490(*arg2, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_1c));
        arg2 = &arg2[1];
        bool cond:1_1 = arg3 == 1;
        arg3 -= 1;
        
        if (cond:1_1)
            break;
        
        if (eax_14 == 0)
            break;
    } while (eax_14 == eax_19);
    
    _LocaleUpdate::~_LocaleUpdate(&var_1c);
    return (eax_14 - eax_19);
}

uint32_t sub_10032250(char* arg1, char* arg2, int32_t arg3)
{
    if (data_10045ca8 != 0)
        return sub_10032010(arg1, arg2, arg3, nullptr);
    
    int32_t eax;
    eax = arg1 != 0;
    
    if ((eax == 0 && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x82, nullptr, u"dst != NULL") == 1))
        breakpoint();
    
    if (eax == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"dst != NULL", u"_strnicmp", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x82, 0);
        return 0x7fffffff;
    }
    
    int32_t edx_1;
    edx_1 = arg2 != 0;
    int32_t var_c_1 = edx_1;
    
    if (var_c_1 == 0)
    {
        int32_t eax_4;
        eax_4 = sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x83, nullptr, u"src != NULL");
        
        if (eax_4 == 1)
            breakpoint();
    }
    
    if (var_c_1 == 0)
    {
        *sub_1000eca0() = 0x16;
        sub_1000c310(u"src != NULL", u"_strnicmp", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x83, 0);
        return 0x7fffffff;
    }
    
    int32_t edx_2 = (edx_1 - edx_1);
    
    if ((edx_2 == 0xffffffff && sub_1000b040(2, u"f:\dd\vctools\crt_bld\self_x86\c…", 0x84, nullptr, u"count <= INT_MAX") == 1))
        breakpoint();
    
    if (edx_2 != 0xffffffff)
        return ___ascii_strnicmp(arg1, arg2, arg3);
    
    *sub_1000eca0() = 0x16;
    sub_1000c310(u"count <= INT_MAX", u"_strnicmp", u"f:\dd\vctools\crt_bld\self_x86\c…", 0x84, 0);
    return 0x7fffffff;
}

BOOL sub_100323e0(void** arg1, wchar16* arg2, int32_t arg3, uint16_t* arg4, int32_t arg5, int32_t arg6, int32_t arg7)
{
    void var_14;
    _LocaleUpdate::_LocaleUpdate(&var_14, arg1);
    int32_t var_1c_1 = arg7;
    int32_t var_20 = arg6;
    int32_t var_24 = arg5;
    BOOL result = sub_10032430(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_14), arg2, arg3, arg4);
    _LocaleUpdate::~_LocaleUpdate(&var_14);
    return result;
}

BOOL sub_10032430(uint32_t arg1, wchar16* arg2, int32_t arg3, uint16_t* arg4)
{
    if (arg3 >= 0xffffffff)
        return GetStringTypeW(arg1, arg2, arg3, arg4);
    
    return 0;
}

int32_t _ValidateRead(int32_t arg1) __pure
{
    int32_t ecx;
    int32_t var_8 = ecx;
    
    if (arg1 != 0)
        return 1;
    
    return 0;
}

uint32_t sub_10032490(uint32_t arg1, void** arg2)
{
    void var_20;
    _LocaleUpdate::_LocaleUpdate(&var_20, arg2);
    
    if (arg1 < 0x100)
    {
        int32_t eax_1 = _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_20);
        void* ecx_3;
        
        if (eax_1 != 0)
            ecx_3 = *_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_20);
        
        int32_t var_38_1;
        
        if ((eax_1 == 0 || *(ecx_3 + 0xac) <= 1))
            var_38_1 = sub_10024350(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_20), arg1, 1);
        else
            var_38_1 = sub_10024400(arg1, 1, _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_20));
        
        if (var_38_1 == 0)
        {
            _LocaleUpdate::~_LocaleUpdate(&var_20);
            return arg1;
        }
        
        uint32_t ecx_8 = *(*(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_20) + 0xcc) + arg1);
        _LocaleUpdate::~_LocaleUpdate(&var_20);
        return ecx_8;
    }
    
    void* eax_12 = *_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_20);
    int32_t eax_14;
    
    if (*(eax_12 + 0xac) > 1)
        eax_14 = sub_10027510((arg1 >> 8), _DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_20));
    
    PSTR var_10_1;
    char var_c;
    
    if ((*(eax_12 + 0xac) <= 1 || eax_14 == 0))
    {
        *sub_1000eca0() = 0x2a;
        var_c = arg1;
        char var_b_2 = 0;
        var_10_1 = 1;
    }
    else
    {
        var_c = (arg1 >> 8);
        eax_14 = arg1;
        char var_b_1 = eax_14;
        char var_a_1 = 0;
        var_10_1 = 2;
    }
    
    int32_t eax_17 = *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_20) + 4);
    uint32_t edx_9 = *(*_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_20) + 0x14);
    char var_8;
    int32_t eax_20 = sub_1002bcb0(_DebugMallocator<int32_t>::_DebugMallocator<int32_t>(&var_20), edx_9, 0x100, &var_c, var_10_1, &var_8, 3, eax_17, 1);
    
    if (eax_20 == 0)
    {
        _LocaleUpdate::~_LocaleUpdate(&var_20);
        return arg1;
    }
    
    if (eax_20 == 1)
    {
        uint32_t ecx_22 = var_8;
        _LocaleUpdate::~_LocaleUpdate(&var_20);
        return ecx_22;
    }
    
    char var_7;
    uint32_t edx_11 = (var_7 | (var_8 << 8));
    _LocaleUpdate::~_LocaleUpdate(&var_20);
    return edx_11;
}

void* sub_10032639(int32_t* arg1 @ ebp)
{
    void* result = _LocaleUpdate::~_LocaleUpdate(&arg1[-7]);
    *arg1;
    return result;
}

int32_t ___ascii_strnicmp(char* arg1, char* arg2, int32_t arg3)
{
    int32_t result = arg3;
    
    if (result != 0)
    {
        char* esi_1 = arg1;
        char* edi_1 = arg2;
        int32_t result_1 = result;
        
        while (true)
        {
            int16_t eax;
            *eax[1] = *esi_1;
            *eax[1] = *eax[1];
            bool cond:1_1 = *eax[1] == 0;
            eax = *edi_1;
            bool cond:0_1;
            
            if (cond:1_1)
            {
            label_100326bb:
                result = 0;
                cond:0_1 = *eax[1] < eax;
                
                if (*eax[1] == eax)
                    break;
            }
            else
            {
                eax = eax;
                
                if (eax == 0)
                    goto label_100326bb;
                
                esi_1 = &esi_1[1];
                edi_1 = &edi_1[1];
                
                if ((*eax[1] >= 0x41 && *eax[1] <= 0x5a))
                    *eax[1] += 0x20;
                
                if ((eax >= 0x41 && eax <= 0x5a))
                    eax += 0x20;
                
                cond:0_1 = *eax[1] < eax;
                
                if (*eax[1] == eax)
                {
                    int32_t result_2 = result_1;
                    result_1 -= 1;
                    
                    if (result_2 != 1)
                        continue;
                    
                    goto label_100326bb;
                }
            }
            
            result = 0xffffffff;
            
            if (!(cond:0_1))
                return 1;
            
            break;
        }
    }
    
    return result;
}

int32_t __stdcall __allmul(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4) __pure
{
    if ((arg4 | arg2) == 0)
    {
        int32_t eax_1;
        int32_t edx;
        edx = HIGHD((arg1 * arg3));
        eax_1 = LOWD((arg1 * arg3));
        return eax_1;
    }
    
    int32_t eax_6;
    int32_t edx_3;
    edx_3 = HIGHD((arg1 * arg3));
    eax_6 = LOWD((arg1 * arg3));
    return eax_6;
}

int32_t __fastcall sub_10032720(int32_t, int32_t arg2) __pure
{
    return (arg2 - 1);
}

void* sub_10032730(char* arg1, char arg2)
{
    int32_t eax;
    eax = arg2;
    char* edx = arg1;
    
    while ((edx & 3) != 0)
    {
        int32_t ecx;
        ecx = *edx;
        edx = &edx[1];
        
        if (ecx == eax)
            /* tailcall */
            return sub_10032720(ecx, edx);
        
        if (ecx == 0)
            return 0;
    }
    
    int32_t ebx_2 = (eax | (eax << 8));
    int32_t ebx_4 = ((ebx_2 << 0x10) | ebx_2);
    
    while (true)
    {
        int32_t ecx_1 = *edx;
        int32_t ecx_2 = (ecx_1 ^ ebx_4);
        edx = &edx[4];
        
        if ((((ecx_2 ^ 0xffffffff) ^ (0x7efefeff + ecx_2)) & 0x81010100) != 0)
        {
            int32_t eax_10 = *(edx - 4);
            
            if (eax_10 == ebx_4)
                return &edx[0xfffffffc];
            
            if (eax_10 == 0)
                break;
            
            if (*eax_10[1] == ebx_4)
                return &edx[0xfffffffd];
            
            if (*eax_10[1] == 0)
                break;
            
            uint16_t eax_11 = (eax_10 >> 0x10);
            
            if (eax_11 == ebx_4)
                return &edx[0xfffffffe];
            
            if (eax_11 == 0)
                break;
            
            if (*eax_11[1] == ebx_4)
                return &edx[0xffffffff];
            
            if (*eax_11[1] == 0)
                break;
        }
        else
        {
            int32_t eax_7 = (((ecx_1 ^ 0xffffffff) ^ (0x7efefeff + ecx_1)) & 0x81010100);
            
            if (eax_7 != 0)
            {
                if ((eax_7 & 0x1010100) != 0)
                    break;
                
                if (((0x7efefeff + ecx_1) & 0x80000000) == 0)
                    break;
            }
        }
    }
    
    return 0;
}

int32_t __fastcall std::_Init_locks::_Init_locks(int32_t arg1)
{
    if (InterlockedIncrement(0x10045090) == 0)
    {
        for (int32_t i = 0; i < 4; i += 1)
            __seterrormode(((i * 0x18) + 0x10046118));
    }
    
    return arg1;
}

int32_t std::_Init_locks::~_Init_locks()
{
    int32_t ecx;
    int32_t var_c = ecx;
    int32_t result = InterlockedDecrement(0x10045090);
    
    if (result < 0)
    {
        for (int32_t i = 0; i < 4; i = result)
        {
            ___crtIsValidLocaleName(((i * 0x18) + 0x10046118));
            result = (i + 1);
        }
    }
    
    return result;
}

int32_t* __thiscall sub_10032890(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    *arg1 = arg2;
    
    if (*arg1 < 4)
        ___crtSetUnhandledExceptionFilter(((*arg1 * 0x18) + 0x10046118));
    
    return arg1;
}

int32_t* __fastcall sub_100328d0(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    int32_t* result = arg1;
    
    if (*result >= 4)
        return result;
    
    return _sys_tss_get(((*arg1 * 0x18) + 0x10046118));
}

int32_t sub_10032900(int32_t arg1, PWSTR arg2, int32_t arg3)
{
    int32_t result = sub_1000b040(2, arg2, arg3, nullptr, arg1);
    
    if (result != 1)
        return result;
    
    breakpoint();
}

int32_t sub_10032930(int32_t arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    int32_t var_8_1 = 0;
    int32_t result = sub_1000cf10(arg1);
    
    if (result == 0)
        return result;
    
    return sub_10026f90();
}

int32_t* sub_10032960()
{
    void var_8;
    sub_10032890(&var_8, 0);
    
    while (data_1004617c != 0)
    {
        int32_t* eax_1 = data_1004617c;
        data_1004617c = *eax_1;
        sub_100337b0(eax_1);
    }
    
    return sub_100328d0(&var_8);
}

int32_t* sub_100329b0(int32_t arg1)
{
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = __ehhandler$??2@YAPAXIW4align_val_t@std@@ABUnothrow_t@1@@Z;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_ebp;
    int32_t var_24 = (__security_cookie ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    
    if (data_1004617c == 0)
        sub_10032930(sub_10032960);
    
    void* eax_3 = sub_10033b20(8, &data_100401e0, "f:\dd\vctools\crt_bld\self_x86\c…", 0x58);
    int32_t var_8_1 = 0;
    int32_t* result;
    
    if (eax_3 == 0)
        result = nullptr;
    else
        result = std::_Fac_node::_Fac_node(eax_3, data_1004617c, arg1);
    
    int32_t var_8_2 = 0xffffffff;
    data_1004617c = result;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t* __thiscall std::_Fac_node::_Fac_node(int32_t* arg1, int32_t arg2, int32_t arg3)
{
    int32_t* var_8 = arg1;
    *arg1 = arg2;
    arg1[1] = arg3;
    return arg1;
}

int32_t* sub_10032a90(int32_t* arg1)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    void* ecx_1 = *arg1;
    
    if (ecx_1 == 0)
        return arg1;
    
    return sub_10001620(sub_100015d0(ecx_1));
}

int32_t __CrtGetAllocHook()
{
    return data_10046180;
}

uint32_t std::locale::_Setgloballocale(int32_t arg1)
{
    uint32_t result = data_100461a4;
    
    if (result == 0)
    {
        data_100461a4 = 1;
        result = sub_10034510(_tidy_global);
    }
    
    data_10046180 = arg1;
    return result;
}

int32_t* __fastcall _tidy_global(int32_t arg1)
{
    int32_t var_8 = arg1;
    sub_10032890(&var_8, 0);
    sub_10032a90(&data_10046180);
    data_10046180 = 0;
    return sub_100328d0(&var_8);
}

int32_t* __thiscall sub_10032b40(int32_t* arg1, char arg2)
{
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = __ehhandler$??0system_error@std@@QAE@HABVerror_category@1@PBD@Z;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t* var_14 = arg1;
    int32_t __saved_ebp;
    int32_t var_18 = (__security_cookie ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    sub_10001650(arg1, 1);
    int32_t var_8_1 = 0;
    *arg1 = 0x1004013c;
    arg1[2] = 0;
    arg1[3] = 0;
    arg1[4] = 0;
    int32_t* edx;
    edx = arg2;
    arg1[5] = edx;
    std::_Iterator012<struct std::random_access_iterator_tag,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > >,int32_t,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > > const*,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > > const&,struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > >,int32_t,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > > const*,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > > const&,struct std::_Iterator_base12>(&arg1[6], &data_1003d070);
    int32_t var_8_2 = 0xffffffff;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg1;
}

wchar16* __thiscall std::_Iterator012<struct std::random_access_iterator_tag,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > >,int32_t,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > > const*,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > > const&,struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > >,int32_t,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > > const*,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > > const&,struct std::_Iterator_base12>(wchar16* arg1, wchar16* arg2)
{
    wchar16* var_8 = arg1;
    sub_10033020(arg1, arg2);
    return arg1;
}

int32_t* __thiscall <lambda_22c800ac295261976027df48869e3267>::<lambda_22c800ac295261976027df48869e3267>(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    *arg1 = arg2;
    return arg1;
}

int32_t* __thiscall sub_10032c20(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    sub_10032c50(arg1);
    
    if ((arg2 & 1) != 0)
        sub_10001620(arg1);
    
    return arg1;
}

int32_t* __fastcall sub_10032c50(int32_t* arg1)
{
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = __ehhandler$??1?$__crt_win32_buffer@DU__crt_win32_buffer_internal_dynamic_resizing@@@@QAE@XZ;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t* var_14 = arg1;
    int32_t __saved_ebp;
    int32_t var_18 = (__security_cookie ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    *arg1 = 0x1004013c;
    int32_t var_8_1 = 1;
    sub_10032e90(arg1);
    var_8_1 = 0;
    int32_t* result = __crt_stdio_output::output_processor<char,class __crt_stdio_output::string_output_adapter<char>,class __crt_stdio_output::format_validation_base<char,class __crt_stdio_output::string_output_adapter<char> > >::~output_processor<char,class __crt_stdio_output::string_output_adapter<char>,class __crt_stdio_output::format_validation_base<char,class __crt_stdio_output::string_output_adapter<char> > >(&arg1[6]);
    int32_t var_8_2 = 0xffffffff;
    sub_10001640(arg1);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t* __fastcall __crt_stdio_output::output_processor<char,class __crt_stdio_output::string_output_adapter<char>,class __crt_stdio_output::format_validation_base<char,class __crt_stdio_output::string_output_adapter<char> > >::~output_processor<char,class __crt_stdio_output::string_output_adapter<char>,class __crt_stdio_output::format_validation_base<char,class __crt_stdio_output::string_output_adapter<char> > >(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    return std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >(arg1);
}

int32_t* sub_10032cf0()
{
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = sub_1003472d;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_ebp;
    int32_t var_58 = (__security_cookie ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* result = __CrtGetAllocHook();
    
    if (result == 0)
    {
        void var_18;
        sub_10032890(&var_18, 0);
        int32_t var_8_1 = 0;
        result = __CrtGetAllocHook();
        
        if (result == 0)
        {
            void* eax_5 = j_sub_10033b20(0x38, &data_100401e0, "f:\dd\vctools\crt_bld\self_x86\c…", 0xd7);
            var_8_1 = 1;
            int32_t* result_1;
            
            if (eax_5 == 0)
                result_1 = nullptr;
            else
                result_1 = sub_10032b40(eax_5, 0);
            
            var_8_1 = 0;
            result = result_1;
            std::locale::_Setgloballocale(result);
            result[4] = 0x3f;
            void var_44;
            std::_Iterator012<struct std::random_access_iterator_tag,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > >,int32_t,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > > const*,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > > const&,struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > >,int32_t,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > > const*,class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<uint8_t,class Concurrency::details::_CancellationTokenState*> > > const&,struct std::_Iterator_base12>(&var_44, &data_1003bb60);
            var_8_1 = 2;
            std::_Iterator012<struct std::random_access_iterator_tag,uint16_t,int32_t,uint16_t const*,uint16_t const&,struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag,uint16_t,int32_t,uint16_t const*,uint16_t const&,struct std::_Iterator_base12>(&result[6], &var_44);
            var_8_1 = 0;
            __crt_stdio_output::output_processor<char,class __crt_stdio_output::string_output_adapter<char>,class __crt_stdio_output::format_validation_base<char,class __crt_stdio_output::string_output_adapter<char> > >::~output_processor<char,class __crt_stdio_output::string_output_adapter<char>,class __crt_stdio_output::format_validation_base<char,class __crt_stdio_output::string_output_adapter<char> > >(&var_44);
            data_10046184 = result;
            sub_100015a0(data_10046184);
            int32_t var_5c_3 = 0x1004619c;
            int32_t* eax_9 = Platform::Details::Heap::Allocate(4);
            var_8_1 = 3;
            int32_t* var_54_1;
            
            if (eax_9 == 0)
                var_54_1 = nullptr;
            else
                var_54_1 = <lambda_22c800ac295261976027df48869e3267>::<lambda_22c800ac295261976027df48869e3267>(eax_9, data_10046184);
            
            int32_t* var_48_1 = var_54_1;
        }
        
        int32_t var_8_2 = 0xffffffff;
        sub_100328d0(&var_18);
    }
    
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_10032e60() __pure
{
    return;
}

void* __thiscall std::_Iterator012<struct std::random_access_iterator_tag,uint16_t,int32_t,uint16_t const*,uint16_t const&,struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag,uint16_t,int32_t,uint16_t const*,uint16_t const&,struct std::_Iterator_base12>(void* arg1, void* arg2)
{
    void* var_8 = arg1;
    sub_10033100(arg1, arg2);
    return arg1;
}

int32_t* sub_10032e90(void* arg1)
{
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = sub_10034758;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_ebp;
    int32_t var_1c = (__security_cookie ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void var_14;
    sub_10032890(&var_14, 0);
    int32_t var_8_1 = 0;
    int32_t i = *(arg1 + 0xc);
    
    while (i > 0)
    {
        i -= 1;
        
        if (*(*(arg1 + 8) + (i << 2)) != 0)
            sub_10001620(sub_100015d0(*(*(arg1 + 8) + (i << 2))));
    }
    
    __mktime32(*(arg1 + 8));
    int32_t var_8_2 = 0xffffffff;
    int32_t* result = sub_100328d0(&var_14);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

void* sub_10032f40(void* arg1, void* arg2)
{
    void* var_8 = sub_10005830(arg2);
    int128_t* eax_1 = sub_10022e20(0, nullptr);
    int128_t* var_10;
    
    if (eax_1 != 0)
        var_10 = eax_1;
    else
        var_10 = &data_10040802;
    
    sub_10033000((arg1 + 0x44), var_10);
    
    if (var_8 != 0)
        var_8 = sub_10022e20(0, var_8);
    
    void* var_14;
    
    if (var_8 != 0)
        var_14 = var_8;
    else
        var_14 = &data_1003d070;
    
    return sub_10033000((arg1 + 0x64), var_14);
}

int32_t sub_10032fd0(void* arg1)
{
    int32_t result = sub_10005840((arg1 + 0x44));
    
    if (result <= 0)
        return result;
    
    return sub_10022e20(0, sub_10005830((arg1 + 0x44)));
}

void* __thiscall sub_10033000(void* arg1, int128_t* arg2)
{
    void* var_8 = arg1;
    return sub_10006e80(arg1, arg2);
}

int32_t* __thiscall sub_10033020(wchar16* arg1, wchar16* arg2)
{
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = sub_10034788;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t __saved_ebp;
    int32_t var_1c = (__security_cookie ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* result = arg1;
    wchar16* var_20 = arg1;
    int32_t* var_14 = &var_20;
    sub_100332f0(result);
    int32_t var_8_1 = 0;
    var_20 = nullptr;
    sub_10033270(result, 0, var_20);
    var_20 = arg2;
    sub_10033230(result, var_20);
    int32_t var_8_2 = 0xffffffff;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t* __fastcall std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >(int32_t* arg1)
{
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = __ehhandler$??1?$__crt_win32_buffer@DU__crt_win32_buffer_no_resizing@@@@QAE@XZ;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t* var_14 = arg1;
    int32_t __saved_ebp;
    int32_t var_18 = (__security_cookie ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t var_8_1 = 0;
    sub_10033270(arg1, 1, nullptr);
    int32_t var_8_2 = 0xffffffff;
    int32_t* result = __crt_stdio_output::output_processor<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t>,class __crt_stdio_output::standard_base<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t> > >::~output_processor<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t>,class __crt_stdio_output::standard_base<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t> > >(arg1);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

void* __thiscall sub_10033100(void* arg1, void* arg2)
{
    void* var_8 = arg1;
    return sub_10033140(arg1, arg2);
}

int32_t* __fastcall __crt_stdio_output::output_processor<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t>,class __crt_stdio_output::standard_base<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t> > >::~output_processor<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t>,class __crt_stdio_output::standard_base<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t> > >(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    return j_sub_10001290(arg1);
}

void* __thiscall sub_10033140(void* arg1, void* arg2)
{
    void* var_8 = arg1;
    return sub_10033170(arg1, arg2, nullptr, 0xffffffff);
}

void* __thiscall sub_10033170(void* arg1, void* arg2, void* arg3, void* arg4)
{
    if (Concurrency::details::ThreadProxy::GetPriority(arg2) < arg3)
    {
        sub_100341f0();
        /* no return */
    }
    
    void* var_8 = (Concurrency::details::ThreadProxy::GetPriority(arg2) - arg3);
    
    if (arg4 < var_8)
        var_8 = arg4;
    
    if (arg1 != arg2)
    {
        if (sub_100334d0(arg1, var_8, 0) != 0)
        {
            void* eax_7 = (sub_10005830(arg2) + arg3);
            sub_100337e0(sub_10033570(arg1), *(arg1 + 0x1c), eax_7, var_8);
            sub_10033490(arg1, var_8);
        }
    }
    else
    {
        sub_100333d0(arg1, (arg3 + var_8), 0xffffffff);
        sub_100333d0(arg1, 0, arg3);
    }
    
    return arg1;
}

void* __thiscall sub_10033230(void* arg1, wchar16* arg2)
{
    void* var_8 = arg1;
    int32_t var_c = 0x446;
    wchar16 const* const var_10 = u"f:\dd\vctools\crt_bld\self_x86\c…";
    sub_10008150(arg2);
    return sub_10033320(arg1, arg2, sub_10001140(arg2));
}

char* __thiscall sub_10033270(void* arg1, char arg2, void* arg3)
{
    if ((arg2 != 0 && *(arg1 + 0x1c) >= 0x10))
    {
        int128_t* eax_1 = *(arg1 + 8);
        
        if (arg3 > 0)
            sub_100337e0((arg1 + 8), 0x10, eax_1, arg3);
        
        int32_t var_10_2 = (*(arg1 + 0x1c) + 1);
        sub_100058c0(eax_1);
    }
    
    *(arg1 + 0x1c) = 0xf;
    return sub_10033490(arg1, arg3);
}

int32_t* __fastcall sub_100332f0(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    sub_100076f0(arg1);
    void* var_c = &arg_4;
    return arg1;
}

void* __thiscall sub_10033320(void* arg1, wchar16* arg2, void* arg3)
{
    void* var_8 = arg1;
    
    if (arg3 != 0)
    {
        int32_t var_c_1 = 0x436;
        wchar16 const* const var_10_1 = u"f:\dd\vctools\crt_bld\self_x86\c…";
        sub_10008150(arg2);
    }
    
    if (std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >::_Inside(arg1, arg2) != 0)
        return sub_10033170(arg1, arg1, (arg2 - sub_10033570(arg1)), arg3);
    
    if (sub_100334d0(arg1, arg3, 0) != 0)
    {
        sub_100337e0(sub_10033570(arg1), *(arg1 + 0x1c), arg2, arg3);
        sub_10033490(arg1, arg3);
    }
    
    return arg1;
}

void* __thiscall sub_100333d0(void* arg1, int32_t arg2, int32_t arg3)
{
    if (*(arg1 + 0x18) < arg2)
    {
        sub_100341f0();
        /* no return */
    }
    
    if ((*(arg1 + 0x18) - arg2) < arg3)
        arg3 = (*(arg1 + 0x18) - arg2);
    
    if (arg3 > 0)
    {
        void* ecx_4 = ((*(arg1 + 0x18) - arg2) - arg3);
        void* eax_6 = ((sub_10033570(arg1) + arg2) + arg3);
        sub_10033810((sub_10033570(arg1) + arg2), (*(arg1 + 0x1c) - arg2), eax_6, ecx_4);
        sub_10033490(arg1, (*(arg1 + 0x18) - arg3));
    }
    
    return arg1;
}

int32_t __fastcall Concurrency::details::ThreadProxy::GetPriority(void* arg1)
{
    void* var_8 = arg1;
    return *(arg1 + 0x18);
}

char* __thiscall sub_10033490(void* arg1, int32_t arg2)
{
    char var_5 = 0;
    *(arg1 + 0x18) = arg2;
    return sub_10001130((sub_10033570(arg1) + arg2), &var_5);
}

int32_t __thiscall sub_100334d0(void* arg1, void* arg2, char arg3)
{
    if (sub_100335a0(arg1) < arg2)
    {
        sub_10033f50();
        /* no return */
    }
    
    if (*(arg1 + 0x1c) < arg2)
        sub_100335e0(arg1, arg2, *(arg1 + 0x18));
    else if ((arg3 != 0 && arg2 < 0x10))
    {
        void* var_c_1;
        
        if (arg2 >= *(arg1 + 0x18))
            var_c_1 = *(arg1 + 0x18);
        else
            var_c_1 = arg2;
        
        sub_10033270(arg1, 1, var_c_1);
    }
    else if (arg2 == 0)
        sub_10033490(arg1, 0);
    
    return -((0 - 0));
}

void* __fastcall sub_10033570(void* arg1)
{
    if (*(arg1 + 0x1c) < 0x10)
        return (arg1 + 8);
    
    return *(arg1 + 8);
}

int32_t __fastcall sub_100335a0(int32_t arg1)
{
    return 0xfffffffe;
}

char* __thiscall sub_100335e0(void* arg1, int32_t arg2, void* arg3)
{
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = sub_100347e0;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    void* var_14 = arg1;
    int32_t edi;
    int32_t var_34 = edi;
    int32_t __saved_ebp;
    int32_t var_38 = (__security_cookie ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    int32_t* var_14_1 = &var_38;
    int32_t var_1c = (arg2 | 0xf);
    
    if (sub_100335a0(arg1) < var_1c)
        var_1c = arg2;
    else if ((COMBINE(0, var_1c) / 3) < (*(arg1 + 0x1c) >> 1))
    {
        int32_t eax_9 = (sub_100335a0(arg1) - (*(arg1 + 0x1c) >> 1));
        
        if (*(arg1 + 0x1c) <= eax_9)
            var_1c = ((*(arg1 + 0x1c) >> 1) + *(arg1 + 0x1c));
    }
    
    int32_t var_18 = 0;
    int32_t var_8_1 = 0;
    void* eax_13 = sub_10005850((var_1c + 1));
    int32_t var_8_2 = 0xffffffff;
    
    if (arg3 > 0)
        sub_100337e0(eax_13, (var_1c + 1), sub_10033570(arg1), arg3);
    
    sub_10033270(arg1, 1, nullptr);
    *(arg1 + 8) = eax_13;
    *(arg1 + 0x1c) = var_1c;
    char* result = sub_10033490(arg1, arg3);
    fsbase->NtTib.ExceptionList = ExceptionList;
    return result;
}

int32_t sub_1003369d(void* arg1 @ ebp)
{
    *(arg1 - 0x10) = &__return_addr;
    *(arg1 - 0x18) = *(arg1 + 8);
    *(arg1 - 4) = 2;
    *(arg1 - 0x1c);
    *(arg1 - 0x24) = sub_10005850((*(arg1 - 0x18) + 1));
    *(arg1 - 0x14) = *(arg1 - 0x24);
    *(arg1 - 4) = 1;
    *(arg1 - 4) = 1;
    return 0x10033704;
}

void sub_100336c7(void* arg1 @ ebp) __noreturn
{
    sub_10033270(*(arg1 - 0x1c), 1, nullptr);
    sub_1000ed00(0, nullptr);
    /* no return */
}

void* __thiscall std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >::_Inside(void* arg1, int32_t arg2)
{
    void* var_8 = arg1;
    void* result;
    
    if (arg2 == 0)
        result = 0;
    else if (arg2 < sub_10033570(arg1))
        result = 0;
    else if ((sub_10033570(arg1) + *(arg1 + 0x18)) > arg2)
        result = 1;
    else
        result = 0;
    
    return result;
}

void sub_100337b0(void* arg1)
{
    if (arg1 != 0)
    {
        sub_10033840(arg1, 0);
        __mktime32(arg1);
    }
}

char* sub_100337e0(char* arg1, int32_t arg2, int128_t* arg3, void* arg4)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    *var_8[3] = std::_Ptr_cat<wchar_t*,class std::ostreambuf_iterator<wchar_t,struct std::char_traits<wchar_t> > >(ecx);
    uint32_t var_c = *var_8[3];
    return _mbsrtowcs(arg1, arg2, arg3, arg4);
}

int128_t* sub_10033810(int128_t* arg1, int32_t arg2, int128_t* arg3, void* arg4)
{
    int32_t ecx;
    int32_t var_8 = ecx;
    *var_8[3] = std::_Ptr_cat<wchar_t*,class std::ostreambuf_iterator<wchar_t,struct std::char_traits<wchar_t> > >(ecx);
    uint32_t var_c = *var_8[3];
    return _wcsrtombs(arg1, arg2, arg3, arg4);
}

void* __thiscall sub_10033840(void* arg1, int32_t arg2)
{
    void* var_8 = arg1;
    sub_10033870(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80(arg1);
    
    return arg1;
}

int32_t __fastcall sub_10033870(void* arg1)
{
    void* var_8 = arg1;
    return sub_10001620(sub_100015d0(*(arg1 + 4)));
}

int32_t __fastcall std::_Ptr_cat<wchar_t*,class std::ostreambuf_iterator<wchar_t,struct std::char_traits<wchar_t> > >(int32_t arg1) __pure
{
    int32_t result;
    result = *arg1[3];
    return result;
}

char* _mbsrtowcs(char* arg1, int32_t arg2, int128_t* arg3, void* arg4)
{
    return sub_10001160(arg1, arg2, arg3, arg4);
}

int128_t* _wcsrtombs(int128_t* arg1, int32_t arg2, int128_t* arg3, void* arg4)
{
    return sub_10001190(arg1, arg2, arg3, arg4);
}

int32_t __fastcall ??$?0H@?$_DebugMallocator@V?$_Ref_count_del_alloc@V__ExceptionPtr@@P6AXPAV1@@ZV?$_DebugMallocator@H@@@std@@@@QAE@ABV?$_DebugMallocator@H@@@Z(int32_t arg1) __pure
{
    int32_t var_8 = arg1;
    return arg1;
}

uint32_t sub_10033910(uint32_t arg1, uint32_t* arg2)
{
    uint32_t var_18;
    int32_t var_10;
    
    if (arg2 != 0)
    {
        var_18 = *arg2;
        var_10 = arg2[1];
    }
    else
    {
        var_18 = *(sub_1002df50() + 8);
        var_10 = sub_1002df00();
    }
    
    if (var_18 == 0)
    {
        if ((arg1 >= 0x41 && arg1 <= 0x5a))
            return (arg1 + 0x20);
        
        return arg1;
    }
    
    if (arg1 < 0x100)
    {
        if (arg2 == 0)
        {
            if (_isupper(arg1) == 0)
                return arg1;
        }
        else if ((*(arg2[2] + (arg1 << 1)) & 1) == 0)
            return arg1;
    }
    
    int32_t var_1c_1;
    
    if (arg2 != 0)
    {
        int32_t eax_13 = (*(arg2[2] + ((arg1 >> 8) << 1)) & 0x8000);
        int32_t eax_14 = -(eax_13);
        var_1c_1 = -((eax_14 - eax_14));
    }
    else
        var_1c_1 = (*(sub_1002c590() + ((arg1 >> 8) << 1)) & 0x8000);
    
    PSTR var_14_1;
    char var_c;
    
    if (var_1c_1 == 0)
    {
        int32_t eax_8;
        eax_8 = arg1;
        var_c = eax_8;
        char var_b_2 = 0;
        var_14_1 = 1;
    }
    else
    {
        var_c = (arg1 >> 8);
        int32_t edx_9;
        edx_9 = arg1;
        char var_b_1 = edx_9;
        char var_a_1 = 0;
        var_14_1 = 2;
    }
    
    char var_8;
    int32_t eax_17 = sub_1002bcb0(nullptr, var_18, 0x100, &var_c, var_14_1, &var_8, 3, var_10, 1);
    
    if (eax_17 == 0)
        return arg1;
    
    char var_7;
    
    if (eax_17 != 1)
        return (var_7 | (var_8 << 8));
    return var_8;
}

int32_t* sub_10033a90(int32_t* arg1)
{
    int32_t eax_1 = *(sub_1002df50() + 4);
    int32_t eax_2 = sub_1002df00();
    void* var_c = sub_10010b10(0x100, 2, 2, "f:\dd\vctools\crt_bld\self_x86\c…", 0x90);
    int32_t var_8;
    
    if (var_c == 0)
    {
        var_c = sub_1002c590();
        var_8 = 0;
    }
    else
    {
        sub_10013c90(var_c, sub_1002c590(), 0x200, eax_1, eax_2, var_c);
        var_8 = 1;
    }
    
    *arg1 = eax_1;
    arg1[1] = eax_2;
    arg1[2] = var_c;
    arg1[3] = var_8;
    return arg1;
}

void* sub_10033b20(int32_t arg1, int32_t* arg2, int32_t arg3, int32_t arg4)
{
    void* result = __malloc_dbg(arg1, *arg2, arg3, arg4);
    
    if (result != 0)
        return result;
    
    if ((data_100461b4 & 1) == 0)
    {
        data_100461b4 |= 1;
        sub_1000e7a0(&data_100461a8);
        sub_1000cf10(sub_10035610);
    }
    
    void var_14;
    sub_10006a00(&var_14, &data_100461a8);
    sub_1000ed00(&var_14, &data_10042750);
    /* no return */
}

void* __wcstoi64_l(int32_t arg1, int32_t* arg2, int32_t arg3, int32_t arg4)
{
    return sub_10033b20(arg1, arg2, arg3, arg4);
}

int32_t __crt_char_traits<char const (&)[0x2],int32_t,char>::taccess_s<char const (&)[0x2],int32_t>(int32_t arg1, int32_t* arg2)
{
    return sub_10011340(arg1, *arg2);
}

int32_t ___p___wargv() __pure
{
    return 0x100401e0;
}

uint32_t sub_10033bf0(uint32_t arg1, uint32_t* arg2)
{
    uint32_t var_18;
    int32_t var_10;
    
    if (arg2 != 0)
    {
        var_18 = *arg2;
        var_10 = arg2[1];
    }
    else
    {
        var_18 = *(sub_1002df50() + 8);
        var_10 = sub_1002df00();
    }
    
    if (var_18 == 0)
    {
        if ((arg1 >= 0x61 && arg1 <= 0x7a))
            return (arg1 - 0x20);
        
        return arg1;
    }
    
    if (arg1 < 0x100)
    {
        if (arg2 == 0)
        {
            if (_islower(arg1) == 0)
                return arg1;
        }
        else if ((*(arg2[2] + (arg1 << 1)) & 2) == 0)
            return arg1;
    }
    
    int32_t var_1c_1;
    
    if (arg2 != 0)
    {
        int32_t eax_13 = (*(arg2[2] + ((arg1 >> 8) << 1)) & 0x8000);
        int32_t eax_14 = -(eax_13);
        var_1c_1 = -((eax_14 - eax_14));
    }
    else
        var_1c_1 = (*(sub_1002c590() + ((arg1 >> 8) << 1)) & 0x8000);
    
    PSTR var_14_1;
    char var_c;
    
    if (var_1c_1 == 0)
    {
        int32_t eax_8;
        eax_8 = arg1;
        var_c = eax_8;
        char var_b_2 = 0;
        var_14_1 = 1;
    }
    else
    {
        var_c = (arg1 >> 8);
        int32_t edx_9;
        edx_9 = arg1;
        char var_b_1 = edx_9;
        char var_a_1 = 0;
        var_14_1 = 2;
    }
    
    char var_8;
    int32_t eax_17 = sub_1002bcb0(nullptr, var_18, 0x200, &var_c, var_14_1, &var_8, 3, var_10, 1);
    
    if (eax_17 == 0)
        return arg1;
    
    char var_7;
    
    if (eax_17 != 1)
        return (var_7 | (var_8 << 8));
    return var_8;
}

int32_t* sub_10033d70(int32_t* arg1)
{
    if (arg1[1] > 0)
    {
        int32_t* eax;
        eax = *(arg1[1] + 0x100461ec);
        eax -= 1;
        *(arg1[1] + 0x100461ec) = eax;
        
        if (*(arg1[1] + 0x100461ec) > 0)
            return arg1;
    }
    
    sub_10033dd0(arg1);
    return sub_100082c0(arg1[9]);
}

int32_t* sub_10033dd0(int32_t* arg1)
{
    sub_10033e60(arg1, 0);
    int32_t* i_2;
    
    for (int32_t* i = arg1[7]; i != 0; i = i_2)
    {
        i_2 = *i;
        sub_10033f30(i);
    }
    
    int32_t* result = arg1;
    result[7] = 0;
    
    for (int32_t* i_1 = arg1[8]; i_1 != 0; i_1 = result)
    {
        int32_t* result_1 = *i_1;
        sub_10033f30(i_1);
        result = result_1;
    }
    
    arg1[8] = 0;
    return result;
}

void** __thiscall sub_10033e60(void** arg1, int32_t arg2)
{
    void** result = arg1;
    
    for (void** i = result[8]; i != 0; i = result)
    {
        i[2](arg2, arg1, i[1], arg1, i);
        result = *i;
    }
    
    return result;
}

void** __fastcall sub_10033eb0(void** arg1)
{
    *arg1 = sub_10033b20(0x18, &data_100401e0, "f:\dd\vctools\crt_bld\self_x86\c…", 0xb);
    __seterrormode(*arg1);
    return arg1;
}

int32_t __fastcall sub_10033f00(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    ___crtIsValidLocaleName(*arg1);
    return sub_10033f30(*arg1);
}

void sub_10033f30(int32_t arg1)
{
    if (arg1 != 0)
        __mktime32(arg1);
}

void sub_10033f50() __noreturn
{
    int32_t ebp;
    int32_t var_4 = ebp;
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = sub_10034808;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t var_60 = (__security_cookie ^ &var_4);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void var_5c;
    sub_100056f0(&var_5c, "string too long");
    int32_t var_8_1 = 0;
    void var_3c;
    sub_10033fd0(&var_3c, &var_5c);
    sub_1000ed00(&var_3c, &data_10042594);
    /* no return */
}

int32_t* __thiscall sub_10033fd0(int32_t* arg1, int32_t* arg2)
{
    int32_t* var_8 = arg1;
    sub_10034000(arg1, arg2);
    *arg1 = 0x10040230;
    return arg1;
}

int32_t* __thiscall sub_10034000(int32_t* arg1, int32_t* arg2)
{
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = sub_10034838;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t* var_14 = arg1;
    int32_t __saved_ebp;
    int32_t var_18 = (__security_cookie ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    Concurrency::details::_MallocaArrayHolder<class Concurrency::event*>::_MallocaArrayHolder<class Concurrency::event*>(arg1);
    int32_t var_8_1 = 0;
    *arg1 = 0x1004023c;
    sub_10005790(&arg1[3], arg2);
    int32_t var_8_2 = 0xffffffff;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg1;
}

void* __fastcall sub_10034070(void* arg1)
{
    void* var_8 = arg1;
    return sub_10005830((arg1 + 0xc));
}

int32_t* __thiscall sub_10034090(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    sub_100340c0(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80(arg1);
    
    return arg1;
}

int32_t* __fastcall sub_100340c0(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    *arg1 = 0x1004023c;
    sub_10005800(&arg1[3]);
    return sub_1000c1f0(arg1);
}

int32_t* __fastcall sub_100340f0(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    *arg1 = 0x10040230;
    return sub_100340c0(arg1);
}

int32_t* __thiscall sub_10034110(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    sub_100340f0(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80(arg1);
    
    return arg1;
}

int32_t* __thiscall sub_10034140(int32_t* arg1, void* arg2)
{
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = sub_10034838;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t* var_14 = arg1;
    int32_t __saved_ebp;
    int32_t var_18 = (__security_cookie ^ &__saved_ebp);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    sub_1000c150(arg1, arg2);
    int32_t var_8_1 = 0;
    *arg1 = 0x1004023c;
    sub_10005790(&arg1[3], (arg2 + 0xc));
    int32_t var_8_2 = 0xffffffff;
    fsbase->NtTib.ExceptionList = ExceptionList;
    return arg1;
}

int32_t* __thiscall sub_100341c0(int32_t* arg1, void* arg2)
{
    int32_t* var_8 = arg1;
    sub_10034140(arg1, arg2);
    *arg1 = 0x10040230;
    return arg1;
}

void sub_100341f0() __noreturn
{
    int32_t ebp;
    int32_t var_4 = ebp;
    int32_t var_8 = 0xffffffff;
    int32_t (* var_c)(void* arg1) = sub_10034808;
    TEB* fsbase;
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
    int32_t var_60 = (__security_cookie ^ &var_4);
    fsbase->NtTib.ExceptionList = &ExceptionList;
    void var_5c;
    sub_100056f0(&var_5c, "invalid string position");
    int32_t var_8_1 = 0;
    void var_3c;
    sub_10034270(&var_3c, &var_5c);
    sub_1000ed00(&var_3c, &data_10042644);
    /* no return */
}

int32_t* __thiscall sub_10034270(int32_t* arg1, int32_t* arg2)
{
    int32_t* var_8 = arg1;
    sub_10034000(arg1, arg2);
    *arg1 = 0x10040260;
    return arg1;
}

int32_t* __fastcall sub_100342a0(int32_t* arg1)
{
    int32_t* var_8 = arg1;
    *arg1 = 0x10040260;
    return sub_100340c0(arg1);
}

int32_t* __thiscall sub_100342c0(int32_t* arg1, int32_t arg2)
{
    int32_t* var_8 = arg1;
    sub_100342a0(arg1);
    
    if ((arg2 & 1) != 0)
        sub_1000ab80(arg1);
    
    return arg1;
}

int32_t* __thiscall sub_100342f0(int32_t* arg1, void* arg2)
{
    int32_t* var_8 = arg1;
    sub_10034140(arg1, arg2);
    *arg1 = 0x10040260;
    return arg1;
}

int32_t* __wcstof_l(int16_t* arg1, int16_t* arg2, int32_t arg3)
{
    return sub_1000cf90(arg1, arg2, arg3);
}

int32_t* sub_10034340(int16_t* arg1, int32_t arg2, int32_t arg3)
{
    int32_t* var_10 = nullptr;
    int32_t eax_1 = (arg2 & 4);
    int32_t ecx_1 = (arg2 & 0x80);
    
    if ((arg2 & 0x40) != 0)
        arg2 |= 1;
    
    if ((arg2 & 8) != 0)
        arg2 |= 2;
    
    int32_t eax_5 = (arg2 & 0xffffff3b);
    int32_t var_c = 0;
    
    while (*((var_c << 2) + &data_1004026c) != 0)
    {
        if (*((var_c << 2) + &data_1004026c) == eax_5)
            break;
        
        var_c += 1;
    }
    
    if (*((var_c << 2) + &data_1004026c) == 0)
        return nullptr;
    
    if ((ecx_1 != 0 && (eax_5 & 1) != 0))
    {
        var_10 = __wcstof_l(arg1, &data_10040268, arg3);
        
        if (var_10 != 0)
        {
            sub_1000d900(var_10);
            return nullptr;
        }
    }
    
    if ((var_10 != 0 && sub_1000d900(var_10) != 0))
        return nullptr;
    
    int32_t* result = __wcstof_l(arg1, &data_10045138[var_c], arg3);
    
    if (result == 0)
        return nullptr;
    
    if ((eax_1 != 0 && sub_1000e000(result, 0, FILE_END) != 0))
    {
        sub_1000d900(result);
        return nullptr;
    }
    
    return result;
}

int32_t __seterrormode(CRITICAL_SECTION* arg1)
{
    return InitializeCriticalSection(arg1);
}

int32_t ___crtIsValidLocaleName(CRITICAL_SECTION* arg1)
{
    return DeleteCriticalSection(arg1);
}

int32_t ___crtSetUnhandledExceptionFilter(CRITICAL_SECTION* arg1)
{
    return EnterCriticalSection(arg1);
}

int32_t _sys_tss_get(CRITICAL_SECTION* arg1)
{
    return LeaveCriticalSection(arg1);
}

int32_t sub_10034510(int32_t arg1)
{
    if (data_1004517c == 0)
        return sub_10026f90();
    
    int32_t result = (data_1004517c - 1);
    data_1004517c = result;
    *((data_1004517c << 2) + &data_10046218) = arg1;
    return result;
}

void __fastcall sub_10034550(int32_t arg1)
{
    int32_t var_8 = arg1;
    
    while (data_1004517c < 0xa)
    {
        int32_t ecx = *((data_1004517c << 2) + &data_10046218);
        data_1004517c += 1;
        
        if (ecx != 0)
            *((data_1004517c << 2) + &data_10046214)(arg1);
    }
}

void __stdcall RtlUnwind(void* TargetFrame, void* TargetIp, EXCEPTION_RECORD* ExceptionRecord, void* ReturnValue)
{
    /* tailcall */
    return RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);
}

int32_t sub_100345a0(void* arg1 @ ebp)
{
    /* tailcall */
    return _LocaleUpdate::~_LocaleUpdate((arg1 - 0x20));
}

int32_t sub_100345a8(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x28) ^ (arg1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_1004205c);
}

int32_t sub_100345d0(void* arg1 @ ebp)
{
    /* tailcall */
    return _LocaleUpdate::~_LocaleUpdate((arg1 - 0x1c));
}

int32_t __ehhandler$___std_fs_get_file_id@8(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x20) ^ (arg1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_10042204);
}

int32_t sub_10034600(void* arg1 @ ebp)
{
    /* tailcall */
    return _LocaleUpdate::~_LocaleUpdate((arg1 - 0x2c));
}

int32_t sub_10034608(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x4c) ^ (arg1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_10042230);
}

int32_t __ehhandler$??_U@YAPAXIW4align_val_t@std@@ABUnothrow_t@1@@Z(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x14) ^ (arg1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_10042390);
}

int32_t sub_10034650(void* arg1 @ ebp)
{
    int32_t var_4 = 0x58;
    char const* const var_8 = "f:\dd\vctools\crt_bld\self_x86\c…";
    return __crt_char_traits<char const (&)[0x2],int32_t,char>::taccess_s<char const (&)[0x2],int32_t>(*(arg1 - 0x14), *(arg1 - 0x18));
}

int32_t __ehhandler$??2@YAPAXIW4align_val_t@std@@ABUnothrow_t@1@@Z(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x14) ^ (arg1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_100423bc);
}

int32_t sub_10034690(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10001640(*(arg1 - 0x10));
}

int32_t __ehhandler$??0system_error@std@@QAE@HABVerror_category@1@PBD@Z(void* arg1)
{
    sub_1000ac70((*(arg1 - 8) ^ (arg1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_100423e8);
}

int32_t sub_100346c0(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10001640(*(arg1 - 0x10));
}

int32_t sub_100346c8(void* arg1 @ ebp)
{
    /* tailcall */
    return __crt_stdio_output::output_processor<char,class __crt_stdio_output::string_output_adapter<char>,class __crt_stdio_output::format_validation_base<char,class __crt_stdio_output::string_output_adapter<char> > >::~output_processor<char,class __crt_stdio_output::string_output_adapter<char>,class __crt_stdio_output::format_validation_base<char,class __crt_stdio_output::string_output_adapter<char> > >((*(arg1 - 0x10) + 0x18));
}

int32_t __ehhandler$??1?$__crt_win32_buffer@DU__crt_win32_buffer_internal_dynamic_resizing@@@@QAE@XZ(void* arg1)
{
    sub_1000ac70((*(arg1 - 8) ^ (arg1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_1004241c);
}

int32_t sub_100346f0(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0((arg1 - 0x14));
}

int32_t sub_100346f8(void* arg1 @ ebp)
{
    int32_t var_4 = 0xd7;
    char const* const var_8 = "f:\dd\vctools\crt_bld\self_x86\c…";
    int32_t var_c = *(arg1 - 0x20);
    return sub_10001620(*(arg1 - 0x1c));
}

int32_t sub_10034713(void* arg1 @ ebp)
{
    /* tailcall */
    return __crt_stdio_output::output_processor<char,class __crt_stdio_output::string_output_adapter<char>,class __crt_stdio_output::format_validation_base<char,class __crt_stdio_output::string_output_adapter<char> > >::~output_processor<char,class __crt_stdio_output::string_output_adapter<char>,class __crt_stdio_output::format_validation_base<char,class __crt_stdio_output::string_output_adapter<char> > >((arg1 - 0x40));
}

int32_t sub_1003471b(void* arg1 @ ebp)
{
    int32_t var_4 = 0x1004619c;
    int32_t result = *(arg1 - 0x48);
    int32_t result_1 = result;
    return result;
}

int32_t sub_1003472d(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x48) ^ (arg1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_10042460);
}

int32_t sub_10034750(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0((arg1 - 0x10));
}

int32_t sub_10034758(void* arg1)
{
    sub_1000ac70((*(arg1 - 0xc) ^ (arg1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_1004248c);
}

int32_t sub_10034780(void* arg1 @ ebp)
{
    /* tailcall */
    return __crt_stdio_output::output_processor<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t>,class __crt_stdio_output::standard_base<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t> > >::~output_processor<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t>,class __crt_stdio_output::standard_base<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t> > >(*(arg1 - 0x14));
}

int32_t sub_10034788(void* arg1)
{
    sub_1000ac70((*(arg1 - 0xc) ^ (arg1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_100424b8);
}

int32_t sub_100347b0(void* arg1 @ ebp)
{
    /* tailcall */
    return __crt_stdio_output::output_processor<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t>,class __crt_stdio_output::standard_base<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t> > >::~output_processor<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t>,class __crt_stdio_output::standard_base<wchar_t,class __crt_stdio_output::string_output_adapter<wchar_t> > >(*(arg1 - 0x10));
}

int32_t __ehhandler$??1?$__crt_win32_buffer@DU__crt_win32_buffer_no_resizing@@@@QAE@XZ(void* arg1)
{
    sub_1000ac70((*(arg1 - 8) ^ (arg1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_100424e4);
}

int32_t sub_100347e0(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x28) ^ (arg1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_10042548);
}

int32_t sub_10034800(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((arg1 - 0x58));
}

int32_t sub_10034808(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x50) ^ (arg1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_100425ac);
}

int32_t sub_10034830(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_1000c1f0(*(arg1 - 0x10));
}

int32_t sub_10034838(void* arg1)
{
    sub_1000ac70((*(arg1 - 8) ^ (arg1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_10042620);
}

int32_t sub_10034860(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0((arg1 - 0x10));
}

int32_t sub_10034868(void* arg1)
{
    sub_1000ac70((*(arg1 - 0xc) ^ (arg1 - 8)));
    /* tailcall */
    return sub_1002b8d0(&data_100427a0);
}

int32_t sub_10034890(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0((arg1 - 0x10));
}

int32_t sub_10034898(void* arg1)
{
    sub_1000ac70((*(arg1 - 8) ^ (arg1 - 4)));
    /* tailcall */
    return sub_1002b8d0(&data_100427cc);
}

int32_t sub_100348c0(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0(*(arg1 + 4));
}

int32_t sub_100348c8(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((*(arg1 + 4) + 4));
}

int32_t sub_100348d3(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((*(arg1 + 4) + 0x24));
}

int32_t sub_100348de(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((*(arg1 + 4) + 0x44));
}

int32_t sub_100348e9(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((*(arg1 + 4) + 0x64));
}

int32_t sub_100348f4(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x14) ^ (arg1 - 0x10)));
    /* tailcall */
    return sub_1002b8d0(&data_10042818);
}

int32_t sub_10034910(void* arg1 @ ebp)
{
    *(arg1 + 4);
    int32_t ecx;
    /* tailcall */
    return sub_10006be0(ecx);
}

int32_t sub_10034918(void* arg1)
{
    sub_1000ac70((*(arg1 - 0xc) ^ (arg1 - 8)));
    /* tailcall */
    return sub_1002b8d0(&data_10042844);
}

int32_t __ehhandler$?_FullAliasWait@_TaskCollection@details@Concurrency@@AAEXPAV123@@Z(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x2c) ^ (arg1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_100428d0);
}

int32_t sub_10034960(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10033f00((*(arg1 + 4) + 4));
}

int32_t sub_1003496b(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x14) ^ (arg1 - 0x10)));
    /* tailcall */
    return sub_1002b8d0(&data_100428fc);
}

int32_t sub_10034990(void* arg1 @ ebp)
{
    /* tailcall */
    return j_sub_10001290(*(arg1 + 4));
}

int32_t sub_10034998(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x10) ^ (arg1 - 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_10042928);
}

int32_t sub_100349c0(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((arg1 - 0x34));
}

int32_t sub_100349c8(int32_t arg1 @ ebp)
{
    int32_t ecx;
    /* tailcall */
    return sub_10006be0(ecx);
}

int32_t sub_100349d0(int32_t arg1 @ ebp)
{
    int32_t ecx;
    /* tailcall */
    return sub_10006be0(ecx);
}

int32_t sub_100349d8(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0((arg1 - 0x78));
}

int32_t sub_100349e0(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0((arg1 - 0x80));
}

int32_t sub_100349e8(int32_t arg1 @ ebp)
{
    int32_t ecx;
    /* tailcall */
    return sub_10006be0(ecx);
}

int32_t sub_100349f0(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0((arg1 - 0x68));
}

int32_t sub_100349f8(void* arg1 @ ebp)
{
    int32_t result = (*(arg1 - 0x84) & 1);
    
    if (result == 0)
        return result;
    
    *(arg1 - 0x84) &= 0xfffffffe;
    int32_t ecx;
    /* tailcall */
    return sub_10006be0(ecx);
}

int32_t sub_10034a17(void* arg1)
{
    int32_t eax_1;
    void* edx;
    eax_1 = sub_1000ac70((*(arg1 - 0x90) ^ (arg1 - 0x8c)));
    sub_1000ac70((*(edx - 8) ^ (eax_1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_10042990);
}

int32_t sub_10034a50(void* arg1 @ ebp)
{
    /* tailcall */
    return j_sub_10001290(*(arg1 - 0x10));
}

int32_t sub_10034a58(void* arg1)
{
    sub_1000ac70((*(arg1 - 0xc) ^ (arg1 - 8)));
    /* tailcall */
    return sub_1002b8d0(&data_100429bc);
}

int32_t sub_10034a80(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_1000c1f0(*(arg1 - 0x10));
}

int32_t sub_10034a88(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x10) ^ (arg1 - 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_100429e8);
}

int32_t sub_10034ab0(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0(*(arg1 + 4));
}

int32_t sub_10034ab8(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((*(arg1 + 4) + 4));
}

int32_t sub_10034ac3(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((*(arg1 + 4) + 0x24));
}

int32_t sub_10034ace(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((*(arg1 + 4) + 0x44));
}

int32_t sub_10034ad9(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((*(arg1 + 4) + 0x64));
}

int32_t sub_10034ae4(void* arg1)
{
    sub_1000ac70((*(arg1 - 0xc) ^ (arg1 - 8)));
    /* tailcall */
    return sub_1002b8d0(&data_10042a34);
}

int32_t sub_10034b00(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((arg1 - 0x34));
}

int32_t sub_10034b08(int32_t arg1 @ ebp)
{
    int32_t ecx;
    /* tailcall */
    return sub_10006be0(ecx);
}

int32_t sub_10034b10(int32_t arg1 @ ebp)
{
    int32_t ecx;
    /* tailcall */
    return sub_10006be0(ecx);
}

int32_t sub_10034b18(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0((arg1 - 0x6c));
}

int32_t sub_10034b20(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0((arg1 - 0x74));
}

int32_t sub_10034b28(int32_t arg1 @ ebp)
{
    int32_t ecx;
    /* tailcall */
    return sub_10006be0(ecx);
}

int32_t sub_10034b30(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0((arg1 - 0x68));
}

int32_t sub_10034b38(void* arg1 @ ebp)
{
    int32_t result = (*(arg1 - 0x80) & 1);
    
    if (result == 0)
        return result;
    
    *(arg1 - 0x80) &= 0xfffffffe;
    int32_t ecx;
    /* tailcall */
    return sub_10006be0(ecx);
}

int32_t sub_10034b51(void* arg1)
{
    int32_t eax_1;
    void* edx;
    eax_1 = sub_1000ac70((*(arg1 - 0x88) ^ (arg1 - 0x84)));
    sub_1000ac70((*(edx - 8) ^ (eax_1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_10042a98);
}

int32_t sub_10034b80(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((arg1 - 0x34));
}

int32_t sub_10034b88(int32_t arg1 @ ebp)
{
    int32_t ecx;
    /* tailcall */
    return sub_10006be0(ecx);
}

int32_t sub_10034b90(int32_t arg1 @ ebp)
{
    int32_t ecx;
    /* tailcall */
    return sub_10006be0(ecx);
}

int32_t sub_10034b98(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0((arg1 - 0x78));
}

int32_t sub_10034ba0(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0((arg1 - 0x84));
}

int32_t sub_10034bab(int32_t arg1 @ ebp)
{
    int32_t ecx;
    /* tailcall */
    return sub_10006be0(ecx);
}

int32_t sub_10034bb3(int32_t arg1 @ ebp)
{
    int32_t ecx;
    /* tailcall */
    return sub_10006be0(ecx);
}

int32_t sub_10034bbb(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0((arg1 - 0x74));
}

int32_t sub_10034bc3(int32_t arg1 @ ebp)
{
    int32_t ecx;
    /* tailcall */
    return sub_10006be0(ecx);
}

int32_t sub_10034bcb(void* arg1)
{
    int32_t eax_1;
    void* edx;
    eax_1 = sub_1000ac70((*(arg1 - 0x98) ^ (arg1 - 0x94)));
    sub_1000ac70((*(edx - 8) ^ (eax_1 + 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_10042b08);
}

int32_t sub_10034c00(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005900(*(arg1 - 0x10));
}

int32_t sub_10034c08(void* arg1)
{
    sub_1000ac70((*(arg1 - 0xc) ^ (arg1 - 8)));
    /* tailcall */
    return sub_1002b8d0(&data_10042b34);
}

int32_t sub_10034c30(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005c90((*(arg1 - 0x10) - 0x50));
}

int32_t sub_10034c3b(void* arg1)
{
    sub_1000ac70((*(arg1 - 0xc) ^ (arg1 - 8)));
    /* tailcall */
    return sub_1002b8d0(&data_10042b60);
}

int32_t sub_10034c60(void* arg1 @ ebp)
{
    /* tailcall */
    return j_sub_10001290(*(arg1 - 0x10));
}

int32_t sub_10034c68(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x10) ^ (arg1 - 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_10042b8c);
}

int32_t sub_10034c90(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_1000c1f0(*(arg1 + 4));
}

int32_t sub_10034c98(void* arg1)
{
    sub_1000ac70((*(arg1 - 8) ^ (arg1 - 4)));
    /* tailcall */
    return sub_1002b8d0(&data_10042bb8);
}

int32_t sub_10034cc0(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005630((arg1 - 0x48));
}

int32_t sub_10034cc8(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005630((arg1 - 0x44));
}

int32_t sub_10034cd0(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005630((arg1 - 0x40));
}

int32_t sub_10034cd8(void* arg1)
{
    int32_t eax_1;
    void* edx;
    eax_1 = sub_1000ac70((*(arg1 - 0x54) ^ (arg1 - 0x50)));
    sub_1000ac70((*(edx - 8) ^ (eax_1 + 0x10)));
    /* tailcall */
    return sub_1002b8d0(&data_10042bf4);
}

int32_t sub_10034d00(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((arg1 - 0xa8));
}

int32_t sub_10034d0b(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((arg1 - 0xa8));
}

int32_t sub_10034d16(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((arg1 - 0x5c));
}

int32_t sub_10034d1e(void* arg1)
{
    sub_1000ac70((*(arg1 - 0xa0) ^ (arg1 - 0x9c)));
    /* tailcall */
    return sub_1002b8d0(&data_10042c30);
}

int32_t sub_10034d40(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005800((arg1 - 0x2c));
}

int32_t sub_10034d48(void* arg1 @ ebp)
{
    int32_t result = (*(arg1 - 0x30) & 1);
    
    if (result == 0)
        return result;
    
    *(arg1 - 0x30) &= 0xfffffffe;
    /* tailcall */
    return sub_10005800(*(arg1 + 8));
}

int32_t sub_10034d61(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x38) ^ (arg1 - 0x34)));
    /* tailcall */
    return sub_1002b8d0(&data_10042c64);
}

int32_t sub_10034d80(void* arg1 @ ebp)
{
    int32_t var_4 = 0x311;
    char const* const var_8 = "E:\Program Files\Microsoft Visua…";
    int32_t var_c = *(arg1 - 0x98);
    return sub_10001620(*(arg1 - 0x9c));
}

int32_t sub_10034da1(void* arg1 @ ebp)
{
    int32_t result = (*(arg1 - 0xc0) & 1);
    
    if (result == 0)
        return result;
    
    *(arg1 - 0xc0) &= 0xfffffffe;
    /* tailcall */
    return sub_10005800((arg1 - 0xbc));
}

int32_t sub_10034dc3(void* arg1)
{
    sub_1000ac70((*(arg1 - 0xc0) ^ (arg1 - 0xbc)));
    /* tailcall */
    return sub_1002b8d0(&data_10042ca0);
}

int32_t sub_10034df0(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100328d0((arg1 - 0x1c));
}

int32_t sub_10034df8(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x28) ^ (arg1 - 0x24)));
    /* tailcall */
    return sub_1002b8d0(&data_10042ccc);
}

int32_t sub_10034e20(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10001670((arg1 - 0x10));
}

int32_t sub_10034e28(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x10) ^ (arg1 - 0xc)));
    /* tailcall */
    return sub_1002b8d0(&data_10042cf8);
}

int32_t sub_10034e50(void* arg1 @ ebp)
{
    int32_t var_4 = 0x700;
    char const* const var_8 = "E:\Program Files\Microsoft Visua…";
    int32_t var_c = *(arg1 - 0x98);
    return sub_10001620(*(arg1 - 0x9c));
}

int32_t sub_10034e71(void* arg1 @ ebp)
{
    int32_t result = (*(arg1 - 0xc0) & 1);
    
    if (result == 0)
        return result;
    
    *(arg1 - 0xc0) &= 0xfffffffe;
    /* tailcall */
    return sub_10005800((arg1 - 0xbc));
}

int32_t sub_10034e93(void* arg1)
{
    sub_1000ac70((*(arg1 - 0xc0) ^ (arg1 - 0xbc)));
    /* tailcall */
    return sub_1002b8d0(&data_10042d34);
}

int32_t sub_10034ec0(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10001670((arg1 + 4));
}

int32_t sub_10034ec8(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x14) ^ (arg1 - 0x10)));
    /* tailcall */
    return sub_1002b8d0(&data_10042d60);
}

int32_t sub_10034ef0(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x14) ^ (arg1 - 0x10)));
    /* tailcall */
    return sub_1002b8d0(&data_10042d8c);
}

int32_t sub_10034f10(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_100058f0((*(arg1 + 4) + 8));
}

int32_t sub_10034f1b(void* arg1)
{
    sub_1000ac70((*(arg1 - 0xc) ^ (arg1 - 8)));
    /* tailcall */
    return sub_1002b8d0(&data_10042dc8);
}

int32_t sub_10034f40(void* arg1 @ ebp)
{
    int32_t result = (*(arg1 - 0x14) & 1);
    
    if (result == 0)
        return result;
    
    *(arg1 - 0x14) &= 0xfffffffe;
    /* tailcall */
    return sub_100058e0((*(arg1 - 0x10) + 0x5c));
}

int32_t sub_10034f5c(void* arg1 @ ebp)
{
    /* tailcall */
    return sub_10005c90((*(arg1 - 0x10) + 0xc));
}

int32_t sub_10034f67(void* arg1)
{
    sub_1000ac70((*(arg1 - 0x18) ^ (arg1 - 0x14)));
    /* tailcall */
    return sub_1002b8d0(&data_10042dfc);
}

int32_t sub_10034f90()
{
    int32_t* (__fastcall* var_4)(void* arg1) = sub_10002040;
    ___BuildCatchObject(0x10048ad8, 0x90, 0xd, sub_10005b10);
    return sub_1000cf10(sub_10035510);
}

int32_t sub_10034fc0()
{
    sub_100086a0(&data_10045520);
    return sub_1000cf10(___p__fmode);
}

int32_t sub_10034fe0()
{
    char result = sub_10008750();
    data_10045550 = result;
    return result;
}

int32_t sub_10035000()
{
    sub_10008930(&data_10045554, sub_1000ed60);
    return sub_1000cf10(___dstbias);
}

int32_t* sub_10035030()
{
    return sub_10009590(&data_1004555c, "atlTraceGeneral", 0);
}

int32_t* sub_10035050()
{
    return sub_10009590(&data_10045560, "atlTraceCOM", 0);
}

int32_t* sub_10035070()
{
    return sub_10009590(&data_10045564, "atlTraceQI", 0);
}

int32_t* sub_10035090()
{
    return sub_10009590(&data_10045568, "atlTraceRegistrar", 0);
}

int32_t* sub_100350b0()
{
    return sub_10009590(&data_1004556c, "atlTraceRefcount", 0);
}

int32_t* sub_100350d0()
{
    return sub_10009590(&data_10045570, "atlTraceWindowing", 0);
}

int32_t* sub_100350f0()
{
    return sub_10009590(&data_10045574, "atlTraceControls", 0);
}

int32_t* sub_10035110()
{
    return sub_10009590(&data_10045578, "atlTraceHosting", 0);
}

int32_t* sub_10035130()
{
    return sub_10009590(&data_1004557c, "atlTraceDBClient", 0);
}

int32_t* sub_10035150()
{
    return sub_10009590(&data_10045580, "atlTraceDBProvider", 0);
}

int32_t* sub_10035170()
{
    return sub_10009590(&data_10045584, "atlTraceSnapin", 0);
}

int32_t* sub_10035190()
{
    return sub_10009590(&data_10045588, "atlTraceNotImpl", 0);
}

int32_t* sub_100351b0()
{
    return sub_10009590(&data_1004558c, "atlTraceAllocation", 0);
}

int32_t* sub_100351d0()
{
    return sub_10009590(&data_10045590, "atlTraceException", 0);
}

int32_t* sub_100351f0()
{
    return sub_10009590(&data_10045594, "atlTraceTime", 0);
}

int32_t* sub_10035210()
{
    return sub_10009590(&data_10045598, "atlTraceCache", 0);
}

int32_t* sub_10035230()
{
    return sub_10009590(&data_1004559c, "atlTraceStencil", 0);
}

int32_t* sub_10035250()
{
    return sub_10009590(&data_100455a0, "atlTraceString", 0);
}

int32_t* sub_10035270()
{
    return sub_10009590(&data_100455a4, "atlTraceMap", 0);
}

int32_t* sub_10035290()
{
    return sub_10009590(&data_100455a8, "atlTraceUtil", 0);
}

int32_t* sub_100352b0()
{
    return sub_10009590(&data_100455ac, "atlTraceSecurity", 0);
}

int32_t* sub_100352d0()
{
    return sub_10009590(&data_100455b0, "atlTraceSync", 0);
}

int32_t* sub_100352f0()
{
    return sub_10009590(&data_100455b4, "atlTraceISAPI", 0);
}

int32_t* sub_10035310()
{
    return sub_10009590(&data_100455b8, "atlTraceUser", 0);
}

int32_t* sub_10035330()
{
    return sub_10009590(&data_100455bc, "atlTraceUser2", 0);
}

int32_t* sub_10035350()
{
    return sub_10009590(&data_100455c0, "atlTraceUser3", 0);
}

int32_t* sub_10035370()
{
    return sub_10009590(&data_100455c4, "atlTraceUser4", 0);
}

int32_t sub_10035390()
{
    sub_10009630(&data_100455c8, GetProcessHeap());
    return sub_1000cf10(___daylight);
}

int32_t sub_100353c0()
{
    sub_10009830(&data_100455d4, 0x100455c8);
    return sub_1000cf10(get_environment_nolock);
}

int32_t sub_100353f0()
{
    std::_Init_locks::_Init_locks(0x10046178);
    return sub_1000cf10(get_environment);
}

int32_t std::classic_locale::()
{
    int32_t var_8 = 0;
    return sub_1000cf10(get_other_environment);
}

int32_t* sub_10035430()
{
    return sub_10001090(&data_1004618c, 0);
}

int32_t* sub_10035450()
{
    return sub_10001090(&data_10046194, 0);
}

int32_t* sub_10035470()
{
    return sub_10001090(&data_10046198, 0);
}

int32_t* sub_10035490()
{
    return sub_10001090(&data_100461a0, 0);
}

int32_t* sub_100354b0()
{
    return sub_10001090(&data_10046190, 0);
}

int32_t sub_100354d0()
{
    std::_Init_locks::_Init_locks(0x10046240);
    return sub_1000cf10(sub_10035630);
}

int32_t __is_c_termination_complete()
{
    return sub_1000cf10(0x10035650);
}

int32_t sub_10035510()
{
    return sub_1000b530(0x10048ad8, 0x90, 0xd, sub_10002040);
}

int32_t* ___p__fmode()
{
    return sub_10008970(&data_10045520);
}

int32_t ___dstbias()
{
    sub_10008a40(&data_10045554);
    return 1;
}

int32_t* ___daylight()
{
    return sub_100097d0(&data_100455c8);
}

int32_t* get_environment_nolock()
{
    return std::_Func_base<void,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil>::~_Func_base<void,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil,struct std::_Nil>(&data_100455d4);
}

int32_t ___p__environ()
{
    return sub_100010f0(&data_100455f4);
}

int32_t get_environment()
{
    return std::_Init_locks::~_Init_locks();
}

int32_t get_other_environment()
{
    return sub_10001670(&data_1004619c);
}

int32_t sub_10035610()
{
    return sub_100010f0(&data_100461a8);
}

int32_t sub_10035630()
{
    return std::_Init_locks::~_Init_locks();
}

